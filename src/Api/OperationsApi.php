<?php
/**
 * OperationsApi
 * PHP version 8.1
 *
 * @package  Tzkt
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * TzKT API
 *
 * # Introduction    TzKT is the most widely used tool in Tezos that provides you with convenient and flexible access to the Tezos blockchain data, processed and indexed by its own indexer.   You can fetch all historical data via REST API, or subscribe for real-time data via WebSocket API. TzKT was built by the joint efforts of the entire Tezos community   to help developers build more services and dapps on top of Tezos.    TzKT Indexer and API are [open-source](https://github.com/baking-bad/tzkt), so don't be afraid to depend on the third-party service,  because you can always clone, build and run it yourself to have full control over all the components.    Feel free to contact us if you have any questions or feature requests.  Your feedback is much appreciated!    - Discord: https://discord.gg/aG8XKuwsQd  - Telegram: https://t.me/baking_bad_chat  - Slack: https://tezos-dev.slack.com/archives/CV5NX7F2L  - Twitter: https://twitter.com/TezosBakingBad  - Email: hello@bakingbad.dev    And don't forget to star TzKT [on GitHub](https://github.com/baking-bad/tzkt) if you like it ðŸ˜Š    # Get Started    There are two API services provided for public use:  - **Free TzKT API** with free anonymous access;  - **TzKT Pro** with paid subscriptions with increased rate limits, off-chain data, extended support and business-level SLA.    You can find more details about differences between available tiers [here](https://tzkt.io/api).    ## Free TzKT API    Free-tier TzKT API is the best way to get started and explore available Tezos data and API functionality.  It doesn't require authorization and is free for everyone and for both commercial and non-commercial use.    > #### Note: attribution required  If you use free-tier TzKT API, you **must** mention it on your website or application by placing the label  \"Powered by TzKT API\", or \"Built with TzKT API\", or \"Data provided by TzKT API\" with a direct link to [tzkt.io](https://tzkt.io).    It's available for the following Tezos networks with the following base URLs:    - Mainnet: `https://api.tzkt.io/` or `https://api.mainnet.tzkt.io/` ([view docs](https://api.tzkt.io))  - Ghostnet: `https://api.ghostnet.tzkt.io/` ([view docs](https://api.ghostnet.tzkt.io))  - Rionet: `https://api.rionet.tzkt.io/` ([view docs](https://api.rionet.tzkt.io))    ### Sending Requests    To send a request to Free TzKT API you need literally nothing. Just take the base URL of the particular network  (for example, Tezos mainnet: `https://api.tzkt.io`) and append the path of the particular endpoint  (for example, chain's head: `/v1/head`), that's pretty much it:     ```bash  curl https://api.tzkt.io/v1/head  ```    Read through this documentation to explore available endpoints, query parameters  (note, if you click on a query parameter, you will see available modes, such as `.eq`, `.in`, etc.)  and response models. If you have any questions, do not hesitate to ask for support, Tezos community has always been very friendly! ðŸ˜‰    ### Rate Limits    Please, refer to https://tzkt.io/api to check relevant rate limits.    If you exceed the limit, the API will respond with `HTTP 429` status code.    ## TzKT Pro    TzKT Pro is intended for professional use, for those who seek for extended capabilities, performance, reliability and business-level SLA.  TzKT Pro service is provided via paid subscriptions. Please, refer to [Pricing Plans](https://tzkt.io/api) to check available tiers.    It's available for the following Tezos networks with the following base URLs:    - Mainnet: `https://pro.tzkt.io/` ([view docs](https://api.tzkt.io))  - Testnets: *let us know if you need TzKT Pro for testnets*    ### Authorization    To access TzKT Pro you will need to authorize requests with your personal API key, that you will receive on your email after purchasing a subscription.  This can be done by adding the query string parameter `?apikey={your_key}` or by adding the HTTP header `apikey: {your_key}`.    Note that you can have multiple API keys within a single subscription.    Keep your API keys private, do not publish it anywhere and do not hardcode it, especially in public repositories.  If your key was compromised, just let us know and we will issue a new one.    Also note that passing the API key via HTTP headers is more secure, because in HTTPS headers are encrypted,  but query string is not, so the key can be unintentionally exposed to third parties.    ### Sending Requests    Sending a request with the API key passed as a query string parameter:    ```bash  curl https://pro.tzkt.io/v1/head?apikey={your_key}  ```    Sending a request with the API key passed via an HTTP header:    ```bash  curl https://pro.tzkt.io/v1/head \\      -H 'apikey: {your_key}'  ```    ### Rate Limits    Please, refer to https://tzkt.io/api to check relevant rate limits for different pricing plans.    Also, TzKT Pro provides you with the additional HTTP headers to show the allowed limits, number of available requests  and the time remaining (in seconds) until the quota is reset. Here's an example:    ```  RateLimit-Limit: 50  RateLimit-Remaining: 49  RateLimit-Reset: 1  ```    It also sends general information about your rate limits per second and per day:    ```  X-RateLimit-Limit-Second: 50  X-RateLimit-Remaining-Second: 49  X-RateLimit-Limit-Day: 3000000  X-RateLimit-Remaining-Day: 2994953  ```    If you exceed the limit, the API will respond with `HTTP 429` status code.
 *
 * The version of the OpenAPI document: 1.14.9
 * Contact: hello@bakingbad.dev
 * @generated Generated by: https://openapi-generator.tech
 * Generator version: 7.12.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Tzkt\Api;

use InvalidArgumentException;
use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use GuzzleHttp\Promise\PromiseInterface;
use Tzkt\ApiException;
use Tzkt\Configuration;
use Tzkt\HeaderSelector;
use Tzkt\ObjectSerializer;

/**
 * OperationsApi Class Doc Comment
 *
 * @package  Tzkt
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class OperationsApi
{
    /**
     * @var ClientInterface
     */
    protected ClientInterface $client;

    /**
     * @var Configuration
     */
    protected Configuration $config;

    /**
     * @var HeaderSelector
     */
    protected HeaderSelector $headerSelector;

    /**
     * @var int Host index
     */
    protected int $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'operationsGetActivationByHash' => [
            'application/json',
        ],
        'operationsGetActivations' => [
            'application/json',
        ],
        'operationsGetActivationsCount' => [
            'application/json',
        ],
        'operationsGetAutostakingOps' => [
            'application/json',
        ],
        'operationsGetAutostakingOpsCount' => [
            'application/json',
        ],
        'operationsGetBaking' => [
            'application/json',
        ],
        'operationsGetBakingById' => [
            'application/json',
        ],
        'operationsGetBakingCount' => [
            'application/json',
        ],
        'operationsGetBallotByHash' => [
            'application/json',
        ],
        'operationsGetBallots' => [
            'application/json',
        ],
        'operationsGetBallotsCount' => [
            'application/json',
        ],
        'operationsGetByHash' => [
            'application/json',
        ],
        'operationsGetByHashCounter' => [
            'application/json',
        ],
        'operationsGetByHashCounterNonce' => [
            'application/json',
        ],
        'operationsGetDalAttestationRewardById' => [
            'application/json',
        ],
        'operationsGetDalAttestationRewards' => [
            'application/json',
        ],
        'operationsGetDalAttestationRewardsCount' => [
            'application/json',
        ],
        'operationsGetDalEntrapmentEvidenceOps' => [
            'application/json',
        ],
        'operationsGetDalEntrapmentEvidenceOpsByHash' => [
            'application/json',
        ],
        'operationsGetDalEntrapmentEvidenceOpsCount' => [
            'application/json',
        ],
        'operationsGetDalPublishCommitmentOps' => [
            'application/json',
        ],
        'operationsGetDalPublishCommitmentOpsCount' => [
            'application/json',
        ],
        'operationsGetDelegationByHash' => [
            'application/json',
        ],
        'operationsGetDelegationStatus' => [
            'application/json',
        ],
        'operationsGetDelegations' => [
            'application/json',
        ],
        'operationsGetDelegationsCount' => [
            'application/json',
        ],
        'operationsGetDoubleBaking' => [
            'application/json',
        ],
        'operationsGetDoubleBakingByHash' => [
            'application/json',
        ],
        'operationsGetDoubleBakingCount' => [
            'application/json',
        ],
        'operationsGetDoubleEndorsing' => [
            'application/json',
        ],
        'operationsGetDoubleEndorsingByHash' => [
            'application/json',
        ],
        'operationsGetDoubleEndorsingCount' => [
            'application/json',
        ],
        'operationsGetDoublePreendorsing' => [
            'application/json',
        ],
        'operationsGetDoublePreendorsingByHash' => [
            'application/json',
        ],
        'operationsGetDoublePreendorsingCount' => [
            'application/json',
        ],
        'operationsGetDrainDelegateByHash' => [
            'application/json',
        ],
        'operationsGetDrainDelegateOps' => [
            'application/json',
        ],
        'operationsGetDrainDelegateOpsCount' => [
            'application/json',
        ],
        'operationsGetEndorsementByHash' => [
            'application/json',
        ],
        'operationsGetEndorsements' => [
            'application/json',
        ],
        'operationsGetEndorsementsCount' => [
            'application/json',
        ],
        'operationsGetEndorsingRewardById' => [
            'application/json',
        ],
        'operationsGetEndorsingRewards' => [
            'application/json',
        ],
        'operationsGetEndorsingRewardsCount' => [
            'application/json',
        ],
        'operationsGetIncreasePaidStorageByHash' => [
            'application/json',
        ],
        'operationsGetIncreasePaidStorageCount' => [
            'application/json',
        ],
        'operationsGetIncreasePaidStorageOps' => [
            'application/json',
        ],
        'operationsGetMigrationById' => [
            'application/json',
        ],
        'operationsGetMigrations' => [
            'application/json',
        ],
        'operationsGetMigrationsCount' => [
            'application/json',
        ],
        'operationsGetNonceRevelationByHash' => [
            'application/json',
        ],
        'operationsGetNonceRevelations' => [
            'application/json',
        ],
        'operationsGetNonceRevelationsCount' => [
            'application/json',
        ],
        'operationsGetOriginationByHash' => [
            'application/json',
        ],
        'operationsGetOriginationStatus' => [
            'application/json',
        ],
        'operationsGetOriginations' => [
            'application/json',
        ],
        'operationsGetOriginationsCount' => [
            'application/json',
        ],
        'operationsGetPreendorsementByHash' => [
            'application/json',
        ],
        'operationsGetPreendorsements' => [
            'application/json',
        ],
        'operationsGetPreendorsementsCount' => [
            'application/json',
        ],
        'operationsGetProposalByHash' => [
            'application/json',
        ],
        'operationsGetProposals' => [
            'application/json',
        ],
        'operationsGetProposalsCount' => [
            'application/json',
        ],
        'operationsGetRegisterConstantByHash' => [
            'application/json',
        ],
        'operationsGetRegisterConstantStatus' => [
            'application/json',
        ],
        'operationsGetRegisterConstants' => [
            'application/json',
        ],
        'operationsGetRegisterConstantsCount' => [
            'application/json',
        ],
        'operationsGetRevealByHash' => [
            'application/json',
        ],
        'operationsGetRevealStatus' => [
            'application/json',
        ],
        'operationsGetReveals' => [
            'application/json',
        ],
        'operationsGetRevealsCount' => [
            'application/json',
        ],
        'operationsGetRevelationPenalties' => [
            'application/json',
        ],
        'operationsGetRevelationPenaltiesCount' => [
            'application/json',
        ],
        'operationsGetRevelationPenaltyById' => [
            'application/json',
        ],
        'operationsGetSetDelegateParametersOps' => [
            'application/json',
        ],
        'operationsGetSetDelegateParametersOpsCount' => [
            'application/json',
        ],
        'operationsGetSetDepositsLimitByHash' => [
            'application/json',
        ],
        'operationsGetSetDepositsLimitStatus' => [
            'application/json',
        ],
        'operationsGetSetDepositsLimits' => [
            'application/json',
        ],
        'operationsGetSetDepositsLimitsCount' => [
            'application/json',
        ],
        'operationsGetSmartRollupAddMessagesOps' => [
            'application/json',
        ],
        'operationsGetSmartRollupAddMessagesOpsCount' => [
            'application/json',
        ],
        'operationsGetSmartRollupCementOps' => [
            'application/json',
        ],
        'operationsGetSmartRollupCementOpsCount' => [
            'application/json',
        ],
        'operationsGetSmartRollupExecuteOps' => [
            'application/json',
        ],
        'operationsGetSmartRollupExecuteOpsCount' => [
            'application/json',
        ],
        'operationsGetSmartRollupOriginateOps' => [
            'application/json',
        ],
        'operationsGetSmartRollupOriginateOpsCount' => [
            'application/json',
        ],
        'operationsGetSmartRollupPublishOps' => [
            'application/json',
        ],
        'operationsGetSmartRollupPublishOpsCount' => [
            'application/json',
        ],
        'operationsGetSmartRollupRecoverBondOps' => [
            'application/json',
        ],
        'operationsGetSmartRollupRecoverBondOpsCount' => [
            'application/json',
        ],
        'operationsGetSmartRollupRefuteOps' => [
            'application/json',
        ],
        'operationsGetSmartRollupRefuteOpsCount' => [
            'application/json',
        ],
        'operationsGetStakingOps' => [
            'application/json',
        ],
        'operationsGetStakingOpsCount' => [
            'application/json',
        ],
        'operationsGetStatus' => [
            'application/json',
        ],
        'operationsGetTransactionByHash' => [
            'application/json',
        ],
        'operationsGetTransactionByHashCounter' => [
            'application/json',
        ],
        'operationsGetTransactionByHashCounterNonce' => [
            'application/json',
        ],
        'operationsGetTransactionStatus' => [
            'application/json',
        ],
        'operationsGetTransactions' => [
            'application/json',
        ],
        'operationsGetTransactionsCount' => [
            'application/json',
        ],
        'operationsGetTransferTicketOps' => [
            'application/json',
        ],
        'operationsGetTransferTicketOpsByHash' => [
            'application/json',
        ],
        'operationsGetTransferTicketOpsCount' => [
            'application/json',
        ],
        'operationsGetTransferTicketStatus' => [
            'application/json',
        ],
        'operationsGetTxRollupCommitOps' => [
            'application/json',
        ],
        'operationsGetTxRollupCommitOpsByHash' => [
            'application/json',
        ],
        'operationsGetTxRollupCommitOpsCount' => [
            'application/json',
        ],
        'operationsGetTxRollupCommitStatus' => [
            'application/json',
        ],
        'operationsGetTxRollupDispatchTicketsOps' => [
            'application/json',
        ],
        'operationsGetTxRollupDispatchTicketsOpsByHash' => [
            'application/json',
        ],
        'operationsGetTxRollupDispatchTicketsOpsCount' => [
            'application/json',
        ],
        'operationsGetTxRollupDispatchTicketsStatus' => [
            'application/json',
        ],
        'operationsGetTxRollupFinalizeCommitmentOps' => [
            'application/json',
        ],
        'operationsGetTxRollupFinalizeCommitmentOpsByHash' => [
            'application/json',
        ],
        'operationsGetTxRollupFinalizeCommitmentOpsCount' => [
            'application/json',
        ],
        'operationsGetTxRollupFinalizeCommitmentStatus' => [
            'application/json',
        ],
        'operationsGetTxRollupOriginationOps' => [
            'application/json',
        ],
        'operationsGetTxRollupOriginationOpsByHash' => [
            'application/json',
        ],
        'operationsGetTxRollupOriginationOpsCount' => [
            'application/json',
        ],
        'operationsGetTxRollupOriginationStatus' => [
            'application/json',
        ],
        'operationsGetTxRollupRejectionOps' => [
            'application/json',
        ],
        'operationsGetTxRollupRejectionOpsByHash' => [
            'application/json',
        ],
        'operationsGetTxRollupRejectionOpsCount' => [
            'application/json',
        ],
        'operationsGetTxRollupRejectionStatus' => [
            'application/json',
        ],
        'operationsGetTxRollupRemoveCommitmentOps' => [
            'application/json',
        ],
        'operationsGetTxRollupRemoveCommitmentOpsByHash' => [
            'application/json',
        ],
        'operationsGetTxRollupRemoveCommitmentOpsCount' => [
            'application/json',
        ],
        'operationsGetTxRollupRemoveCommitmentStatus' => [
            'application/json',
        ],
        'operationsGetTxRollupReturnBondOps' => [
            'application/json',
        ],
        'operationsGetTxRollupReturnBondOpsByHash' => [
            'application/json',
        ],
        'operationsGetTxRollupReturnBondOpsCount' => [
            'application/json',
        ],
        'operationsGetTxRollupReturnBondStatus' => [
            'application/json',
        ],
        'operationsGetTxRollupSubmitBatchOps' => [
            'application/json',
        ],
        'operationsGetTxRollupSubmitBatchOpsByHash' => [
            'application/json',
        ],
        'operationsGetTxRollupSubmitBatchOpsCount' => [
            'application/json',
        ],
        'operationsGetTxRollupSubmitBatchStatus' => [
            'application/json',
        ],
        'operationsGetUpdateConsensusKeyByHash' => [
            'application/json',
        ],
        'operationsGetUpdateConsensusKeyOps' => [
            'application/json',
        ],
        'operationsGetUpdateConsensusKeyOpsCount' => [
            'application/json',
        ],
        'operationsGetVdfRevelationByHash' => [
            'application/json',
        ],
        'operationsGetVdfRevelations' => [
            'application/json',
        ],
        'operationsGetVdfRevelationsCount' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface|null $client
     * @param Configuration|null   $config
     * @param HeaderSelector|null  $selector
     * @param int                  $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex(int $hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex(): int
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig(): Configuration
    {
        return $this->config;
    }

    /**
     * Operation operationsGetActivationByHash
     *
     * Get activation by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetActivationByHash'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\ActivationOperation[]
     */
    public function operationsGetActivationByHash(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetActivationByHash'][0]
    ): array
    {
        list($response) = $this->operationsGetActivationByHashWithHttpInfo($hash, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetActivationByHashWithHttpInfo
     *
     * Get activation by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetActivationByHash'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\ActivationOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetActivationByHashWithHttpInfo(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetActivationByHash'][0]
    ): array
    {
        $request = $this->operationsGetActivationByHashRequest($hash, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\ActivationOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\ActivationOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\ActivationOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\ActivationOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\ActivationOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetActivationByHashAsync
     *
     * Get activation by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetActivationByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetActivationByHashAsync(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetActivationByHash'][0]
    ): PromiseInterface
    {
        return $this->operationsGetActivationByHashAsyncWithHttpInfo($hash, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetActivationByHashAsyncWithHttpInfo
     *
     * Get activation by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetActivationByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetActivationByHashAsyncWithHttpInfo(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetActivationByHash'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\ActivationOperation[]';
        $request = $this->operationsGetActivationByHashRequest($hash, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetActivationByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetActivationByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetActivationByHashRequest(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetActivationByHash'][0]
    ): Request
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetActivationByHash'
            );
        }



        $resourcePath = '/v1/operations/activations/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetActivations
     *
     * Get activations
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $account Filters activations by account. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters activations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters activations by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts activations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;balance&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetActivations'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\ActivationOperation[]
     */
    public function operationsGetActivations(
        ?\Tzkt\Model\AccountsGetDelegateParameter $account = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetActivations'][0]
    ): array
    {
        list($response) = $this->operationsGetActivationsWithHttpInfo($account, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetActivationsWithHttpInfo
     *
     * Get activations
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $account Filters activations by account. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters activations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters activations by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts activations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;balance&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetActivations'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\ActivationOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetActivationsWithHttpInfo(
        ?\Tzkt\Model\AccountsGetDelegateParameter $account = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetActivations'][0]
    ): array
    {
        $request = $this->operationsGetActivationsRequest($account, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\ActivationOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\ActivationOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\ActivationOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\ActivationOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\ActivationOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetActivationsAsync
     *
     * Get activations
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $account Filters activations by account. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters activations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters activations by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts activations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;balance&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetActivations'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetActivationsAsync(
        ?\Tzkt\Model\AccountsGetDelegateParameter $account = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetActivations'][0]
    ): PromiseInterface
    {
        return $this->operationsGetActivationsAsyncWithHttpInfo($account, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetActivationsAsyncWithHttpInfo
     *
     * Get activations
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $account Filters activations by account. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters activations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters activations by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts activations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;balance&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetActivations'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetActivationsAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetDelegateParameter $account = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetActivations'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\ActivationOperation[]';
        $request = $this->operationsGetActivationsRequest($account, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetActivations'
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $account Filters activations by account. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters activations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters activations by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts activations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;balance&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetActivations'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetActivationsRequest(
        ?\Tzkt\Model\AccountsGetDelegateParameter $account = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetActivations'][0]
    ): Request
    {







        if ($limit !== null && $limit > 10000) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetActivations, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetActivations, must be bigger than or equal to 0.');
        }
        


        $resourcePath = '/v1/operations/activations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account,
            'account', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            '\Tzkt\Model\SelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            '\Tzkt\Model\SortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            '\Tzkt\Model\OffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetActivationsCount
     *
     * Get activations count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters activations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters activations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetActivationsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return int
     */
    public function operationsGetActivationsCount(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetActivationsCount'][0]
    ): int
    {
        list($response) = $this->operationsGetActivationsCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetActivationsCountWithHttpInfo
     *
     * Get activations count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters activations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters activations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetActivationsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetActivationsCountWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetActivationsCount'][0]
    ): array
    {
        $request = $this->operationsGetActivationsCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('int', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'int';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetActivationsCountAsync
     *
     * Get activations count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters activations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters activations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetActivationsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetActivationsCountAsync(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetActivationsCount'][0]
    ): PromiseInterface
    {
        return $this->operationsGetActivationsCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetActivationsCountAsyncWithHttpInfo
     *
     * Get activations count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters activations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters activations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetActivationsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetActivationsCountAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetActivationsCount'][0]
    ): PromiseInterface
    {
        $returnType = 'int';
        $request = $this->operationsGetActivationsCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetActivationsCount'
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters activations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters activations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetActivationsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetActivationsCountRequest(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetActivationsCount'][0]
    ): Request
    {




        $resourcePath = '/v1/operations/activations/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetAutostakingOps
     *
     * Get autostaking ops
     *
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by level of the block where the operation happened.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the block where the operation happened.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $baker Filter by baker.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetStakingOpsActionParameter|null $action Filter by autostaking action.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $amount Filter by amount.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $staking_updates_count Filter by number of staking updates.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int|null $limit Maximum number of items to return. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysSelectParameter|null $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetAutostakingOps'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\AutostakingOperation[]
     */
    public function operationsGetAutostakingOps(
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $baker = null,
        ?\Tzkt\Model\OperationsGetStakingOpsActionParameter $action = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $amount = null,
        ?\Tzkt\Model\AccountsGetIdParameter $staking_updates_count = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetAutostakingOps'][0]
    ): array
    {
        list($response) = $this->operationsGetAutostakingOpsWithHttpInfo($id, $level, $timestamp, $baker, $action, $amount, $staking_updates_count, $sort, $offset, $limit, $select, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetAutostakingOpsWithHttpInfo
     *
     * Get autostaking ops
     *
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by level of the block where the operation happened.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the block where the operation happened.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $baker Filter by baker.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetStakingOpsActionParameter|null $action Filter by autostaking action.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $amount Filter by amount.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $staking_updates_count Filter by number of staking updates.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int|null $limit Maximum number of items to return. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysSelectParameter|null $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetAutostakingOps'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\AutostakingOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetAutostakingOpsWithHttpInfo(
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $baker = null,
        ?\Tzkt\Model\OperationsGetStakingOpsActionParameter $action = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $amount = null,
        ?\Tzkt\Model\AccountsGetIdParameter $staking_updates_count = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetAutostakingOps'][0]
    ): array
    {
        $request = $this->operationsGetAutostakingOpsRequest($id, $level, $timestamp, $baker, $action, $amount, $staking_updates_count, $sort, $offset, $limit, $select, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\AutostakingOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\AutostakingOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\AutostakingOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\AutostakingOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\AutostakingOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetAutostakingOpsAsync
     *
     * Get autostaking ops
     *
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by level of the block where the operation happened.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the block where the operation happened.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $baker Filter by baker.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetStakingOpsActionParameter|null $action Filter by autostaking action.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $amount Filter by amount.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $staking_updates_count Filter by number of staking updates.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int|null $limit Maximum number of items to return. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysSelectParameter|null $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetAutostakingOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetAutostakingOpsAsync(
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $baker = null,
        ?\Tzkt\Model\OperationsGetStakingOpsActionParameter $action = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $amount = null,
        ?\Tzkt\Model\AccountsGetIdParameter $staking_updates_count = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetAutostakingOps'][0]
    ): PromiseInterface
    {
        return $this->operationsGetAutostakingOpsAsyncWithHttpInfo($id, $level, $timestamp, $baker, $action, $amount, $staking_updates_count, $sort, $offset, $limit, $select, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetAutostakingOpsAsyncWithHttpInfo
     *
     * Get autostaking ops
     *
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by level of the block where the operation happened.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the block where the operation happened.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $baker Filter by baker.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetStakingOpsActionParameter|null $action Filter by autostaking action.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $amount Filter by amount.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $staking_updates_count Filter by number of staking updates.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int|null $limit Maximum number of items to return. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysSelectParameter|null $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetAutostakingOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetAutostakingOpsAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $baker = null,
        ?\Tzkt\Model\OperationsGetStakingOpsActionParameter $action = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $amount = null,
        ?\Tzkt\Model\AccountsGetIdParameter $staking_updates_count = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetAutostakingOps'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\AutostakingOperation[]';
        $request = $this->operationsGetAutostakingOpsRequest($id, $level, $timestamp, $baker, $action, $amount, $staking_updates_count, $sort, $offset, $limit, $select, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetAutostakingOps'
     *
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by level of the block where the operation happened.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the block where the operation happened.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $baker Filter by baker.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetStakingOpsActionParameter|null $action Filter by autostaking action.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $amount Filter by amount.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $staking_updates_count Filter by number of staking updates.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int|null $limit Maximum number of items to return. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysSelectParameter|null $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetAutostakingOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetAutostakingOpsRequest(
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $baker = null,
        ?\Tzkt\Model\OperationsGetStakingOpsActionParameter $action = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $amount = null,
        ?\Tzkt\Model\AccountsGetIdParameter $staking_updates_count = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetAutostakingOps'][0]
    ): Request
    {










        if ($limit !== null && $limit > 10000) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetAutostakingOps, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetAutostakingOps, must be bigger than or equal to 0.');
        }
        



        $resourcePath = '/v1/operations/autostaking';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            '\Tzkt\Model\Int64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\TimestampParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $baker,
            'baker', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $action,
            'action', // param base name
            '\Tzkt\Model\StakingActionParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $amount,
            'amount', // param base name
            '\Tzkt\Model\Int64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $staking_updates_count,
            'stakingUpdatesCount', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            '\Tzkt\Model\SortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            '\Tzkt\Model\OffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            '\Tzkt\Model\SelectionParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetAutostakingOpsCount
     *
     * Get autostaking ops count
     *
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by level of the block where the operation happened.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the block where the operation happened.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $baker Filter by baker.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetStakingOpsActionParameter|null $action Filter by autostaking action.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $amount Filter by amount.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $staking_updates_count Filter by number of staking updates.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetAutostakingOpsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return int
     */
    public function operationsGetAutostakingOpsCount(
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $baker = null,
        ?\Tzkt\Model\OperationsGetStakingOpsActionParameter $action = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $amount = null,
        ?\Tzkt\Model\AccountsGetIdParameter $staking_updates_count = null,
        string $contentType = self::contentTypes['operationsGetAutostakingOpsCount'][0]
    ): int
    {
        list($response) = $this->operationsGetAutostakingOpsCountWithHttpInfo($id, $level, $timestamp, $baker, $action, $amount, $staking_updates_count, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetAutostakingOpsCountWithHttpInfo
     *
     * Get autostaking ops count
     *
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by level of the block where the operation happened.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the block where the operation happened.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $baker Filter by baker.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetStakingOpsActionParameter|null $action Filter by autostaking action.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $amount Filter by amount.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $staking_updates_count Filter by number of staking updates.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetAutostakingOpsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetAutostakingOpsCountWithHttpInfo(
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $baker = null,
        ?\Tzkt\Model\OperationsGetStakingOpsActionParameter $action = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $amount = null,
        ?\Tzkt\Model\AccountsGetIdParameter $staking_updates_count = null,
        string $contentType = self::contentTypes['operationsGetAutostakingOpsCount'][0]
    ): array
    {
        $request = $this->operationsGetAutostakingOpsCountRequest($id, $level, $timestamp, $baker, $action, $amount, $staking_updates_count, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('int', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'int';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetAutostakingOpsCountAsync
     *
     * Get autostaking ops count
     *
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by level of the block where the operation happened.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the block where the operation happened.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $baker Filter by baker.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetStakingOpsActionParameter|null $action Filter by autostaking action.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $amount Filter by amount.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $staking_updates_count Filter by number of staking updates.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetAutostakingOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetAutostakingOpsCountAsync(
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $baker = null,
        ?\Tzkt\Model\OperationsGetStakingOpsActionParameter $action = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $amount = null,
        ?\Tzkt\Model\AccountsGetIdParameter $staking_updates_count = null,
        string $contentType = self::contentTypes['operationsGetAutostakingOpsCount'][0]
    ): PromiseInterface
    {
        return $this->operationsGetAutostakingOpsCountAsyncWithHttpInfo($id, $level, $timestamp, $baker, $action, $amount, $staking_updates_count, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetAutostakingOpsCountAsyncWithHttpInfo
     *
     * Get autostaking ops count
     *
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by level of the block where the operation happened.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the block where the operation happened.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $baker Filter by baker.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetStakingOpsActionParameter|null $action Filter by autostaking action.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $amount Filter by amount.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $staking_updates_count Filter by number of staking updates.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetAutostakingOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetAutostakingOpsCountAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $baker = null,
        ?\Tzkt\Model\OperationsGetStakingOpsActionParameter $action = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $amount = null,
        ?\Tzkt\Model\AccountsGetIdParameter $staking_updates_count = null,
        string $contentType = self::contentTypes['operationsGetAutostakingOpsCount'][0]
    ): PromiseInterface
    {
        $returnType = 'int';
        $request = $this->operationsGetAutostakingOpsCountRequest($id, $level, $timestamp, $baker, $action, $amount, $staking_updates_count, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetAutostakingOpsCount'
     *
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by level of the block where the operation happened.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the block where the operation happened.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $baker Filter by baker.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetStakingOpsActionParameter|null $action Filter by autostaking action.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $amount Filter by amount.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $staking_updates_count Filter by number of staking updates.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetAutostakingOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetAutostakingOpsCountRequest(
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $baker = null,
        ?\Tzkt\Model\OperationsGetStakingOpsActionParameter $action = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $amount = null,
        ?\Tzkt\Model\AccountsGetIdParameter $staking_updates_count = null,
        string $contentType = self::contentTypes['operationsGetAutostakingOpsCount'][0]
    ): Request
    {









        $resourcePath = '/v1/operations/autostaking/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            '\Tzkt\Model\Int64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\TimestampParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $baker,
            'baker', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $action,
            'action', // param base name
            '\Tzkt\Model\StakingActionParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $amount,
            'amount', // param base name
            '\Tzkt\Model\Int64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $staking_updates_count,
            'stakingUpdatesCount', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetBaking
     *
     * Get baking
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $baker [DEPRECATED] (optional)
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters by any of the specified fields. Example: &#x60;anyof.proposer.producer&#x3D;tz1...&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $proposer Filters by block proposer. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $producer Filters by block producer. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters operations by internal TzKT id. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters baking operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters baking operations by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts baking operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetBaking'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\BakingOperation[]
     */
    public function operationsGetBaking(
        ?\Tzkt\Model\AccountsGetDelegateParameter $baker = null,
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $proposer = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $producer = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetBaking'][0]
    ): array
    {
        list($response) = $this->operationsGetBakingWithHttpInfo($baker, $anyof, $proposer, $producer, $id, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetBakingWithHttpInfo
     *
     * Get baking
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $baker [DEPRECATED] (optional)
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters by any of the specified fields. Example: &#x60;anyof.proposer.producer&#x3D;tz1...&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $proposer Filters by block proposer. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $producer Filters by block producer. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters operations by internal TzKT id. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters baking operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters baking operations by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts baking operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetBaking'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\BakingOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetBakingWithHttpInfo(
        ?\Tzkt\Model\AccountsGetDelegateParameter $baker = null,
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $proposer = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $producer = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetBaking'][0]
    ): array
    {
        $request = $this->operationsGetBakingRequest($baker, $anyof, $proposer, $producer, $id, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\BakingOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\BakingOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\BakingOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\BakingOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\BakingOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetBakingAsync
     *
     * Get baking
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $baker [DEPRECATED] (optional)
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters by any of the specified fields. Example: &#x60;anyof.proposer.producer&#x3D;tz1...&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $proposer Filters by block proposer. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $producer Filters by block producer. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters operations by internal TzKT id. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters baking operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters baking operations by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts baking operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetBaking'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetBakingAsync(
        ?\Tzkt\Model\AccountsGetDelegateParameter $baker = null,
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $proposer = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $producer = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetBaking'][0]
    ): PromiseInterface
    {
        return $this->operationsGetBakingAsyncWithHttpInfo($baker, $anyof, $proposer, $producer, $id, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetBakingAsyncWithHttpInfo
     *
     * Get baking
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $baker [DEPRECATED] (optional)
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters by any of the specified fields. Example: &#x60;anyof.proposer.producer&#x3D;tz1...&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $proposer Filters by block proposer. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $producer Filters by block producer. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters operations by internal TzKT id. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters baking operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters baking operations by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts baking operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetBaking'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetBakingAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetDelegateParameter $baker = null,
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $proposer = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $producer = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetBaking'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\BakingOperation[]';
        $request = $this->operationsGetBakingRequest($baker, $anyof, $proposer, $producer, $id, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetBaking'
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $baker [DEPRECATED] (optional)
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters by any of the specified fields. Example: &#x60;anyof.proposer.producer&#x3D;tz1...&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $proposer Filters by block proposer. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $producer Filters by block producer. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters operations by internal TzKT id. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters baking operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters baking operations by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts baking operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetBaking'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetBakingRequest(
        ?\Tzkt\Model\AccountsGetDelegateParameter $baker = null,
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $proposer = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $producer = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetBaking'][0]
    ): Request
    {











        if ($limit !== null && $limit > 10000) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetBaking, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetBaking, must be bigger than or equal to 0.');
        }
        


        $resourcePath = '/v1/operations/baking';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $baker,
            'baker', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $anyof,
            'anyof', // param base name
            '\Tzkt\Model\AnyOfParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $proposer,
            'proposer', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $producer,
            'producer', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            '\Tzkt\Model\Int64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            '\Tzkt\Model\SelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            '\Tzkt\Model\SortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            '\Tzkt\Model\OffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetBakingById
     *
     * Get baking by id
     *
     * @param  int $id Operation id (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetBakingById'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\BakingOperation
     */
    public function operationsGetBakingById(
        int $id,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetBakingById'][0]
    ): \Tzkt\Model\BakingOperation
    {
        list($response) = $this->operationsGetBakingByIdWithHttpInfo($id, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetBakingByIdWithHttpInfo
     *
     * Get baking by id
     *
     * @param  int $id Operation id (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetBakingById'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\BakingOperation, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetBakingByIdWithHttpInfo(
        int $id,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetBakingById'][0]
    ): array
    {
        $request = $this->operationsGetBakingByIdRequest($id, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\BakingOperation', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\BakingOperation' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\BakingOperation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\BakingOperation';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\BakingOperation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetBakingByIdAsync
     *
     * Get baking by id
     *
     * @param  int $id Operation id (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetBakingById'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetBakingByIdAsync(
        int $id,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetBakingById'][0]
    ): PromiseInterface
    {
        return $this->operationsGetBakingByIdAsyncWithHttpInfo($id, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetBakingByIdAsyncWithHttpInfo
     *
     * Get baking by id
     *
     * @param  int $id Operation id (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetBakingById'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetBakingByIdAsyncWithHttpInfo(
        int $id,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetBakingById'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\BakingOperation';
        $request = $this->operationsGetBakingByIdRequest($id, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetBakingById'
     *
     * @param  int $id Operation id (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetBakingById'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetBakingByIdRequest(
        int $id,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetBakingById'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling operationsGetBakingById'
            );
        }



        $resourcePath = '/v1/operations/baking/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetBakingCount
     *
     * Get baking count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters baking operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters baking operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetBakingCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return int
     */
    public function operationsGetBakingCount(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetBakingCount'][0]
    ): int
    {
        list($response) = $this->operationsGetBakingCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetBakingCountWithHttpInfo
     *
     * Get baking count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters baking operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters baking operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetBakingCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetBakingCountWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetBakingCount'][0]
    ): array
    {
        $request = $this->operationsGetBakingCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('int', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'int';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetBakingCountAsync
     *
     * Get baking count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters baking operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters baking operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetBakingCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetBakingCountAsync(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetBakingCount'][0]
    ): PromiseInterface
    {
        return $this->operationsGetBakingCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetBakingCountAsyncWithHttpInfo
     *
     * Get baking count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters baking operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters baking operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetBakingCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetBakingCountAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetBakingCount'][0]
    ): PromiseInterface
    {
        $returnType = 'int';
        $request = $this->operationsGetBakingCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetBakingCount'
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters baking operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters baking operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetBakingCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetBakingCountRequest(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetBakingCount'][0]
    ): Request
    {




        $resourcePath = '/v1/operations/baking/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetBallotByHash
     *
     * Get ballot by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetBallotByHash'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\BallotOperation[]
     */
    public function operationsGetBallotByHash(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetBallotByHash'][0]
    ): array
    {
        list($response) = $this->operationsGetBallotByHashWithHttpInfo($hash, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetBallotByHashWithHttpInfo
     *
     * Get ballot by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetBallotByHash'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\BallotOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetBallotByHashWithHttpInfo(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetBallotByHash'][0]
    ): array
    {
        $request = $this->operationsGetBallotByHashRequest($hash, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\BallotOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\BallotOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\BallotOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\BallotOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\BallotOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetBallotByHashAsync
     *
     * Get ballot by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetBallotByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetBallotByHashAsync(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetBallotByHash'][0]
    ): PromiseInterface
    {
        return $this->operationsGetBallotByHashAsyncWithHttpInfo($hash, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetBallotByHashAsyncWithHttpInfo
     *
     * Get ballot by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetBallotByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetBallotByHashAsyncWithHttpInfo(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetBallotByHash'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\BallotOperation[]';
        $request = $this->operationsGetBallotByHashRequest($hash, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetBallotByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetBallotByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetBallotByHashRequest(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetBallotByHash'][0]
    ): Request
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetBallotByHash'
            );
        }



        $resourcePath = '/v1/operations/ballots/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetBallots
     *
     * Get ballots
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $delegate Filters ballots by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters ballots by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters ballots by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $epoch Filters ballots by voting epoch. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $period Filters ballots by voting period. (optional)
     * @param  \Tzkt\Model\OperationsGetBallotsProposalParameter|null $proposal Filters ballots by proposal hash. (optional)
     * @param  \Tzkt\Model\OperationsGetBallotsVoteParameter|null $vote Filters ballots by vote (&#x60;yay&#x60;, &#x60;nay&#x60;, &#x60;pass&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts ballots by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetBallots'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\BallotOperation[]
     */
    public function operationsGetBallots(
        ?\Tzkt\Model\AccountsGetDelegateParameter $delegate = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetIdParameter $epoch = null,
        ?\Tzkt\Model\AccountsGetIdParameter $period = null,
        ?\Tzkt\Model\OperationsGetBallotsProposalParameter $proposal = null,
        ?\Tzkt\Model\OperationsGetBallotsVoteParameter $vote = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetBallots'][0]
    ): array
    {
        list($response) = $this->operationsGetBallotsWithHttpInfo($delegate, $level, $timestamp, $epoch, $period, $proposal, $vote, $select, $sort, $offset, $limit, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetBallotsWithHttpInfo
     *
     * Get ballots
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $delegate Filters ballots by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters ballots by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters ballots by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $epoch Filters ballots by voting epoch. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $period Filters ballots by voting period. (optional)
     * @param  \Tzkt\Model\OperationsGetBallotsProposalParameter|null $proposal Filters ballots by proposal hash. (optional)
     * @param  \Tzkt\Model\OperationsGetBallotsVoteParameter|null $vote Filters ballots by vote (&#x60;yay&#x60;, &#x60;nay&#x60;, &#x60;pass&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts ballots by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetBallots'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\BallotOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetBallotsWithHttpInfo(
        ?\Tzkt\Model\AccountsGetDelegateParameter $delegate = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetIdParameter $epoch = null,
        ?\Tzkt\Model\AccountsGetIdParameter $period = null,
        ?\Tzkt\Model\OperationsGetBallotsProposalParameter $proposal = null,
        ?\Tzkt\Model\OperationsGetBallotsVoteParameter $vote = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetBallots'][0]
    ): array
    {
        $request = $this->operationsGetBallotsRequest($delegate, $level, $timestamp, $epoch, $period, $proposal, $vote, $select, $sort, $offset, $limit, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\BallotOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\BallotOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\BallotOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\BallotOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\BallotOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetBallotsAsync
     *
     * Get ballots
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $delegate Filters ballots by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters ballots by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters ballots by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $epoch Filters ballots by voting epoch. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $period Filters ballots by voting period. (optional)
     * @param  \Tzkt\Model\OperationsGetBallotsProposalParameter|null $proposal Filters ballots by proposal hash. (optional)
     * @param  \Tzkt\Model\OperationsGetBallotsVoteParameter|null $vote Filters ballots by vote (&#x60;yay&#x60;, &#x60;nay&#x60;, &#x60;pass&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts ballots by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetBallots'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetBallotsAsync(
        ?\Tzkt\Model\AccountsGetDelegateParameter $delegate = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetIdParameter $epoch = null,
        ?\Tzkt\Model\AccountsGetIdParameter $period = null,
        ?\Tzkt\Model\OperationsGetBallotsProposalParameter $proposal = null,
        ?\Tzkt\Model\OperationsGetBallotsVoteParameter $vote = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetBallots'][0]
    ): PromiseInterface
    {
        return $this->operationsGetBallotsAsyncWithHttpInfo($delegate, $level, $timestamp, $epoch, $period, $proposal, $vote, $select, $sort, $offset, $limit, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetBallotsAsyncWithHttpInfo
     *
     * Get ballots
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $delegate Filters ballots by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters ballots by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters ballots by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $epoch Filters ballots by voting epoch. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $period Filters ballots by voting period. (optional)
     * @param  \Tzkt\Model\OperationsGetBallotsProposalParameter|null $proposal Filters ballots by proposal hash. (optional)
     * @param  \Tzkt\Model\OperationsGetBallotsVoteParameter|null $vote Filters ballots by vote (&#x60;yay&#x60;, &#x60;nay&#x60;, &#x60;pass&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts ballots by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetBallots'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetBallotsAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetDelegateParameter $delegate = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetIdParameter $epoch = null,
        ?\Tzkt\Model\AccountsGetIdParameter $period = null,
        ?\Tzkt\Model\OperationsGetBallotsProposalParameter $proposal = null,
        ?\Tzkt\Model\OperationsGetBallotsVoteParameter $vote = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetBallots'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\BallotOperation[]';
        $request = $this->operationsGetBallotsRequest($delegate, $level, $timestamp, $epoch, $period, $proposal, $vote, $select, $sort, $offset, $limit, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetBallots'
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $delegate Filters ballots by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters ballots by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters ballots by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $epoch Filters ballots by voting epoch. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $period Filters ballots by voting period. (optional)
     * @param  \Tzkt\Model\OperationsGetBallotsProposalParameter|null $proposal Filters ballots by proposal hash. (optional)
     * @param  \Tzkt\Model\OperationsGetBallotsVoteParameter|null $vote Filters ballots by vote (&#x60;yay&#x60;, &#x60;nay&#x60;, &#x60;pass&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts ballots by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetBallots'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetBallotsRequest(
        ?\Tzkt\Model\AccountsGetDelegateParameter $delegate = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetIdParameter $epoch = null,
        ?\Tzkt\Model\AccountsGetIdParameter $period = null,
        ?\Tzkt\Model\OperationsGetBallotsProposalParameter $proposal = null,
        ?\Tzkt\Model\OperationsGetBallotsVoteParameter $vote = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetBallots'][0]
    ): Request
    {











        if ($limit !== null && $limit > 10000) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetBallots, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetBallots, must be bigger than or equal to 0.');
        }
        


        $resourcePath = '/v1/operations/ballots';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $delegate,
            'delegate', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $epoch,
            'epoch', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $period,
            'period', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $proposal,
            'proposal', // param base name
            '\Tzkt\Model\ProtocolParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vote,
            'vote', // param base name
            '\Tzkt\Model\VoteParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            '\Tzkt\Model\SelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            '\Tzkt\Model\SortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            '\Tzkt\Model\OffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetBallotsCount
     *
     * Get ballots count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters ballot operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters ballot operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetBallotsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return int
     */
    public function operationsGetBallotsCount(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetBallotsCount'][0]
    ): int
    {
        list($response) = $this->operationsGetBallotsCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetBallotsCountWithHttpInfo
     *
     * Get ballots count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters ballot operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters ballot operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetBallotsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetBallotsCountWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetBallotsCount'][0]
    ): array
    {
        $request = $this->operationsGetBallotsCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('int', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'int';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetBallotsCountAsync
     *
     * Get ballots count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters ballot operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters ballot operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetBallotsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetBallotsCountAsync(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetBallotsCount'][0]
    ): PromiseInterface
    {
        return $this->operationsGetBallotsCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetBallotsCountAsyncWithHttpInfo
     *
     * Get ballots count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters ballot operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters ballot operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetBallotsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetBallotsCountAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetBallotsCount'][0]
    ): PromiseInterface
    {
        $returnType = 'int';
        $request = $this->operationsGetBallotsCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetBallotsCount'
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters ballot operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters ballot operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetBallotsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetBallotsCountRequest(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetBallotsCount'][0]
    ): Request
    {




        $resourcePath = '/v1/operations/ballots/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetByHash
     *
     * Get operations by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetByHash'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\Operation[]
     */
    public function operationsGetByHash(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetByHash'][0]
    ): array
    {
        list($response) = $this->operationsGetByHashWithHttpInfo($hash, $micheline, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetByHashWithHttpInfo
     *
     * Get operations by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetByHash'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\Operation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetByHashWithHttpInfo(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetByHash'][0]
    ): array
    {
        $request = $this->operationsGetByHashRequest($hash, $micheline, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\Operation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\Operation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\Operation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\Operation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\Operation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetByHashAsync
     *
     * Get operations by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetByHashAsync(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetByHash'][0]
    ): PromiseInterface
    {
        return $this->operationsGetByHashAsyncWithHttpInfo($hash, $micheline, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetByHashAsyncWithHttpInfo
     *
     * Get operations by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetByHashAsyncWithHttpInfo(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetByHash'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\Operation[]';
        $request = $this->operationsGetByHashRequest($hash, $micheline, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetByHashRequest(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetByHash'][0]
    ): Request
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetByHash'
            );
        }




        $resourcePath = '/v1/operations/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $micheline,
            'micheline', // param base name
            '\Tzkt\Model\MichelineFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetByHashCounter
     *
     * Get operations by hash and counter
     *
     * @param  string $hash Operation hash (required)
     * @param  int $counter Operation counter (required)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetByHashCounter'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\Operation[]
     */
    public function operationsGetByHashCounter(
        string $hash,
        int $counter,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetByHashCounter'][0]
    ): array
    {
        list($response) = $this->operationsGetByHashCounterWithHttpInfo($hash, $counter, $micheline, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetByHashCounterWithHttpInfo
     *
     * Get operations by hash and counter
     *
     * @param  string $hash Operation hash (required)
     * @param  int $counter Operation counter (required)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetByHashCounter'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\Operation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetByHashCounterWithHttpInfo(
        string $hash,
        int $counter,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetByHashCounter'][0]
    ): array
    {
        $request = $this->operationsGetByHashCounterRequest($hash, $counter, $micheline, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\Operation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\Operation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\Operation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\Operation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\Operation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetByHashCounterAsync
     *
     * Get operations by hash and counter
     *
     * @param  string $hash Operation hash (required)
     * @param  int $counter Operation counter (required)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetByHashCounter'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetByHashCounterAsync(
        string $hash,
        int $counter,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetByHashCounter'][0]
    ): PromiseInterface
    {
        return $this->operationsGetByHashCounterAsyncWithHttpInfo($hash, $counter, $micheline, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetByHashCounterAsyncWithHttpInfo
     *
     * Get operations by hash and counter
     *
     * @param  string $hash Operation hash (required)
     * @param  int $counter Operation counter (required)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetByHashCounter'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetByHashCounterAsyncWithHttpInfo(
        string $hash,
        int $counter,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetByHashCounter'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\Operation[]';
        $request = $this->operationsGetByHashCounterRequest($hash, $counter, $micheline, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetByHashCounter'
     *
     * @param  string $hash Operation hash (required)
     * @param  int $counter Operation counter (required)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetByHashCounter'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetByHashCounterRequest(
        string $hash,
        int $counter,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetByHashCounter'][0]
    ): Request
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetByHashCounter'
            );
        }

        // verify the required parameter 'counter' is set
        if ($counter === null || (is_array($counter) && count($counter) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $counter when calling operationsGetByHashCounter'
            );
        }




        $resourcePath = '/v1/operations/{hash}/{counter}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $micheline,
            'micheline', // param base name
            '\Tzkt\Model\MichelineFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }
        // path params
        if ($counter !== null) {
            $resourcePath = str_replace(
                '{' . 'counter' . '}',
                ObjectSerializer::toPathValue($counter),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetByHashCounterNonce
     *
     * Get operations by hash, counter and nonce
     *
     * @param  string $hash Operation hash (required)
     * @param  int $counter Operation counter (required)
     * @param  int $nonce Operation nonce (internal) (required)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetByHashCounterNonce'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\Operation[]
     */
    public function operationsGetByHashCounterNonce(
        string $hash,
        int $counter,
        int $nonce,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetByHashCounterNonce'][0]
    ): array
    {
        list($response) = $this->operationsGetByHashCounterNonceWithHttpInfo($hash, $counter, $nonce, $micheline, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetByHashCounterNonceWithHttpInfo
     *
     * Get operations by hash, counter and nonce
     *
     * @param  string $hash Operation hash (required)
     * @param  int $counter Operation counter (required)
     * @param  int $nonce Operation nonce (internal) (required)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetByHashCounterNonce'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\Operation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetByHashCounterNonceWithHttpInfo(
        string $hash,
        int $counter,
        int $nonce,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetByHashCounterNonce'][0]
    ): array
    {
        $request = $this->operationsGetByHashCounterNonceRequest($hash, $counter, $nonce, $micheline, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\Operation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\Operation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\Operation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\Operation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\Operation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetByHashCounterNonceAsync
     *
     * Get operations by hash, counter and nonce
     *
     * @param  string $hash Operation hash (required)
     * @param  int $counter Operation counter (required)
     * @param  int $nonce Operation nonce (internal) (required)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetByHashCounterNonce'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetByHashCounterNonceAsync(
        string $hash,
        int $counter,
        int $nonce,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetByHashCounterNonce'][0]
    ): PromiseInterface
    {
        return $this->operationsGetByHashCounterNonceAsyncWithHttpInfo($hash, $counter, $nonce, $micheline, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetByHashCounterNonceAsyncWithHttpInfo
     *
     * Get operations by hash, counter and nonce
     *
     * @param  string $hash Operation hash (required)
     * @param  int $counter Operation counter (required)
     * @param  int $nonce Operation nonce (internal) (required)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetByHashCounterNonce'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetByHashCounterNonceAsyncWithHttpInfo(
        string $hash,
        int $counter,
        int $nonce,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetByHashCounterNonce'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\Operation[]';
        $request = $this->operationsGetByHashCounterNonceRequest($hash, $counter, $nonce, $micheline, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetByHashCounterNonce'
     *
     * @param  string $hash Operation hash (required)
     * @param  int $counter Operation counter (required)
     * @param  int $nonce Operation nonce (internal) (required)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetByHashCounterNonce'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetByHashCounterNonceRequest(
        string $hash,
        int $counter,
        int $nonce,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetByHashCounterNonce'][0]
    ): Request
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetByHashCounterNonce'
            );
        }

        // verify the required parameter 'counter' is set
        if ($counter === null || (is_array($counter) && count($counter) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $counter when calling operationsGetByHashCounterNonce'
            );
        }

        // verify the required parameter 'nonce' is set
        if ($nonce === null || (is_array($nonce) && count($nonce) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $nonce when calling operationsGetByHashCounterNonce'
            );
        }




        $resourcePath = '/v1/operations/{hash}/{counter}/{nonce}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $micheline,
            'micheline', // param base name
            '\Tzkt\Model\MichelineFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }
        // path params
        if ($counter !== null) {
            $resourcePath = str_replace(
                '{' . 'counter' . '}',
                ObjectSerializer::toPathValue($counter),
                $resourcePath
            );
        }
        // path params
        if ($nonce !== null) {
            $resourcePath = str_replace(
                '{' . 'nonce' . '}',
                ObjectSerializer::toPathValue($nonce),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetDalAttestationRewardById
     *
     * Get dal attestation reward by id
     *
     * @param  int $id Operation id (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDalAttestationRewardById'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\DalAttestationRewardOperation
     */
    public function operationsGetDalAttestationRewardById(
        int $id,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDalAttestationRewardById'][0]
    ): \Tzkt\Model\DalAttestationRewardOperation
    {
        list($response) = $this->operationsGetDalAttestationRewardByIdWithHttpInfo($id, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetDalAttestationRewardByIdWithHttpInfo
     *
     * Get dal attestation reward by id
     *
     * @param  int $id Operation id (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDalAttestationRewardById'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\DalAttestationRewardOperation, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetDalAttestationRewardByIdWithHttpInfo(
        int $id,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDalAttestationRewardById'][0]
    ): array
    {
        $request = $this->operationsGetDalAttestationRewardByIdRequest($id, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\DalAttestationRewardOperation', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\DalAttestationRewardOperation' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\DalAttestationRewardOperation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\DalAttestationRewardOperation';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\DalAttestationRewardOperation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetDalAttestationRewardByIdAsync
     *
     * Get dal attestation reward by id
     *
     * @param  int $id Operation id (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDalAttestationRewardById'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetDalAttestationRewardByIdAsync(
        int $id,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDalAttestationRewardById'][0]
    ): PromiseInterface
    {
        return $this->operationsGetDalAttestationRewardByIdAsyncWithHttpInfo($id, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetDalAttestationRewardByIdAsyncWithHttpInfo
     *
     * Get dal attestation reward by id
     *
     * @param  int $id Operation id (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDalAttestationRewardById'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetDalAttestationRewardByIdAsyncWithHttpInfo(
        int $id,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDalAttestationRewardById'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\DalAttestationRewardOperation';
        $request = $this->operationsGetDalAttestationRewardByIdRequest($id, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetDalAttestationRewardById'
     *
     * @param  int $id Operation id (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDalAttestationRewardById'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetDalAttestationRewardByIdRequest(
        int $id,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDalAttestationRewardById'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling operationsGetDalAttestationRewardById'
            );
        }



        $resourcePath = '/v1/operations/dal_attestation_reward/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetDalAttestationRewards
     *
     * Get dal attestation rewards
     *
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters operations by internal TzKT id. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $baker Filters by baker. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDalAttestationRewards'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\DalAttestationRewardOperation[]
     */
    public function operationsGetDalAttestationRewards(
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $baker = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDalAttestationRewards'][0]
    ): array
    {
        list($response) = $this->operationsGetDalAttestationRewardsWithHttpInfo($id, $baker, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetDalAttestationRewardsWithHttpInfo
     *
     * Get dal attestation rewards
     *
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters operations by internal TzKT id. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $baker Filters by baker. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDalAttestationRewards'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\DalAttestationRewardOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetDalAttestationRewardsWithHttpInfo(
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $baker = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDalAttestationRewards'][0]
    ): array
    {
        $request = $this->operationsGetDalAttestationRewardsRequest($id, $baker, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\DalAttestationRewardOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\DalAttestationRewardOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\DalAttestationRewardOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\DalAttestationRewardOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\DalAttestationRewardOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetDalAttestationRewardsAsync
     *
     * Get dal attestation rewards
     *
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters operations by internal TzKT id. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $baker Filters by baker. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDalAttestationRewards'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetDalAttestationRewardsAsync(
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $baker = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDalAttestationRewards'][0]
    ): PromiseInterface
    {
        return $this->operationsGetDalAttestationRewardsAsyncWithHttpInfo($id, $baker, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetDalAttestationRewardsAsyncWithHttpInfo
     *
     * Get dal attestation rewards
     *
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters operations by internal TzKT id. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $baker Filters by baker. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDalAttestationRewards'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetDalAttestationRewardsAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $baker = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDalAttestationRewards'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\DalAttestationRewardOperation[]';
        $request = $this->operationsGetDalAttestationRewardsRequest($id, $baker, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetDalAttestationRewards'
     *
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters operations by internal TzKT id. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $baker Filters by baker. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDalAttestationRewards'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetDalAttestationRewardsRequest(
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $baker = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDalAttestationRewards'][0]
    ): Request
    {








        if ($limit !== null && $limit > 10000) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetDalAttestationRewards, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetDalAttestationRewards, must be bigger than or equal to 0.');
        }
        


        $resourcePath = '/v1/operations/dal_attestation_reward';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            '\Tzkt\Model\Int64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $baker,
            'baker', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            '\Tzkt\Model\SelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            '\Tzkt\Model\SortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            '\Tzkt\Model\OffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetDalAttestationRewardsCount
     *
     * Get dal attestation rewards count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDalAttestationRewardsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return int
     */
    public function operationsGetDalAttestationRewardsCount(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetDalAttestationRewardsCount'][0]
    ): int
    {
        list($response) = $this->operationsGetDalAttestationRewardsCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetDalAttestationRewardsCountWithHttpInfo
     *
     * Get dal attestation rewards count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDalAttestationRewardsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetDalAttestationRewardsCountWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetDalAttestationRewardsCount'][0]
    ): array
    {
        $request = $this->operationsGetDalAttestationRewardsCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('int', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'int';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetDalAttestationRewardsCountAsync
     *
     * Get dal attestation rewards count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDalAttestationRewardsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetDalAttestationRewardsCountAsync(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetDalAttestationRewardsCount'][0]
    ): PromiseInterface
    {
        return $this->operationsGetDalAttestationRewardsCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetDalAttestationRewardsCountAsyncWithHttpInfo
     *
     * Get dal attestation rewards count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDalAttestationRewardsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetDalAttestationRewardsCountAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetDalAttestationRewardsCount'][0]
    ): PromiseInterface
    {
        $returnType = 'int';
        $request = $this->operationsGetDalAttestationRewardsCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetDalAttestationRewardsCount'
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDalAttestationRewardsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetDalAttestationRewardsCountRequest(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetDalAttestationRewardsCount'][0]
    ): Request
    {




        $resourcePath = '/v1/operations/dal_attestation_reward/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetDalEntrapmentEvidenceOps
     *
     * Get dal entrapment evidences
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters by any of the specified fields. Example: &#x60;anyof.accuser.offender&#x3D;tz1...&#x60; will return operations where &#x60;accuser&#x60; OR &#x60;offender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $accuser Filters by accuser. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;offender&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $offender Filters by offender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;accuser&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters operations by internal TzKT id. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;trapLevel&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDalEntrapmentEvidenceOps'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\DalEntrapmentEvidenceOperation[]
     */
    public function operationsGetDalEntrapmentEvidenceOps(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $accuser = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $offender = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDalEntrapmentEvidenceOps'][0]
    ): array
    {
        list($response) = $this->operationsGetDalEntrapmentEvidenceOpsWithHttpInfo($anyof, $accuser, $offender, $id, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetDalEntrapmentEvidenceOpsWithHttpInfo
     *
     * Get dal entrapment evidences
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters by any of the specified fields. Example: &#x60;anyof.accuser.offender&#x3D;tz1...&#x60; will return operations where &#x60;accuser&#x60; OR &#x60;offender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $accuser Filters by accuser. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;offender&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $offender Filters by offender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;accuser&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters operations by internal TzKT id. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;trapLevel&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDalEntrapmentEvidenceOps'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\DalEntrapmentEvidenceOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetDalEntrapmentEvidenceOpsWithHttpInfo(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $accuser = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $offender = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDalEntrapmentEvidenceOps'][0]
    ): array
    {
        $request = $this->operationsGetDalEntrapmentEvidenceOpsRequest($anyof, $accuser, $offender, $id, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\DalEntrapmentEvidenceOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\DalEntrapmentEvidenceOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\DalEntrapmentEvidenceOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\DalEntrapmentEvidenceOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\DalEntrapmentEvidenceOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetDalEntrapmentEvidenceOpsAsync
     *
     * Get dal entrapment evidences
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters by any of the specified fields. Example: &#x60;anyof.accuser.offender&#x3D;tz1...&#x60; will return operations where &#x60;accuser&#x60; OR &#x60;offender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $accuser Filters by accuser. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;offender&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $offender Filters by offender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;accuser&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters operations by internal TzKT id. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;trapLevel&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDalEntrapmentEvidenceOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetDalEntrapmentEvidenceOpsAsync(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $accuser = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $offender = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDalEntrapmentEvidenceOps'][0]
    ): PromiseInterface
    {
        return $this->operationsGetDalEntrapmentEvidenceOpsAsyncWithHttpInfo($anyof, $accuser, $offender, $id, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetDalEntrapmentEvidenceOpsAsyncWithHttpInfo
     *
     * Get dal entrapment evidences
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters by any of the specified fields. Example: &#x60;anyof.accuser.offender&#x3D;tz1...&#x60; will return operations where &#x60;accuser&#x60; OR &#x60;offender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $accuser Filters by accuser. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;offender&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $offender Filters by offender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;accuser&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters operations by internal TzKT id. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;trapLevel&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDalEntrapmentEvidenceOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetDalEntrapmentEvidenceOpsAsyncWithHttpInfo(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $accuser = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $offender = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDalEntrapmentEvidenceOps'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\DalEntrapmentEvidenceOperation[]';
        $request = $this->operationsGetDalEntrapmentEvidenceOpsRequest($anyof, $accuser, $offender, $id, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetDalEntrapmentEvidenceOps'
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters by any of the specified fields. Example: &#x60;anyof.accuser.offender&#x3D;tz1...&#x60; will return operations where &#x60;accuser&#x60; OR &#x60;offender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $accuser Filters by accuser. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;offender&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $offender Filters by offender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;accuser&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters operations by internal TzKT id. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;trapLevel&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDalEntrapmentEvidenceOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetDalEntrapmentEvidenceOpsRequest(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $accuser = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $offender = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDalEntrapmentEvidenceOps'][0]
    ): Request
    {










        if ($limit !== null && $limit > 10000) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetDalEntrapmentEvidenceOps, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetDalEntrapmentEvidenceOps, must be bigger than or equal to 0.');
        }
        


        $resourcePath = '/v1/operations/dal_entrapment_evidence';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $anyof,
            'anyof', // param base name
            '\Tzkt\Model\AnyOfParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $accuser,
            'accuser', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offender,
            'offender', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            '\Tzkt\Model\Int64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            '\Tzkt\Model\SelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            '\Tzkt\Model\SortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            '\Tzkt\Model\OffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetDalEntrapmentEvidenceOpsByHash
     *
     * Get dal entrapment evidence by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDalEntrapmentEvidenceOpsByHash'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\DalEntrapmentEvidenceOperation[]
     */
    public function operationsGetDalEntrapmentEvidenceOpsByHash(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDalEntrapmentEvidenceOpsByHash'][0]
    ): array
    {
        list($response) = $this->operationsGetDalEntrapmentEvidenceOpsByHashWithHttpInfo($hash, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetDalEntrapmentEvidenceOpsByHashWithHttpInfo
     *
     * Get dal entrapment evidence by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDalEntrapmentEvidenceOpsByHash'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\DalEntrapmentEvidenceOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetDalEntrapmentEvidenceOpsByHashWithHttpInfo(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDalEntrapmentEvidenceOpsByHash'][0]
    ): array
    {
        $request = $this->operationsGetDalEntrapmentEvidenceOpsByHashRequest($hash, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\DalEntrapmentEvidenceOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\DalEntrapmentEvidenceOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\DalEntrapmentEvidenceOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\DalEntrapmentEvidenceOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\DalEntrapmentEvidenceOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetDalEntrapmentEvidenceOpsByHashAsync
     *
     * Get dal entrapment evidence by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDalEntrapmentEvidenceOpsByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetDalEntrapmentEvidenceOpsByHashAsync(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDalEntrapmentEvidenceOpsByHash'][0]
    ): PromiseInterface
    {
        return $this->operationsGetDalEntrapmentEvidenceOpsByHashAsyncWithHttpInfo($hash, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetDalEntrapmentEvidenceOpsByHashAsyncWithHttpInfo
     *
     * Get dal entrapment evidence by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDalEntrapmentEvidenceOpsByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetDalEntrapmentEvidenceOpsByHashAsyncWithHttpInfo(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDalEntrapmentEvidenceOpsByHash'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\DalEntrapmentEvidenceOperation[]';
        $request = $this->operationsGetDalEntrapmentEvidenceOpsByHashRequest($hash, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetDalEntrapmentEvidenceOpsByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDalEntrapmentEvidenceOpsByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetDalEntrapmentEvidenceOpsByHashRequest(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDalEntrapmentEvidenceOpsByHash'][0]
    ): Request
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetDalEntrapmentEvidenceOpsByHash'
            );
        }



        $resourcePath = '/v1/operations/dal_entrapment_evidence/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetDalEntrapmentEvidenceOpsCount
     *
     * Get dal entrapment evidences count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDalEntrapmentEvidenceOpsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return int
     */
    public function operationsGetDalEntrapmentEvidenceOpsCount(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetDalEntrapmentEvidenceOpsCount'][0]
    ): int
    {
        list($response) = $this->operationsGetDalEntrapmentEvidenceOpsCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetDalEntrapmentEvidenceOpsCountWithHttpInfo
     *
     * Get dal entrapment evidences count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDalEntrapmentEvidenceOpsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetDalEntrapmentEvidenceOpsCountWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetDalEntrapmentEvidenceOpsCount'][0]
    ): array
    {
        $request = $this->operationsGetDalEntrapmentEvidenceOpsCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('int', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'int';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetDalEntrapmentEvidenceOpsCountAsync
     *
     * Get dal entrapment evidences count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDalEntrapmentEvidenceOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetDalEntrapmentEvidenceOpsCountAsync(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetDalEntrapmentEvidenceOpsCount'][0]
    ): PromiseInterface
    {
        return $this->operationsGetDalEntrapmentEvidenceOpsCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetDalEntrapmentEvidenceOpsCountAsyncWithHttpInfo
     *
     * Get dal entrapment evidences count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDalEntrapmentEvidenceOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetDalEntrapmentEvidenceOpsCountAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetDalEntrapmentEvidenceOpsCount'][0]
    ): PromiseInterface
    {
        $returnType = 'int';
        $request = $this->operationsGetDalEntrapmentEvidenceOpsCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetDalEntrapmentEvidenceOpsCount'
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDalEntrapmentEvidenceOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetDalEntrapmentEvidenceOpsCountRequest(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetDalEntrapmentEvidenceOpsCount'][0]
    ): Request
    {




        $resourcePath = '/v1/operations/dal_entrapment_evidence/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetDalPublishCommitmentOps
     *
     * Get dal_publish_commitment ops
     *
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int|null $limit Maximum number of items to return. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysSelectParameter|null $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDalPublishCommitmentOps'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\DalPublishCommitmentOperation[]
     */
    public function operationsGetDalPublishCommitmentOps(
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDalPublishCommitmentOps'][0]
    ): array
    {
        list($response) = $this->operationsGetDalPublishCommitmentOpsWithHttpInfo($id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetDalPublishCommitmentOpsWithHttpInfo
     *
     * Get dal_publish_commitment ops
     *
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int|null $limit Maximum number of items to return. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysSelectParameter|null $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDalPublishCommitmentOps'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\DalPublishCommitmentOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetDalPublishCommitmentOpsWithHttpInfo(
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDalPublishCommitmentOps'][0]
    ): array
    {
        $request = $this->operationsGetDalPublishCommitmentOpsRequest($id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\DalPublishCommitmentOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\DalPublishCommitmentOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\DalPublishCommitmentOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\DalPublishCommitmentOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\DalPublishCommitmentOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetDalPublishCommitmentOpsAsync
     *
     * Get dal_publish_commitment ops
     *
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int|null $limit Maximum number of items to return. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysSelectParameter|null $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDalPublishCommitmentOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetDalPublishCommitmentOpsAsync(
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDalPublishCommitmentOps'][0]
    ): PromiseInterface
    {
        return $this->operationsGetDalPublishCommitmentOpsAsyncWithHttpInfo($id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetDalPublishCommitmentOpsAsyncWithHttpInfo
     *
     * Get dal_publish_commitment ops
     *
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int|null $limit Maximum number of items to return. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysSelectParameter|null $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDalPublishCommitmentOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetDalPublishCommitmentOpsAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDalPublishCommitmentOps'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\DalPublishCommitmentOperation[]';
        $request = $this->operationsGetDalPublishCommitmentOpsRequest($id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetDalPublishCommitmentOps'
     *
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int|null $limit Maximum number of items to return. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysSelectParameter|null $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDalPublishCommitmentOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetDalPublishCommitmentOpsRequest(
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDalPublishCommitmentOps'][0]
    ): Request
    {










        if ($limit !== null && $limit > 10000) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetDalPublishCommitmentOps, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetDalPublishCommitmentOps, must be bigger than or equal to 0.');
        }
        



        $resourcePath = '/v1/operations/dal_publish_commitment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            '\Tzkt\Model\Int64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hash,
            'hash', // param base name
            '\Tzkt\Model\OpHashParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $counter,
            'counter', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\TimestampParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            '\Tzkt\Model\OperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            '\Tzkt\Model\SortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            '\Tzkt\Model\OffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            '\Tzkt\Model\SelectionParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetDalPublishCommitmentOpsCount
     *
     * Get dal_publish_commitment ops count
     *
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDalPublishCommitmentOpsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return int
     */
    public function operationsGetDalPublishCommitmentOpsCount(
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        string $contentType = self::contentTypes['operationsGetDalPublishCommitmentOpsCount'][0]
    ): int
    {
        list($response) = $this->operationsGetDalPublishCommitmentOpsCountWithHttpInfo($id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetDalPublishCommitmentOpsCountWithHttpInfo
     *
     * Get dal_publish_commitment ops count
     *
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDalPublishCommitmentOpsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetDalPublishCommitmentOpsCountWithHttpInfo(
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        string $contentType = self::contentTypes['operationsGetDalPublishCommitmentOpsCount'][0]
    ): array
    {
        $request = $this->operationsGetDalPublishCommitmentOpsCountRequest($id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('int', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'int';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetDalPublishCommitmentOpsCountAsync
     *
     * Get dal_publish_commitment ops count
     *
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDalPublishCommitmentOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetDalPublishCommitmentOpsCountAsync(
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        string $contentType = self::contentTypes['operationsGetDalPublishCommitmentOpsCount'][0]
    ): PromiseInterface
    {
        return $this->operationsGetDalPublishCommitmentOpsCountAsyncWithHttpInfo($id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetDalPublishCommitmentOpsCountAsyncWithHttpInfo
     *
     * Get dal_publish_commitment ops count
     *
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDalPublishCommitmentOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetDalPublishCommitmentOpsCountAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        string $contentType = self::contentTypes['operationsGetDalPublishCommitmentOpsCount'][0]
    ): PromiseInterface
    {
        $returnType = 'int';
        $request = $this->operationsGetDalPublishCommitmentOpsCountRequest($id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetDalPublishCommitmentOpsCount'
     *
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDalPublishCommitmentOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetDalPublishCommitmentOpsCountRequest(
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        string $contentType = self::contentTypes['operationsGetDalPublishCommitmentOpsCount'][0]
    ): Request
    {









        $resourcePath = '/v1/operations/dal_publish_commitment/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            '\Tzkt\Model\Int64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hash,
            'hash', // param base name
            '\Tzkt\Model\OpHashParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $counter,
            'counter', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\TimestampParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            '\Tzkt\Model\OperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetDelegationByHash
     *
     * Get delegation by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDelegationByHash'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\DelegationOperation[]
     */
    public function operationsGetDelegationByHash(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDelegationByHash'][0]
    ): array
    {
        list($response) = $this->operationsGetDelegationByHashWithHttpInfo($hash, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetDelegationByHashWithHttpInfo
     *
     * Get delegation by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDelegationByHash'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\DelegationOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetDelegationByHashWithHttpInfo(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDelegationByHash'][0]
    ): array
    {
        $request = $this->operationsGetDelegationByHashRequest($hash, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\DelegationOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\DelegationOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\DelegationOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\DelegationOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\DelegationOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetDelegationByHashAsync
     *
     * Get delegation by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDelegationByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetDelegationByHashAsync(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDelegationByHash'][0]
    ): PromiseInterface
    {
        return $this->operationsGetDelegationByHashAsyncWithHttpInfo($hash, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetDelegationByHashAsyncWithHttpInfo
     *
     * Get delegation by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDelegationByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetDelegationByHashAsyncWithHttpInfo(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDelegationByHash'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\DelegationOperation[]';
        $request = $this->operationsGetDelegationByHashRequest($hash, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetDelegationByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDelegationByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetDelegationByHashRequest(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDelegationByHash'][0]
    ): Request
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetDelegationByHash'
            );
        }



        $resourcePath = '/v1/operations/delegations/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetDelegationStatus
     *
     * Get delegation status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDelegationStatus'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return bool
     */
    public function operationsGetDelegationStatus(
        string $hash,
        string $contentType = self::contentTypes['operationsGetDelegationStatus'][0]
    ): bool
    {
        list($response) = $this->operationsGetDelegationStatusWithHttpInfo($hash, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetDelegationStatusWithHttpInfo
     *
     * Get delegation status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDelegationStatus'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of bool, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetDelegationStatusWithHttpInfo(
        string $hash,
        string $contentType = self::contentTypes['operationsGetDelegationStatus'][0]
    ): array
    {
        $request = $this->operationsGetDelegationStatusRequest($hash, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('bool', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('bool' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'bool', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'bool';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'bool',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetDelegationStatusAsync
     *
     * Get delegation status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDelegationStatus'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetDelegationStatusAsync(
        string $hash,
        string $contentType = self::contentTypes['operationsGetDelegationStatus'][0]
    ): PromiseInterface
    {
        return $this->operationsGetDelegationStatusAsyncWithHttpInfo($hash, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetDelegationStatusAsyncWithHttpInfo
     *
     * Get delegation status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDelegationStatus'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetDelegationStatusAsyncWithHttpInfo(
        string $hash,
        string $contentType = self::contentTypes['operationsGetDelegationStatus'][0]
    ): PromiseInterface
    {
        $returnType = 'bool';
        $request = $this->operationsGetDelegationStatusRequest($hash, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetDelegationStatus'
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDelegationStatus'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetDelegationStatusRequest(
        string $hash,
        string $contentType = self::contentTypes['operationsGetDelegationStatus'][0]
    ): Request
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetDelegationStatus'
            );
        }


        $resourcePath = '/v1/operations/delegations/{hash}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetDelegations
     *
     * Get delegations
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters delegations by any of the specified fields. Example: &#x60;anyof.prevDelegate.newDelegate&#x3D;tz1...&#x60; will return operations where &#x60;prevDelegate&#x60; OR &#x60;newDelegate&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all delegations associated with a specified account. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $initiator Filters delegations by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;prevDelegate&#x60;, &#x60;newDelegate&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters delegations by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;prevDelegate&#x60;, &#x60;newDelegate&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $prev_delegate Filters delegations by prev delegate. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;newDelegate&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $new_delegate Filters delegations by new delegate. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;prevDelegate&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters operations by internal TzKT id. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters delegations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters delegations by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $sender_code_hash Filters by &#x60;senderCodeHash&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters delegations by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts delegations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDelegations'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\DelegationOperation[]
     */
    public function operationsGetDelegations(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $initiator = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $prev_delegate = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $new_delegate = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetIdParameter $sender_code_hash = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDelegations'][0]
    ): array
    {
        list($response) = $this->operationsGetDelegationsWithHttpInfo($anyof, $initiator, $sender, $prev_delegate, $new_delegate, $id, $level, $timestamp, $sender_code_hash, $status, $select, $sort, $offset, $limit, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetDelegationsWithHttpInfo
     *
     * Get delegations
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters delegations by any of the specified fields. Example: &#x60;anyof.prevDelegate.newDelegate&#x3D;tz1...&#x60; will return operations where &#x60;prevDelegate&#x60; OR &#x60;newDelegate&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all delegations associated with a specified account. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $initiator Filters delegations by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;prevDelegate&#x60;, &#x60;newDelegate&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters delegations by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;prevDelegate&#x60;, &#x60;newDelegate&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $prev_delegate Filters delegations by prev delegate. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;newDelegate&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $new_delegate Filters delegations by new delegate. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;prevDelegate&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters operations by internal TzKT id. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters delegations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters delegations by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $sender_code_hash Filters by &#x60;senderCodeHash&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters delegations by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts delegations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDelegations'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\DelegationOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetDelegationsWithHttpInfo(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $initiator = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $prev_delegate = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $new_delegate = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetIdParameter $sender_code_hash = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDelegations'][0]
    ): array
    {
        $request = $this->operationsGetDelegationsRequest($anyof, $initiator, $sender, $prev_delegate, $new_delegate, $id, $level, $timestamp, $sender_code_hash, $status, $select, $sort, $offset, $limit, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\DelegationOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\DelegationOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\DelegationOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\DelegationOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\DelegationOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetDelegationsAsync
     *
     * Get delegations
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters delegations by any of the specified fields. Example: &#x60;anyof.prevDelegate.newDelegate&#x3D;tz1...&#x60; will return operations where &#x60;prevDelegate&#x60; OR &#x60;newDelegate&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all delegations associated with a specified account. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $initiator Filters delegations by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;prevDelegate&#x60;, &#x60;newDelegate&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters delegations by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;prevDelegate&#x60;, &#x60;newDelegate&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $prev_delegate Filters delegations by prev delegate. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;newDelegate&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $new_delegate Filters delegations by new delegate. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;prevDelegate&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters operations by internal TzKT id. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters delegations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters delegations by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $sender_code_hash Filters by &#x60;senderCodeHash&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters delegations by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts delegations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDelegations'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetDelegationsAsync(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $initiator = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $prev_delegate = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $new_delegate = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetIdParameter $sender_code_hash = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDelegations'][0]
    ): PromiseInterface
    {
        return $this->operationsGetDelegationsAsyncWithHttpInfo($anyof, $initiator, $sender, $prev_delegate, $new_delegate, $id, $level, $timestamp, $sender_code_hash, $status, $select, $sort, $offset, $limit, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetDelegationsAsyncWithHttpInfo
     *
     * Get delegations
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters delegations by any of the specified fields. Example: &#x60;anyof.prevDelegate.newDelegate&#x3D;tz1...&#x60; will return operations where &#x60;prevDelegate&#x60; OR &#x60;newDelegate&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all delegations associated with a specified account. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $initiator Filters delegations by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;prevDelegate&#x60;, &#x60;newDelegate&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters delegations by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;prevDelegate&#x60;, &#x60;newDelegate&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $prev_delegate Filters delegations by prev delegate. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;newDelegate&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $new_delegate Filters delegations by new delegate. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;prevDelegate&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters operations by internal TzKT id. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters delegations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters delegations by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $sender_code_hash Filters by &#x60;senderCodeHash&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters delegations by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts delegations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDelegations'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetDelegationsAsyncWithHttpInfo(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $initiator = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $prev_delegate = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $new_delegate = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetIdParameter $sender_code_hash = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDelegations'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\DelegationOperation[]';
        $request = $this->operationsGetDelegationsRequest($anyof, $initiator, $sender, $prev_delegate, $new_delegate, $id, $level, $timestamp, $sender_code_hash, $status, $select, $sort, $offset, $limit, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetDelegations'
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters delegations by any of the specified fields. Example: &#x60;anyof.prevDelegate.newDelegate&#x3D;tz1...&#x60; will return operations where &#x60;prevDelegate&#x60; OR &#x60;newDelegate&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all delegations associated with a specified account. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $initiator Filters delegations by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;prevDelegate&#x60;, &#x60;newDelegate&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters delegations by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;prevDelegate&#x60;, &#x60;newDelegate&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $prev_delegate Filters delegations by prev delegate. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;newDelegate&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $new_delegate Filters delegations by new delegate. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;prevDelegate&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters operations by internal TzKT id. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters delegations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters delegations by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $sender_code_hash Filters by &#x60;senderCodeHash&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters delegations by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts delegations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDelegations'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetDelegationsRequest(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $initiator = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $prev_delegate = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $new_delegate = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetIdParameter $sender_code_hash = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDelegations'][0]
    ): Request
    {














        if ($limit !== null && $limit > 10000) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetDelegations, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetDelegations, must be bigger than or equal to 0.');
        }
        


        $resourcePath = '/v1/operations/delegations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $anyof,
            'anyof', // param base name
            '\Tzkt\Model\AnyOfParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $initiator,
            'initiator', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $prev_delegate,
            'prevDelegate', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $new_delegate,
            'newDelegate', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            '\Tzkt\Model\Int64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender_code_hash,
            'senderCodeHash', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            '\Tzkt\Model\OperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            '\Tzkt\Model\SelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            '\Tzkt\Model\SortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            '\Tzkt\Model\OffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetDelegationsCount
     *
     * Get delegations count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters delegations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters delegations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDelegationsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return int
     */
    public function operationsGetDelegationsCount(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetDelegationsCount'][0]
    ): int
    {
        list($response) = $this->operationsGetDelegationsCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetDelegationsCountWithHttpInfo
     *
     * Get delegations count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters delegations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters delegations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDelegationsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetDelegationsCountWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetDelegationsCount'][0]
    ): array
    {
        $request = $this->operationsGetDelegationsCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('int', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'int';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetDelegationsCountAsync
     *
     * Get delegations count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters delegations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters delegations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDelegationsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetDelegationsCountAsync(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetDelegationsCount'][0]
    ): PromiseInterface
    {
        return $this->operationsGetDelegationsCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetDelegationsCountAsyncWithHttpInfo
     *
     * Get delegations count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters delegations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters delegations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDelegationsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetDelegationsCountAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetDelegationsCount'][0]
    ): PromiseInterface
    {
        $returnType = 'int';
        $request = $this->operationsGetDelegationsCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetDelegationsCount'
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters delegations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters delegations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDelegationsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetDelegationsCountRequest(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetDelegationsCount'][0]
    ): Request
    {




        $resourcePath = '/v1/operations/delegations/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetDoubleBaking
     *
     * Get double baking
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters double baking operations by any of the specified fields. Example: &#x60;anyof.accuser.offender&#x3D;tz1...&#x60; will return operations where &#x60;accuser&#x60; OR &#x60;offender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $accuser Filters double baking operations by accuser. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;offender&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $offender Filters double baking operations by offender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;accuser&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters operations by internal TzKT id. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters double baking operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters double baking operations by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts double baking operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;accusedLevel&#x60;, &#x60;accuserRewards&#x60;, &#x60;offenderLostDeposits&#x60;, &#x60;offenderLostRewards&#x60;, &#x60;offenderLostFees&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoubleBaking'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\DoubleBakingOperation[]
     */
    public function operationsGetDoubleBaking(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $accuser = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $offender = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDoubleBaking'][0]
    ): array
    {
        list($response) = $this->operationsGetDoubleBakingWithHttpInfo($anyof, $accuser, $offender, $id, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetDoubleBakingWithHttpInfo
     *
     * Get double baking
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters double baking operations by any of the specified fields. Example: &#x60;anyof.accuser.offender&#x3D;tz1...&#x60; will return operations where &#x60;accuser&#x60; OR &#x60;offender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $accuser Filters double baking operations by accuser. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;offender&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $offender Filters double baking operations by offender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;accuser&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters operations by internal TzKT id. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters double baking operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters double baking operations by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts double baking operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;accusedLevel&#x60;, &#x60;accuserRewards&#x60;, &#x60;offenderLostDeposits&#x60;, &#x60;offenderLostRewards&#x60;, &#x60;offenderLostFees&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoubleBaking'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\DoubleBakingOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetDoubleBakingWithHttpInfo(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $accuser = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $offender = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDoubleBaking'][0]
    ): array
    {
        $request = $this->operationsGetDoubleBakingRequest($anyof, $accuser, $offender, $id, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\DoubleBakingOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\DoubleBakingOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\DoubleBakingOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\DoubleBakingOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\DoubleBakingOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetDoubleBakingAsync
     *
     * Get double baking
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters double baking operations by any of the specified fields. Example: &#x60;anyof.accuser.offender&#x3D;tz1...&#x60; will return operations where &#x60;accuser&#x60; OR &#x60;offender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $accuser Filters double baking operations by accuser. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;offender&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $offender Filters double baking operations by offender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;accuser&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters operations by internal TzKT id. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters double baking operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters double baking operations by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts double baking operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;accusedLevel&#x60;, &#x60;accuserRewards&#x60;, &#x60;offenderLostDeposits&#x60;, &#x60;offenderLostRewards&#x60;, &#x60;offenderLostFees&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoubleBaking'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetDoubleBakingAsync(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $accuser = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $offender = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDoubleBaking'][0]
    ): PromiseInterface
    {
        return $this->operationsGetDoubleBakingAsyncWithHttpInfo($anyof, $accuser, $offender, $id, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetDoubleBakingAsyncWithHttpInfo
     *
     * Get double baking
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters double baking operations by any of the specified fields. Example: &#x60;anyof.accuser.offender&#x3D;tz1...&#x60; will return operations where &#x60;accuser&#x60; OR &#x60;offender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $accuser Filters double baking operations by accuser. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;offender&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $offender Filters double baking operations by offender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;accuser&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters operations by internal TzKT id. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters double baking operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters double baking operations by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts double baking operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;accusedLevel&#x60;, &#x60;accuserRewards&#x60;, &#x60;offenderLostDeposits&#x60;, &#x60;offenderLostRewards&#x60;, &#x60;offenderLostFees&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoubleBaking'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetDoubleBakingAsyncWithHttpInfo(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $accuser = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $offender = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDoubleBaking'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\DoubleBakingOperation[]';
        $request = $this->operationsGetDoubleBakingRequest($anyof, $accuser, $offender, $id, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetDoubleBaking'
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters double baking operations by any of the specified fields. Example: &#x60;anyof.accuser.offender&#x3D;tz1...&#x60; will return operations where &#x60;accuser&#x60; OR &#x60;offender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $accuser Filters double baking operations by accuser. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;offender&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $offender Filters double baking operations by offender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;accuser&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters operations by internal TzKT id. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters double baking operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters double baking operations by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts double baking operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;accusedLevel&#x60;, &#x60;accuserRewards&#x60;, &#x60;offenderLostDeposits&#x60;, &#x60;offenderLostRewards&#x60;, &#x60;offenderLostFees&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoubleBaking'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetDoubleBakingRequest(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $accuser = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $offender = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDoubleBaking'][0]
    ): Request
    {










        if ($limit !== null && $limit > 10000) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetDoubleBaking, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetDoubleBaking, must be bigger than or equal to 0.');
        }
        


        $resourcePath = '/v1/operations/double_baking';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $anyof,
            'anyof', // param base name
            '\Tzkt\Model\AnyOfParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $accuser,
            'accuser', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offender,
            'offender', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            '\Tzkt\Model\Int64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            '\Tzkt\Model\SelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            '\Tzkt\Model\SortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            '\Tzkt\Model\OffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetDoubleBakingByHash
     *
     * Get double baking by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoubleBakingByHash'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\DoubleBakingOperation[]
     */
    public function operationsGetDoubleBakingByHash(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDoubleBakingByHash'][0]
    ): array
    {
        list($response) = $this->operationsGetDoubleBakingByHashWithHttpInfo($hash, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetDoubleBakingByHashWithHttpInfo
     *
     * Get double baking by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoubleBakingByHash'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\DoubleBakingOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetDoubleBakingByHashWithHttpInfo(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDoubleBakingByHash'][0]
    ): array
    {
        $request = $this->operationsGetDoubleBakingByHashRequest($hash, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\DoubleBakingOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\DoubleBakingOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\DoubleBakingOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\DoubleBakingOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\DoubleBakingOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetDoubleBakingByHashAsync
     *
     * Get double baking by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoubleBakingByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetDoubleBakingByHashAsync(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDoubleBakingByHash'][0]
    ): PromiseInterface
    {
        return $this->operationsGetDoubleBakingByHashAsyncWithHttpInfo($hash, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetDoubleBakingByHashAsyncWithHttpInfo
     *
     * Get double baking by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoubleBakingByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetDoubleBakingByHashAsyncWithHttpInfo(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDoubleBakingByHash'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\DoubleBakingOperation[]';
        $request = $this->operationsGetDoubleBakingByHashRequest($hash, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetDoubleBakingByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoubleBakingByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetDoubleBakingByHashRequest(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDoubleBakingByHash'][0]
    ): Request
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetDoubleBakingByHash'
            );
        }



        $resourcePath = '/v1/operations/double_baking/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetDoubleBakingCount
     *
     * Get double baking count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters double baking operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters double baking operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoubleBakingCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return int
     */
    public function operationsGetDoubleBakingCount(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetDoubleBakingCount'][0]
    ): int
    {
        list($response) = $this->operationsGetDoubleBakingCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetDoubleBakingCountWithHttpInfo
     *
     * Get double baking count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters double baking operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters double baking operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoubleBakingCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetDoubleBakingCountWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetDoubleBakingCount'][0]
    ): array
    {
        $request = $this->operationsGetDoubleBakingCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('int', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'int';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetDoubleBakingCountAsync
     *
     * Get double baking count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters double baking operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters double baking operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoubleBakingCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetDoubleBakingCountAsync(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetDoubleBakingCount'][0]
    ): PromiseInterface
    {
        return $this->operationsGetDoubleBakingCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetDoubleBakingCountAsyncWithHttpInfo
     *
     * Get double baking count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters double baking operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters double baking operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoubleBakingCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetDoubleBakingCountAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetDoubleBakingCount'][0]
    ): PromiseInterface
    {
        $returnType = 'int';
        $request = $this->operationsGetDoubleBakingCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetDoubleBakingCount'
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters double baking operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters double baking operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoubleBakingCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetDoubleBakingCountRequest(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetDoubleBakingCount'][0]
    ): Request
    {




        $resourcePath = '/v1/operations/double_baking/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetDoubleEndorsing
     *
     * Get double endorsing
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters double endorsing operations by any of the specified fields. Example: &#x60;anyof.accuser.offender&#x3D;tz1...&#x60; will return operations where &#x60;accuser&#x60; OR &#x60;offender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $accuser Filters double endorsing operations by accuser. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;offender&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $offender Filters double endorsing operations by offender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;accuser&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters operations by internal TzKT id. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters double endorsing operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters double endorsing operations by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts double endorsing operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;accusedLevel&#x60;, &#x60;accuserRewards&#x60;, &#x60;offenderLostDeposits&#x60;, &#x60;offenderLostRewards&#x60;, &#x60;offenderLostFees&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoubleEndorsing'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\DoubleEndorsingOperation[]
     */
    public function operationsGetDoubleEndorsing(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $accuser = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $offender = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDoubleEndorsing'][0]
    ): array
    {
        list($response) = $this->operationsGetDoubleEndorsingWithHttpInfo($anyof, $accuser, $offender, $id, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetDoubleEndorsingWithHttpInfo
     *
     * Get double endorsing
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters double endorsing operations by any of the specified fields. Example: &#x60;anyof.accuser.offender&#x3D;tz1...&#x60; will return operations where &#x60;accuser&#x60; OR &#x60;offender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $accuser Filters double endorsing operations by accuser. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;offender&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $offender Filters double endorsing operations by offender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;accuser&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters operations by internal TzKT id. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters double endorsing operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters double endorsing operations by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts double endorsing operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;accusedLevel&#x60;, &#x60;accuserRewards&#x60;, &#x60;offenderLostDeposits&#x60;, &#x60;offenderLostRewards&#x60;, &#x60;offenderLostFees&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoubleEndorsing'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\DoubleEndorsingOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetDoubleEndorsingWithHttpInfo(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $accuser = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $offender = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDoubleEndorsing'][0]
    ): array
    {
        $request = $this->operationsGetDoubleEndorsingRequest($anyof, $accuser, $offender, $id, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\DoubleEndorsingOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\DoubleEndorsingOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\DoubleEndorsingOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\DoubleEndorsingOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\DoubleEndorsingOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetDoubleEndorsingAsync
     *
     * Get double endorsing
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters double endorsing operations by any of the specified fields. Example: &#x60;anyof.accuser.offender&#x3D;tz1...&#x60; will return operations where &#x60;accuser&#x60; OR &#x60;offender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $accuser Filters double endorsing operations by accuser. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;offender&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $offender Filters double endorsing operations by offender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;accuser&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters operations by internal TzKT id. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters double endorsing operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters double endorsing operations by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts double endorsing operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;accusedLevel&#x60;, &#x60;accuserRewards&#x60;, &#x60;offenderLostDeposits&#x60;, &#x60;offenderLostRewards&#x60;, &#x60;offenderLostFees&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoubleEndorsing'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetDoubleEndorsingAsync(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $accuser = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $offender = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDoubleEndorsing'][0]
    ): PromiseInterface
    {
        return $this->operationsGetDoubleEndorsingAsyncWithHttpInfo($anyof, $accuser, $offender, $id, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetDoubleEndorsingAsyncWithHttpInfo
     *
     * Get double endorsing
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters double endorsing operations by any of the specified fields. Example: &#x60;anyof.accuser.offender&#x3D;tz1...&#x60; will return operations where &#x60;accuser&#x60; OR &#x60;offender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $accuser Filters double endorsing operations by accuser. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;offender&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $offender Filters double endorsing operations by offender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;accuser&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters operations by internal TzKT id. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters double endorsing operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters double endorsing operations by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts double endorsing operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;accusedLevel&#x60;, &#x60;accuserRewards&#x60;, &#x60;offenderLostDeposits&#x60;, &#x60;offenderLostRewards&#x60;, &#x60;offenderLostFees&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoubleEndorsing'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetDoubleEndorsingAsyncWithHttpInfo(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $accuser = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $offender = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDoubleEndorsing'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\DoubleEndorsingOperation[]';
        $request = $this->operationsGetDoubleEndorsingRequest($anyof, $accuser, $offender, $id, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetDoubleEndorsing'
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters double endorsing operations by any of the specified fields. Example: &#x60;anyof.accuser.offender&#x3D;tz1...&#x60; will return operations where &#x60;accuser&#x60; OR &#x60;offender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $accuser Filters double endorsing operations by accuser. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;offender&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $offender Filters double endorsing operations by offender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;accuser&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters operations by internal TzKT id. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters double endorsing operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters double endorsing operations by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts double endorsing operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;accusedLevel&#x60;, &#x60;accuserRewards&#x60;, &#x60;offenderLostDeposits&#x60;, &#x60;offenderLostRewards&#x60;, &#x60;offenderLostFees&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoubleEndorsing'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetDoubleEndorsingRequest(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $accuser = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $offender = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDoubleEndorsing'][0]
    ): Request
    {










        if ($limit !== null && $limit > 10000) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetDoubleEndorsing, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetDoubleEndorsing, must be bigger than or equal to 0.');
        }
        


        $resourcePath = '/v1/operations/double_endorsing';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $anyof,
            'anyof', // param base name
            '\Tzkt\Model\AnyOfParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $accuser,
            'accuser', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offender,
            'offender', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            '\Tzkt\Model\Int64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            '\Tzkt\Model\SelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            '\Tzkt\Model\SortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            '\Tzkt\Model\OffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetDoubleEndorsingByHash
     *
     * Get double endorsing by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoubleEndorsingByHash'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\DoubleEndorsingOperation[]
     */
    public function operationsGetDoubleEndorsingByHash(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDoubleEndorsingByHash'][0]
    ): array
    {
        list($response) = $this->operationsGetDoubleEndorsingByHashWithHttpInfo($hash, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetDoubleEndorsingByHashWithHttpInfo
     *
     * Get double endorsing by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoubleEndorsingByHash'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\DoubleEndorsingOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetDoubleEndorsingByHashWithHttpInfo(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDoubleEndorsingByHash'][0]
    ): array
    {
        $request = $this->operationsGetDoubleEndorsingByHashRequest($hash, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\DoubleEndorsingOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\DoubleEndorsingOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\DoubleEndorsingOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\DoubleEndorsingOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\DoubleEndorsingOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetDoubleEndorsingByHashAsync
     *
     * Get double endorsing by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoubleEndorsingByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetDoubleEndorsingByHashAsync(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDoubleEndorsingByHash'][0]
    ): PromiseInterface
    {
        return $this->operationsGetDoubleEndorsingByHashAsyncWithHttpInfo($hash, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetDoubleEndorsingByHashAsyncWithHttpInfo
     *
     * Get double endorsing by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoubleEndorsingByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetDoubleEndorsingByHashAsyncWithHttpInfo(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDoubleEndorsingByHash'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\DoubleEndorsingOperation[]';
        $request = $this->operationsGetDoubleEndorsingByHashRequest($hash, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetDoubleEndorsingByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoubleEndorsingByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetDoubleEndorsingByHashRequest(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDoubleEndorsingByHash'][0]
    ): Request
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetDoubleEndorsingByHash'
            );
        }



        $resourcePath = '/v1/operations/double_endorsing/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetDoubleEndorsingCount
     *
     * Get double endorsing count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters double endorsing operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters double endorsing operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoubleEndorsingCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return int
     */
    public function operationsGetDoubleEndorsingCount(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetDoubleEndorsingCount'][0]
    ): int
    {
        list($response) = $this->operationsGetDoubleEndorsingCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetDoubleEndorsingCountWithHttpInfo
     *
     * Get double endorsing count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters double endorsing operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters double endorsing operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoubleEndorsingCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetDoubleEndorsingCountWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetDoubleEndorsingCount'][0]
    ): array
    {
        $request = $this->operationsGetDoubleEndorsingCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('int', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'int';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetDoubleEndorsingCountAsync
     *
     * Get double endorsing count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters double endorsing operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters double endorsing operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoubleEndorsingCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetDoubleEndorsingCountAsync(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetDoubleEndorsingCount'][0]
    ): PromiseInterface
    {
        return $this->operationsGetDoubleEndorsingCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetDoubleEndorsingCountAsyncWithHttpInfo
     *
     * Get double endorsing count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters double endorsing operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters double endorsing operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoubleEndorsingCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetDoubleEndorsingCountAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetDoubleEndorsingCount'][0]
    ): PromiseInterface
    {
        $returnType = 'int';
        $request = $this->operationsGetDoubleEndorsingCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetDoubleEndorsingCount'
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters double endorsing operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters double endorsing operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoubleEndorsingCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetDoubleEndorsingCountRequest(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetDoubleEndorsingCount'][0]
    ): Request
    {




        $resourcePath = '/v1/operations/double_endorsing/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetDoublePreendorsing
     *
     * Get double preendorsing
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters by any of the specified fields. Example: &#x60;anyof.accuser.offender&#x3D;tz1...&#x60; will return operations where &#x60;accuser&#x60; OR &#x60;offender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $accuser Filters by accuser. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;offender&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $offender Filters by offender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;accuser&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters operations by internal TzKT id. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;accusedLevel&#x60;, &#x60;accuserRewards&#x60;, &#x60;offenderLostDeposits&#x60;, &#x60;offenderLostRewards&#x60;, &#x60;offenderLostFees&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoublePreendorsing'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\DoublePreendorsingOperation[]
     */
    public function operationsGetDoublePreendorsing(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $accuser = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $offender = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDoublePreendorsing'][0]
    ): array
    {
        list($response) = $this->operationsGetDoublePreendorsingWithHttpInfo($anyof, $accuser, $offender, $id, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetDoublePreendorsingWithHttpInfo
     *
     * Get double preendorsing
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters by any of the specified fields. Example: &#x60;anyof.accuser.offender&#x3D;tz1...&#x60; will return operations where &#x60;accuser&#x60; OR &#x60;offender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $accuser Filters by accuser. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;offender&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $offender Filters by offender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;accuser&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters operations by internal TzKT id. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;accusedLevel&#x60;, &#x60;accuserRewards&#x60;, &#x60;offenderLostDeposits&#x60;, &#x60;offenderLostRewards&#x60;, &#x60;offenderLostFees&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoublePreendorsing'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\DoublePreendorsingOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetDoublePreendorsingWithHttpInfo(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $accuser = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $offender = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDoublePreendorsing'][0]
    ): array
    {
        $request = $this->operationsGetDoublePreendorsingRequest($anyof, $accuser, $offender, $id, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\DoublePreendorsingOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\DoublePreendorsingOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\DoublePreendorsingOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\DoublePreendorsingOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\DoublePreendorsingOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetDoublePreendorsingAsync
     *
     * Get double preendorsing
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters by any of the specified fields. Example: &#x60;anyof.accuser.offender&#x3D;tz1...&#x60; will return operations where &#x60;accuser&#x60; OR &#x60;offender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $accuser Filters by accuser. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;offender&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $offender Filters by offender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;accuser&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters operations by internal TzKT id. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;accusedLevel&#x60;, &#x60;accuserRewards&#x60;, &#x60;offenderLostDeposits&#x60;, &#x60;offenderLostRewards&#x60;, &#x60;offenderLostFees&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoublePreendorsing'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetDoublePreendorsingAsync(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $accuser = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $offender = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDoublePreendorsing'][0]
    ): PromiseInterface
    {
        return $this->operationsGetDoublePreendorsingAsyncWithHttpInfo($anyof, $accuser, $offender, $id, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetDoublePreendorsingAsyncWithHttpInfo
     *
     * Get double preendorsing
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters by any of the specified fields. Example: &#x60;anyof.accuser.offender&#x3D;tz1...&#x60; will return operations where &#x60;accuser&#x60; OR &#x60;offender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $accuser Filters by accuser. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;offender&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $offender Filters by offender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;accuser&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters operations by internal TzKT id. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;accusedLevel&#x60;, &#x60;accuserRewards&#x60;, &#x60;offenderLostDeposits&#x60;, &#x60;offenderLostRewards&#x60;, &#x60;offenderLostFees&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoublePreendorsing'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetDoublePreendorsingAsyncWithHttpInfo(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $accuser = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $offender = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDoublePreendorsing'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\DoublePreendorsingOperation[]';
        $request = $this->operationsGetDoublePreendorsingRequest($anyof, $accuser, $offender, $id, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetDoublePreendorsing'
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters by any of the specified fields. Example: &#x60;anyof.accuser.offender&#x3D;tz1...&#x60; will return operations where &#x60;accuser&#x60; OR &#x60;offender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $accuser Filters by accuser. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;offender&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $offender Filters by offender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;accuser&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters operations by internal TzKT id. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;accusedLevel&#x60;, &#x60;accuserRewards&#x60;, &#x60;offenderLostDeposits&#x60;, &#x60;offenderLostRewards&#x60;, &#x60;offenderLostFees&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoublePreendorsing'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetDoublePreendorsingRequest(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $accuser = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $offender = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDoublePreendorsing'][0]
    ): Request
    {










        if ($limit !== null && $limit > 10000) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetDoublePreendorsing, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetDoublePreendorsing, must be bigger than or equal to 0.');
        }
        


        $resourcePath = '/v1/operations/double_preendorsing';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $anyof,
            'anyof', // param base name
            '\Tzkt\Model\AnyOfParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $accuser,
            'accuser', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offender,
            'offender', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            '\Tzkt\Model\Int64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            '\Tzkt\Model\SelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            '\Tzkt\Model\SortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            '\Tzkt\Model\OffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetDoublePreendorsingByHash
     *
     * Get double preendorsing by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoublePreendorsingByHash'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\DoublePreendorsingOperation[]
     */
    public function operationsGetDoublePreendorsingByHash(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDoublePreendorsingByHash'][0]
    ): array
    {
        list($response) = $this->operationsGetDoublePreendorsingByHashWithHttpInfo($hash, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetDoublePreendorsingByHashWithHttpInfo
     *
     * Get double preendorsing by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoublePreendorsingByHash'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\DoublePreendorsingOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetDoublePreendorsingByHashWithHttpInfo(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDoublePreendorsingByHash'][0]
    ): array
    {
        $request = $this->operationsGetDoublePreendorsingByHashRequest($hash, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\DoublePreendorsingOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\DoublePreendorsingOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\DoublePreendorsingOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\DoublePreendorsingOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\DoublePreendorsingOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetDoublePreendorsingByHashAsync
     *
     * Get double preendorsing by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoublePreendorsingByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetDoublePreendorsingByHashAsync(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDoublePreendorsingByHash'][0]
    ): PromiseInterface
    {
        return $this->operationsGetDoublePreendorsingByHashAsyncWithHttpInfo($hash, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetDoublePreendorsingByHashAsyncWithHttpInfo
     *
     * Get double preendorsing by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoublePreendorsingByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetDoublePreendorsingByHashAsyncWithHttpInfo(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDoublePreendorsingByHash'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\DoublePreendorsingOperation[]';
        $request = $this->operationsGetDoublePreendorsingByHashRequest($hash, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetDoublePreendorsingByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoublePreendorsingByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetDoublePreendorsingByHashRequest(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDoublePreendorsingByHash'][0]
    ): Request
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetDoublePreendorsingByHash'
            );
        }



        $resourcePath = '/v1/operations/double_preendorsing/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetDoublePreendorsingCount
     *
     * Get double preendorsing count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoublePreendorsingCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return int
     */
    public function operationsGetDoublePreendorsingCount(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetDoublePreendorsingCount'][0]
    ): int
    {
        list($response) = $this->operationsGetDoublePreendorsingCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetDoublePreendorsingCountWithHttpInfo
     *
     * Get double preendorsing count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoublePreendorsingCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetDoublePreendorsingCountWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetDoublePreendorsingCount'][0]
    ): array
    {
        $request = $this->operationsGetDoublePreendorsingCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('int', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'int';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetDoublePreendorsingCountAsync
     *
     * Get double preendorsing count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoublePreendorsingCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetDoublePreendorsingCountAsync(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetDoublePreendorsingCount'][0]
    ): PromiseInterface
    {
        return $this->operationsGetDoublePreendorsingCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetDoublePreendorsingCountAsyncWithHttpInfo
     *
     * Get double preendorsing count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoublePreendorsingCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetDoublePreendorsingCountAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetDoublePreendorsingCount'][0]
    ): PromiseInterface
    {
        $returnType = 'int';
        $request = $this->operationsGetDoublePreendorsingCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetDoublePreendorsingCount'
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoublePreendorsingCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetDoublePreendorsingCountRequest(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetDoublePreendorsingCount'][0]
    ): Request
    {




        $resourcePath = '/v1/operations/double_preendorsing/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetDrainDelegateByHash
     *
     * Get drain delegate by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDrainDelegateByHash'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\DrainDelegateOperation[]
     */
    public function operationsGetDrainDelegateByHash(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDrainDelegateByHash'][0]
    ): array
    {
        list($response) = $this->operationsGetDrainDelegateByHashWithHttpInfo($hash, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetDrainDelegateByHashWithHttpInfo
     *
     * Get drain delegate by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDrainDelegateByHash'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\DrainDelegateOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetDrainDelegateByHashWithHttpInfo(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDrainDelegateByHash'][0]
    ): array
    {
        $request = $this->operationsGetDrainDelegateByHashRequest($hash, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\DrainDelegateOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\DrainDelegateOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\DrainDelegateOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\DrainDelegateOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\DrainDelegateOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetDrainDelegateByHashAsync
     *
     * Get drain delegate by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDrainDelegateByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetDrainDelegateByHashAsync(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDrainDelegateByHash'][0]
    ): PromiseInterface
    {
        return $this->operationsGetDrainDelegateByHashAsyncWithHttpInfo($hash, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetDrainDelegateByHashAsyncWithHttpInfo
     *
     * Get drain delegate by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDrainDelegateByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetDrainDelegateByHashAsyncWithHttpInfo(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDrainDelegateByHash'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\DrainDelegateOperation[]';
        $request = $this->operationsGetDrainDelegateByHashRequest($hash, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetDrainDelegateByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDrainDelegateByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetDrainDelegateByHashRequest(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDrainDelegateByHash'][0]
    ): Request
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetDrainDelegateByHash'
            );
        }



        $resourcePath = '/v1/operations/drain_delegate/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetDrainDelegateOps
     *
     * Get drain delegate
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters by any of the specified fields. Example: &#x60;anyof.delegate.target&#x3D;tz1...&#x60; will return operations where &#x60;delegate&#x60; OR &#x60;target&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $delegate Filters by drained baker. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $target Filters by target. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDrainDelegateOps'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\DrainDelegateOperation[]
     */
    public function operationsGetDrainDelegateOps(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $delegate = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $target = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDrainDelegateOps'][0]
    ): array
    {
        list($response) = $this->operationsGetDrainDelegateOpsWithHttpInfo($anyof, $delegate, $target, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetDrainDelegateOpsWithHttpInfo
     *
     * Get drain delegate
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters by any of the specified fields. Example: &#x60;anyof.delegate.target&#x3D;tz1...&#x60; will return operations where &#x60;delegate&#x60; OR &#x60;target&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $delegate Filters by drained baker. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $target Filters by target. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDrainDelegateOps'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\DrainDelegateOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetDrainDelegateOpsWithHttpInfo(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $delegate = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $target = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDrainDelegateOps'][0]
    ): array
    {
        $request = $this->operationsGetDrainDelegateOpsRequest($anyof, $delegate, $target, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\DrainDelegateOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\DrainDelegateOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\DrainDelegateOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\DrainDelegateOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\DrainDelegateOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetDrainDelegateOpsAsync
     *
     * Get drain delegate
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters by any of the specified fields. Example: &#x60;anyof.delegate.target&#x3D;tz1...&#x60; will return operations where &#x60;delegate&#x60; OR &#x60;target&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $delegate Filters by drained baker. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $target Filters by target. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDrainDelegateOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetDrainDelegateOpsAsync(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $delegate = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $target = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDrainDelegateOps'][0]
    ): PromiseInterface
    {
        return $this->operationsGetDrainDelegateOpsAsyncWithHttpInfo($anyof, $delegate, $target, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetDrainDelegateOpsAsyncWithHttpInfo
     *
     * Get drain delegate
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters by any of the specified fields. Example: &#x60;anyof.delegate.target&#x3D;tz1...&#x60; will return operations where &#x60;delegate&#x60; OR &#x60;target&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $delegate Filters by drained baker. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $target Filters by target. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDrainDelegateOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetDrainDelegateOpsAsyncWithHttpInfo(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $delegate = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $target = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDrainDelegateOps'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\DrainDelegateOperation[]';
        $request = $this->operationsGetDrainDelegateOpsRequest($anyof, $delegate, $target, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetDrainDelegateOps'
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters by any of the specified fields. Example: &#x60;anyof.delegate.target&#x3D;tz1...&#x60; will return operations where &#x60;delegate&#x60; OR &#x60;target&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $delegate Filters by drained baker. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $target Filters by target. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDrainDelegateOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetDrainDelegateOpsRequest(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $delegate = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $target = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetDrainDelegateOps'][0]
    ): Request
    {









        if ($limit !== null && $limit > 10000) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetDrainDelegateOps, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetDrainDelegateOps, must be bigger than or equal to 0.');
        }
        


        $resourcePath = '/v1/operations/drain_delegate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $anyof,
            'anyof', // param base name
            '\Tzkt\Model\AnyOfParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $delegate,
            'delegate', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $target,
            'target', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            '\Tzkt\Model\SelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            '\Tzkt\Model\SortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            '\Tzkt\Model\OffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetDrainDelegateOpsCount
     *
     * Get drain delegate count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDrainDelegateOpsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return int
     */
    public function operationsGetDrainDelegateOpsCount(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetDrainDelegateOpsCount'][0]
    ): int
    {
        list($response) = $this->operationsGetDrainDelegateOpsCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetDrainDelegateOpsCountWithHttpInfo
     *
     * Get drain delegate count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDrainDelegateOpsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetDrainDelegateOpsCountWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetDrainDelegateOpsCount'][0]
    ): array
    {
        $request = $this->operationsGetDrainDelegateOpsCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('int', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'int';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetDrainDelegateOpsCountAsync
     *
     * Get drain delegate count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDrainDelegateOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetDrainDelegateOpsCountAsync(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetDrainDelegateOpsCount'][0]
    ): PromiseInterface
    {
        return $this->operationsGetDrainDelegateOpsCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetDrainDelegateOpsCountAsyncWithHttpInfo
     *
     * Get drain delegate count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDrainDelegateOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetDrainDelegateOpsCountAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetDrainDelegateOpsCount'][0]
    ): PromiseInterface
    {
        $returnType = 'int';
        $request = $this->operationsGetDrainDelegateOpsCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetDrainDelegateOpsCount'
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDrainDelegateOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetDrainDelegateOpsCountRequest(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetDrainDelegateOpsCount'][0]
    ): Request
    {




        $resourcePath = '/v1/operations/drain_delegate/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetEndorsementByHash
     *
     * Get endorsement by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetEndorsementByHash'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\EndorsementOperation[]
     */
    public function operationsGetEndorsementByHash(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetEndorsementByHash'][0]
    ): array
    {
        list($response) = $this->operationsGetEndorsementByHashWithHttpInfo($hash, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetEndorsementByHashWithHttpInfo
     *
     * Get endorsement by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetEndorsementByHash'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\EndorsementOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetEndorsementByHashWithHttpInfo(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetEndorsementByHash'][0]
    ): array
    {
        $request = $this->operationsGetEndorsementByHashRequest($hash, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\EndorsementOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\EndorsementOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\EndorsementOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\EndorsementOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\EndorsementOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetEndorsementByHashAsync
     *
     * Get endorsement by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetEndorsementByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetEndorsementByHashAsync(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetEndorsementByHash'][0]
    ): PromiseInterface
    {
        return $this->operationsGetEndorsementByHashAsyncWithHttpInfo($hash, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetEndorsementByHashAsyncWithHttpInfo
     *
     * Get endorsement by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetEndorsementByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetEndorsementByHashAsyncWithHttpInfo(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetEndorsementByHash'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\EndorsementOperation[]';
        $request = $this->operationsGetEndorsementByHashRequest($hash, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetEndorsementByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetEndorsementByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetEndorsementByHashRequest(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetEndorsementByHash'][0]
    ): Request
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetEndorsementByHash'
            );
        }



        $resourcePath = '/v1/operations/endorsements/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetEndorsements
     *
     * Get endorsements
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $delegate Filters endorsements by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters endorsements by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters endorsements by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts endorsements by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetEndorsements'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\EndorsementOperation[]
     */
    public function operationsGetEndorsements(
        ?\Tzkt\Model\AccountsGetDelegateParameter $delegate = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetEndorsements'][0]
    ): array
    {
        list($response) = $this->operationsGetEndorsementsWithHttpInfo($delegate, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetEndorsementsWithHttpInfo
     *
     * Get endorsements
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $delegate Filters endorsements by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters endorsements by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters endorsements by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts endorsements by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetEndorsements'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\EndorsementOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetEndorsementsWithHttpInfo(
        ?\Tzkt\Model\AccountsGetDelegateParameter $delegate = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetEndorsements'][0]
    ): array
    {
        $request = $this->operationsGetEndorsementsRequest($delegate, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\EndorsementOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\EndorsementOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\EndorsementOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\EndorsementOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\EndorsementOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetEndorsementsAsync
     *
     * Get endorsements
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $delegate Filters endorsements by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters endorsements by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters endorsements by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts endorsements by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetEndorsements'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetEndorsementsAsync(
        ?\Tzkt\Model\AccountsGetDelegateParameter $delegate = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetEndorsements'][0]
    ): PromiseInterface
    {
        return $this->operationsGetEndorsementsAsyncWithHttpInfo($delegate, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetEndorsementsAsyncWithHttpInfo
     *
     * Get endorsements
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $delegate Filters endorsements by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters endorsements by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters endorsements by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts endorsements by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetEndorsements'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetEndorsementsAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetDelegateParameter $delegate = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetEndorsements'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\EndorsementOperation[]';
        $request = $this->operationsGetEndorsementsRequest($delegate, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetEndorsements'
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $delegate Filters endorsements by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters endorsements by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters endorsements by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts endorsements by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetEndorsements'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetEndorsementsRequest(
        ?\Tzkt\Model\AccountsGetDelegateParameter $delegate = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetEndorsements'][0]
    ): Request
    {







        if ($limit !== null && $limit > 10000) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetEndorsements, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetEndorsements, must be bigger than or equal to 0.');
        }
        


        $resourcePath = '/v1/operations/endorsements';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $delegate,
            'delegate', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            '\Tzkt\Model\SelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            '\Tzkt\Model\SortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            '\Tzkt\Model\OffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetEndorsementsCount
     *
     * Get endorsements count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters endorsements by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters endorsements by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetEndorsementsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return int
     */
    public function operationsGetEndorsementsCount(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetEndorsementsCount'][0]
    ): int
    {
        list($response) = $this->operationsGetEndorsementsCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetEndorsementsCountWithHttpInfo
     *
     * Get endorsements count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters endorsements by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters endorsements by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetEndorsementsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetEndorsementsCountWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetEndorsementsCount'][0]
    ): array
    {
        $request = $this->operationsGetEndorsementsCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('int', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'int';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetEndorsementsCountAsync
     *
     * Get endorsements count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters endorsements by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters endorsements by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetEndorsementsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetEndorsementsCountAsync(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetEndorsementsCount'][0]
    ): PromiseInterface
    {
        return $this->operationsGetEndorsementsCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetEndorsementsCountAsyncWithHttpInfo
     *
     * Get endorsements count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters endorsements by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters endorsements by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetEndorsementsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetEndorsementsCountAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetEndorsementsCount'][0]
    ): PromiseInterface
    {
        $returnType = 'int';
        $request = $this->operationsGetEndorsementsCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetEndorsementsCount'
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters endorsements by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters endorsements by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetEndorsementsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetEndorsementsCountRequest(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetEndorsementsCount'][0]
    ): Request
    {




        $resourcePath = '/v1/operations/endorsements/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetEndorsingRewardById
     *
     * Get endorsing reward by id
     *
     * @param  int $id Operation id (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetEndorsingRewardById'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\EndorsingRewardOperation
     */
    public function operationsGetEndorsingRewardById(
        int $id,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetEndorsingRewardById'][0]
    ): \Tzkt\Model\EndorsingRewardOperation
    {
        list($response) = $this->operationsGetEndorsingRewardByIdWithHttpInfo($id, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetEndorsingRewardByIdWithHttpInfo
     *
     * Get endorsing reward by id
     *
     * @param  int $id Operation id (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetEndorsingRewardById'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\EndorsingRewardOperation, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetEndorsingRewardByIdWithHttpInfo(
        int $id,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetEndorsingRewardById'][0]
    ): array
    {
        $request = $this->operationsGetEndorsingRewardByIdRequest($id, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\EndorsingRewardOperation', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\EndorsingRewardOperation' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\EndorsingRewardOperation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\EndorsingRewardOperation';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\EndorsingRewardOperation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetEndorsingRewardByIdAsync
     *
     * Get endorsing reward by id
     *
     * @param  int $id Operation id (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetEndorsingRewardById'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetEndorsingRewardByIdAsync(
        int $id,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetEndorsingRewardById'][0]
    ): PromiseInterface
    {
        return $this->operationsGetEndorsingRewardByIdAsyncWithHttpInfo($id, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetEndorsingRewardByIdAsyncWithHttpInfo
     *
     * Get endorsing reward by id
     *
     * @param  int $id Operation id (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetEndorsingRewardById'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetEndorsingRewardByIdAsyncWithHttpInfo(
        int $id,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetEndorsingRewardById'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\EndorsingRewardOperation';
        $request = $this->operationsGetEndorsingRewardByIdRequest($id, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetEndorsingRewardById'
     *
     * @param  int $id Operation id (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetEndorsingRewardById'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetEndorsingRewardByIdRequest(
        int $id,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetEndorsingRewardById'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling operationsGetEndorsingRewardById'
            );
        }



        $resourcePath = '/v1/operations/endorsing_rewards/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetEndorsingRewards
     *
     * Get endorsing rewards
     *
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters operations by internal TzKT id. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $baker Filters by baker. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetEndorsingRewards'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\EndorsingRewardOperation[]
     */
    public function operationsGetEndorsingRewards(
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $baker = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetEndorsingRewards'][0]
    ): array
    {
        list($response) = $this->operationsGetEndorsingRewardsWithHttpInfo($id, $baker, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetEndorsingRewardsWithHttpInfo
     *
     * Get endorsing rewards
     *
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters operations by internal TzKT id. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $baker Filters by baker. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetEndorsingRewards'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\EndorsingRewardOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetEndorsingRewardsWithHttpInfo(
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $baker = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetEndorsingRewards'][0]
    ): array
    {
        $request = $this->operationsGetEndorsingRewardsRequest($id, $baker, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\EndorsingRewardOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\EndorsingRewardOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\EndorsingRewardOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\EndorsingRewardOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\EndorsingRewardOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetEndorsingRewardsAsync
     *
     * Get endorsing rewards
     *
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters operations by internal TzKT id. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $baker Filters by baker. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetEndorsingRewards'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetEndorsingRewardsAsync(
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $baker = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetEndorsingRewards'][0]
    ): PromiseInterface
    {
        return $this->operationsGetEndorsingRewardsAsyncWithHttpInfo($id, $baker, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetEndorsingRewardsAsyncWithHttpInfo
     *
     * Get endorsing rewards
     *
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters operations by internal TzKT id. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $baker Filters by baker. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetEndorsingRewards'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetEndorsingRewardsAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $baker = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetEndorsingRewards'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\EndorsingRewardOperation[]';
        $request = $this->operationsGetEndorsingRewardsRequest($id, $baker, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetEndorsingRewards'
     *
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters operations by internal TzKT id. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $baker Filters by baker. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetEndorsingRewards'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetEndorsingRewardsRequest(
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $baker = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetEndorsingRewards'][0]
    ): Request
    {








        if ($limit !== null && $limit > 10000) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetEndorsingRewards, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetEndorsingRewards, must be bigger than or equal to 0.');
        }
        


        $resourcePath = '/v1/operations/endorsing_rewards';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            '\Tzkt\Model\Int64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $baker,
            'baker', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            '\Tzkt\Model\SelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            '\Tzkt\Model\SortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            '\Tzkt\Model\OffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetEndorsingRewardsCount
     *
     * Get endorsing rewards count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetEndorsingRewardsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return int
     */
    public function operationsGetEndorsingRewardsCount(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetEndorsingRewardsCount'][0]
    ): int
    {
        list($response) = $this->operationsGetEndorsingRewardsCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetEndorsingRewardsCountWithHttpInfo
     *
     * Get endorsing rewards count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetEndorsingRewardsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetEndorsingRewardsCountWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetEndorsingRewardsCount'][0]
    ): array
    {
        $request = $this->operationsGetEndorsingRewardsCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('int', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'int';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetEndorsingRewardsCountAsync
     *
     * Get endorsing rewards count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetEndorsingRewardsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetEndorsingRewardsCountAsync(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetEndorsingRewardsCount'][0]
    ): PromiseInterface
    {
        return $this->operationsGetEndorsingRewardsCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetEndorsingRewardsCountAsyncWithHttpInfo
     *
     * Get endorsing rewards count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetEndorsingRewardsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetEndorsingRewardsCountAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetEndorsingRewardsCount'][0]
    ): PromiseInterface
    {
        $returnType = 'int';
        $request = $this->operationsGetEndorsingRewardsCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetEndorsingRewardsCount'
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetEndorsingRewardsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetEndorsingRewardsCountRequest(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetEndorsingRewardsCount'][0]
    ): Request
    {




        $resourcePath = '/v1/operations/endorsing_rewards/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetIncreasePaidStorageByHash
     *
     * Get increase paid storage by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetIncreasePaidStorageByHash'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\IncreasePaidStorageOperation[]
     */
    public function operationsGetIncreasePaidStorageByHash(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetIncreasePaidStorageByHash'][0]
    ): array
    {
        list($response) = $this->operationsGetIncreasePaidStorageByHashWithHttpInfo($hash, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetIncreasePaidStorageByHashWithHttpInfo
     *
     * Get increase paid storage by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetIncreasePaidStorageByHash'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\IncreasePaidStorageOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetIncreasePaidStorageByHashWithHttpInfo(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetIncreasePaidStorageByHash'][0]
    ): array
    {
        $request = $this->operationsGetIncreasePaidStorageByHashRequest($hash, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\IncreasePaidStorageOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\IncreasePaidStorageOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\IncreasePaidStorageOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\IncreasePaidStorageOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\IncreasePaidStorageOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetIncreasePaidStorageByHashAsync
     *
     * Get increase paid storage by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetIncreasePaidStorageByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetIncreasePaidStorageByHashAsync(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetIncreasePaidStorageByHash'][0]
    ): PromiseInterface
    {
        return $this->operationsGetIncreasePaidStorageByHashAsyncWithHttpInfo($hash, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetIncreasePaidStorageByHashAsyncWithHttpInfo
     *
     * Get increase paid storage by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetIncreasePaidStorageByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetIncreasePaidStorageByHashAsyncWithHttpInfo(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetIncreasePaidStorageByHash'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\IncreasePaidStorageOperation[]';
        $request = $this->operationsGetIncreasePaidStorageByHashRequest($hash, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetIncreasePaidStorageByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetIncreasePaidStorageByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetIncreasePaidStorageByHashRequest(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetIncreasePaidStorageByHash'][0]
    ): Request
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetIncreasePaidStorageByHash'
            );
        }



        $resourcePath = '/v1/operations/increase_paid_storage/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetIncreasePaidStorageCount
     *
     * Get increase paid storage count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetIncreasePaidStorageCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return int
     */
    public function operationsGetIncreasePaidStorageCount(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetIncreasePaidStorageCount'][0]
    ): int
    {
        list($response) = $this->operationsGetIncreasePaidStorageCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetIncreasePaidStorageCountWithHttpInfo
     *
     * Get increase paid storage count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetIncreasePaidStorageCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetIncreasePaidStorageCountWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetIncreasePaidStorageCount'][0]
    ): array
    {
        $request = $this->operationsGetIncreasePaidStorageCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('int', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'int';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetIncreasePaidStorageCountAsync
     *
     * Get increase paid storage count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetIncreasePaidStorageCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetIncreasePaidStorageCountAsync(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetIncreasePaidStorageCount'][0]
    ): PromiseInterface
    {
        return $this->operationsGetIncreasePaidStorageCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetIncreasePaidStorageCountAsyncWithHttpInfo
     *
     * Get increase paid storage count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetIncreasePaidStorageCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetIncreasePaidStorageCountAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetIncreasePaidStorageCount'][0]
    ): PromiseInterface
    {
        $returnType = 'int';
        $request = $this->operationsGetIncreasePaidStorageCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetIncreasePaidStorageCount'
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetIncreasePaidStorageCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetIncreasePaidStorageCountRequest(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetIncreasePaidStorageCount'][0]
    ): Request
    {




        $resourcePath = '/v1/operations/increase_paid_storage/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetIncreasePaidStorageOps
     *
     * Get increase paid storage
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $contract Filters by contract. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetIncreasePaidStorageOps'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\IncreasePaidStorageOperation[]
     */
    public function operationsGetIncreasePaidStorageOps(
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $contract = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetIncreasePaidStorageOps'][0]
    ): array
    {
        list($response) = $this->operationsGetIncreasePaidStorageOpsWithHttpInfo($sender, $contract, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetIncreasePaidStorageOpsWithHttpInfo
     *
     * Get increase paid storage
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $contract Filters by contract. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetIncreasePaidStorageOps'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\IncreasePaidStorageOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetIncreasePaidStorageOpsWithHttpInfo(
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $contract = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetIncreasePaidStorageOps'][0]
    ): array
    {
        $request = $this->operationsGetIncreasePaidStorageOpsRequest($sender, $contract, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\IncreasePaidStorageOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\IncreasePaidStorageOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\IncreasePaidStorageOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\IncreasePaidStorageOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\IncreasePaidStorageOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetIncreasePaidStorageOpsAsync
     *
     * Get increase paid storage
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $contract Filters by contract. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetIncreasePaidStorageOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetIncreasePaidStorageOpsAsync(
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $contract = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetIncreasePaidStorageOps'][0]
    ): PromiseInterface
    {
        return $this->operationsGetIncreasePaidStorageOpsAsyncWithHttpInfo($sender, $contract, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetIncreasePaidStorageOpsAsyncWithHttpInfo
     *
     * Get increase paid storage
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $contract Filters by contract. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetIncreasePaidStorageOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetIncreasePaidStorageOpsAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $contract = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetIncreasePaidStorageOps'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\IncreasePaidStorageOperation[]';
        $request = $this->operationsGetIncreasePaidStorageOpsRequest($sender, $contract, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetIncreasePaidStorageOps'
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $contract Filters by contract. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetIncreasePaidStorageOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetIncreasePaidStorageOpsRequest(
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $contract = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetIncreasePaidStorageOps'][0]
    ): Request
    {









        if ($limit !== null && $limit > 10000) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetIncreasePaidStorageOps, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetIncreasePaidStorageOps, must be bigger than or equal to 0.');
        }
        


        $resourcePath = '/v1/operations/increase_paid_storage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $contract,
            'contract', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            '\Tzkt\Model\OperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            '\Tzkt\Model\SelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            '\Tzkt\Model\SortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            '\Tzkt\Model\OffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetMigrationById
     *
     * Get migration by id
     *
     * @param  int $id Operation id (required)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetMigrationById'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\MigrationOperation
     */
    public function operationsGetMigrationById(
        int $id,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetMigrationById'][0]
    ): \Tzkt\Model\MigrationOperation
    {
        list($response) = $this->operationsGetMigrationByIdWithHttpInfo($id, $micheline, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetMigrationByIdWithHttpInfo
     *
     * Get migration by id
     *
     * @param  int $id Operation id (required)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetMigrationById'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\MigrationOperation, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetMigrationByIdWithHttpInfo(
        int $id,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetMigrationById'][0]
    ): array
    {
        $request = $this->operationsGetMigrationByIdRequest($id, $micheline, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\MigrationOperation', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\MigrationOperation' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\MigrationOperation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\MigrationOperation';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\MigrationOperation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetMigrationByIdAsync
     *
     * Get migration by id
     *
     * @param  int $id Operation id (required)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetMigrationById'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetMigrationByIdAsync(
        int $id,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetMigrationById'][0]
    ): PromiseInterface
    {
        return $this->operationsGetMigrationByIdAsyncWithHttpInfo($id, $micheline, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetMigrationByIdAsyncWithHttpInfo
     *
     * Get migration by id
     *
     * @param  int $id Operation id (required)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetMigrationById'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetMigrationByIdAsyncWithHttpInfo(
        int $id,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetMigrationById'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\MigrationOperation';
        $request = $this->operationsGetMigrationByIdRequest($id, $micheline, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetMigrationById'
     *
     * @param  int $id Operation id (required)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetMigrationById'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetMigrationByIdRequest(
        int $id,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetMigrationById'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling operationsGetMigrationById'
            );
        }




        $resourcePath = '/v1/operations/migrations/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $micheline,
            'micheline', // param base name
            '\Tzkt\Model\MichelineFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetMigrations
     *
     * Get migrations
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $account Filters migration operations by account. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\OperationsGetMigrationsKindParameter|null $kind Filters migration operations by kind (&#x60;bootstrap&#x60;, &#x60;activate_delegate&#x60;, &#x60;airdrop&#x60;, &#x60;proposal_invoice&#x60;, &#x60;origination&#x60;, &#x60;subsidy&#x60;, &#x60;remove_bigmap_key&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $balance_change Filters migration operations by amount. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters migration operations by internal TzKT id. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters migration operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters migration operations by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts migrations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetMigrations'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\MigrationOperation[]
     */
    public function operationsGetMigrations(
        ?\Tzkt\Model\AccountsGetDelegateParameter $account = null,
        ?\Tzkt\Model\OperationsGetMigrationsKindParameter $kind = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $balance_change = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetMigrations'][0]
    ): array
    {
        list($response) = $this->operationsGetMigrationsWithHttpInfo($account, $kind, $balance_change, $id, $level, $timestamp, $select, $sort, $offset, $limit, $micheline, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetMigrationsWithHttpInfo
     *
     * Get migrations
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $account Filters migration operations by account. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\OperationsGetMigrationsKindParameter|null $kind Filters migration operations by kind (&#x60;bootstrap&#x60;, &#x60;activate_delegate&#x60;, &#x60;airdrop&#x60;, &#x60;proposal_invoice&#x60;, &#x60;origination&#x60;, &#x60;subsidy&#x60;, &#x60;remove_bigmap_key&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $balance_change Filters migration operations by amount. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters migration operations by internal TzKT id. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters migration operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters migration operations by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts migrations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetMigrations'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\MigrationOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetMigrationsWithHttpInfo(
        ?\Tzkt\Model\AccountsGetDelegateParameter $account = null,
        ?\Tzkt\Model\OperationsGetMigrationsKindParameter $kind = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $balance_change = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetMigrations'][0]
    ): array
    {
        $request = $this->operationsGetMigrationsRequest($account, $kind, $balance_change, $id, $level, $timestamp, $select, $sort, $offset, $limit, $micheline, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\MigrationOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\MigrationOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\MigrationOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\MigrationOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\MigrationOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetMigrationsAsync
     *
     * Get migrations
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $account Filters migration operations by account. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\OperationsGetMigrationsKindParameter|null $kind Filters migration operations by kind (&#x60;bootstrap&#x60;, &#x60;activate_delegate&#x60;, &#x60;airdrop&#x60;, &#x60;proposal_invoice&#x60;, &#x60;origination&#x60;, &#x60;subsidy&#x60;, &#x60;remove_bigmap_key&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $balance_change Filters migration operations by amount. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters migration operations by internal TzKT id. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters migration operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters migration operations by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts migrations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetMigrations'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetMigrationsAsync(
        ?\Tzkt\Model\AccountsGetDelegateParameter $account = null,
        ?\Tzkt\Model\OperationsGetMigrationsKindParameter $kind = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $balance_change = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetMigrations'][0]
    ): PromiseInterface
    {
        return $this->operationsGetMigrationsAsyncWithHttpInfo($account, $kind, $balance_change, $id, $level, $timestamp, $select, $sort, $offset, $limit, $micheline, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetMigrationsAsyncWithHttpInfo
     *
     * Get migrations
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $account Filters migration operations by account. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\OperationsGetMigrationsKindParameter|null $kind Filters migration operations by kind (&#x60;bootstrap&#x60;, &#x60;activate_delegate&#x60;, &#x60;airdrop&#x60;, &#x60;proposal_invoice&#x60;, &#x60;origination&#x60;, &#x60;subsidy&#x60;, &#x60;remove_bigmap_key&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $balance_change Filters migration operations by amount. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters migration operations by internal TzKT id. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters migration operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters migration operations by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts migrations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetMigrations'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetMigrationsAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetDelegateParameter $account = null,
        ?\Tzkt\Model\OperationsGetMigrationsKindParameter $kind = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $balance_change = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetMigrations'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\MigrationOperation[]';
        $request = $this->operationsGetMigrationsRequest($account, $kind, $balance_change, $id, $level, $timestamp, $select, $sort, $offset, $limit, $micheline, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetMigrations'
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $account Filters migration operations by account. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\OperationsGetMigrationsKindParameter|null $kind Filters migration operations by kind (&#x60;bootstrap&#x60;, &#x60;activate_delegate&#x60;, &#x60;airdrop&#x60;, &#x60;proposal_invoice&#x60;, &#x60;origination&#x60;, &#x60;subsidy&#x60;, &#x60;remove_bigmap_key&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $balance_change Filters migration operations by amount. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters migration operations by internal TzKT id. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters migration operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters migration operations by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts migrations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetMigrations'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetMigrationsRequest(
        ?\Tzkt\Model\AccountsGetDelegateParameter $account = null,
        ?\Tzkt\Model\OperationsGetMigrationsKindParameter $kind = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $balance_change = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetMigrations'][0]
    ): Request
    {










        if ($limit !== null && $limit > 10000) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetMigrations, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetMigrations, must be bigger than or equal to 0.');
        }
        



        $resourcePath = '/v1/operations/migrations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account,
            'account', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $kind,
            'kind', // param base name
            '\Tzkt\Model\MigrationKindParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $balance_change,
            'balanceChange', // param base name
            '\Tzkt\Model\Int64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            '\Tzkt\Model\Int64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            '\Tzkt\Model\SelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            '\Tzkt\Model\SortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            '\Tzkt\Model\OffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $micheline,
            'micheline', // param base name
            '\Tzkt\Model\MichelineFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetMigrationsCount
     *
     * Get migrations count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters migrations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters migrations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetMigrationsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return int
     */
    public function operationsGetMigrationsCount(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetMigrationsCount'][0]
    ): int
    {
        list($response) = $this->operationsGetMigrationsCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetMigrationsCountWithHttpInfo
     *
     * Get migrations count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters migrations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters migrations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetMigrationsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetMigrationsCountWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetMigrationsCount'][0]
    ): array
    {
        $request = $this->operationsGetMigrationsCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('int', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'int';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetMigrationsCountAsync
     *
     * Get migrations count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters migrations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters migrations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetMigrationsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetMigrationsCountAsync(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetMigrationsCount'][0]
    ): PromiseInterface
    {
        return $this->operationsGetMigrationsCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetMigrationsCountAsyncWithHttpInfo
     *
     * Get migrations count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters migrations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters migrations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetMigrationsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetMigrationsCountAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetMigrationsCount'][0]
    ): PromiseInterface
    {
        $returnType = 'int';
        $request = $this->operationsGetMigrationsCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetMigrationsCount'
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters migrations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters migrations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetMigrationsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetMigrationsCountRequest(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetMigrationsCount'][0]
    ): Request
    {




        $resourcePath = '/v1/operations/migrations/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetNonceRevelationByHash
     *
     * Get nonce revelation by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetNonceRevelationByHash'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\NonceRevelationOperation[]
     */
    public function operationsGetNonceRevelationByHash(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetNonceRevelationByHash'][0]
    ): array
    {
        list($response) = $this->operationsGetNonceRevelationByHashWithHttpInfo($hash, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetNonceRevelationByHashWithHttpInfo
     *
     * Get nonce revelation by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetNonceRevelationByHash'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\NonceRevelationOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetNonceRevelationByHashWithHttpInfo(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetNonceRevelationByHash'][0]
    ): array
    {
        $request = $this->operationsGetNonceRevelationByHashRequest($hash, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\NonceRevelationOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\NonceRevelationOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\NonceRevelationOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\NonceRevelationOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\NonceRevelationOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetNonceRevelationByHashAsync
     *
     * Get nonce revelation by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetNonceRevelationByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetNonceRevelationByHashAsync(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetNonceRevelationByHash'][0]
    ): PromiseInterface
    {
        return $this->operationsGetNonceRevelationByHashAsyncWithHttpInfo($hash, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetNonceRevelationByHashAsyncWithHttpInfo
     *
     * Get nonce revelation by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetNonceRevelationByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetNonceRevelationByHashAsyncWithHttpInfo(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetNonceRevelationByHash'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\NonceRevelationOperation[]';
        $request = $this->operationsGetNonceRevelationByHashRequest($hash, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetNonceRevelationByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetNonceRevelationByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetNonceRevelationByHashRequest(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetNonceRevelationByHash'][0]
    ): Request
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetNonceRevelationByHash'
            );
        }



        $resourcePath = '/v1/operations/nonce_revelations/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetNonceRevelations
     *
     * Get nonce revelations
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters nonce revelation operations by any of the specified fields. Example: &#x60;anyof.baker.sender&#x3D;tz1...&#x60; will return operations where &#x60;baker&#x60; OR &#x60;sender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $baker Filters nonce revelation operations by baker. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;sender&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters nonce revelation operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;baker&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters nonce revelation operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $revealed_cycle Filters by cycle for which the nonce was revealed. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters nonce revelation operations by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts nonce revelation operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;revealedLevel&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetNonceRevelations'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\NonceRevelationOperation[]
     */
    public function operationsGetNonceRevelations(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $baker = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetIdParameter $revealed_cycle = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetNonceRevelations'][0]
    ): array
    {
        list($response) = $this->operationsGetNonceRevelationsWithHttpInfo($anyof, $baker, $sender, $level, $revealed_cycle, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetNonceRevelationsWithHttpInfo
     *
     * Get nonce revelations
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters nonce revelation operations by any of the specified fields. Example: &#x60;anyof.baker.sender&#x3D;tz1...&#x60; will return operations where &#x60;baker&#x60; OR &#x60;sender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $baker Filters nonce revelation operations by baker. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;sender&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters nonce revelation operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;baker&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters nonce revelation operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $revealed_cycle Filters by cycle for which the nonce was revealed. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters nonce revelation operations by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts nonce revelation operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;revealedLevel&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetNonceRevelations'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\NonceRevelationOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetNonceRevelationsWithHttpInfo(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $baker = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetIdParameter $revealed_cycle = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetNonceRevelations'][0]
    ): array
    {
        $request = $this->operationsGetNonceRevelationsRequest($anyof, $baker, $sender, $level, $revealed_cycle, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\NonceRevelationOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\NonceRevelationOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\NonceRevelationOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\NonceRevelationOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\NonceRevelationOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetNonceRevelationsAsync
     *
     * Get nonce revelations
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters nonce revelation operations by any of the specified fields. Example: &#x60;anyof.baker.sender&#x3D;tz1...&#x60; will return operations where &#x60;baker&#x60; OR &#x60;sender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $baker Filters nonce revelation operations by baker. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;sender&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters nonce revelation operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;baker&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters nonce revelation operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $revealed_cycle Filters by cycle for which the nonce was revealed. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters nonce revelation operations by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts nonce revelation operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;revealedLevel&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetNonceRevelations'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetNonceRevelationsAsync(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $baker = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetIdParameter $revealed_cycle = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetNonceRevelations'][0]
    ): PromiseInterface
    {
        return $this->operationsGetNonceRevelationsAsyncWithHttpInfo($anyof, $baker, $sender, $level, $revealed_cycle, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetNonceRevelationsAsyncWithHttpInfo
     *
     * Get nonce revelations
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters nonce revelation operations by any of the specified fields. Example: &#x60;anyof.baker.sender&#x3D;tz1...&#x60; will return operations where &#x60;baker&#x60; OR &#x60;sender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $baker Filters nonce revelation operations by baker. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;sender&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters nonce revelation operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;baker&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters nonce revelation operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $revealed_cycle Filters by cycle for which the nonce was revealed. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters nonce revelation operations by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts nonce revelation operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;revealedLevel&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetNonceRevelations'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetNonceRevelationsAsyncWithHttpInfo(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $baker = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetIdParameter $revealed_cycle = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetNonceRevelations'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\NonceRevelationOperation[]';
        $request = $this->operationsGetNonceRevelationsRequest($anyof, $baker, $sender, $level, $revealed_cycle, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetNonceRevelations'
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters nonce revelation operations by any of the specified fields. Example: &#x60;anyof.baker.sender&#x3D;tz1...&#x60; will return operations where &#x60;baker&#x60; OR &#x60;sender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $baker Filters nonce revelation operations by baker. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;sender&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters nonce revelation operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;baker&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters nonce revelation operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $revealed_cycle Filters by cycle for which the nonce was revealed. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters nonce revelation operations by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts nonce revelation operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;revealedLevel&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetNonceRevelations'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetNonceRevelationsRequest(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $baker = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetIdParameter $revealed_cycle = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetNonceRevelations'][0]
    ): Request
    {










        if ($limit !== null && $limit > 10000) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetNonceRevelations, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetNonceRevelations, must be bigger than or equal to 0.');
        }
        


        $resourcePath = '/v1/operations/nonce_revelations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $anyof,
            'anyof', // param base name
            '\Tzkt\Model\AnyOfParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $baker,
            'baker', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $revealed_cycle,
            'revealedCycle', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            '\Tzkt\Model\SelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            '\Tzkt\Model\SortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            '\Tzkt\Model\OffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetNonceRevelationsCount
     *
     * Get nonce revelations count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters seed nonce revelation operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters seed nonce revelation operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetNonceRevelationsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return int
     */
    public function operationsGetNonceRevelationsCount(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetNonceRevelationsCount'][0]
    ): int
    {
        list($response) = $this->operationsGetNonceRevelationsCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetNonceRevelationsCountWithHttpInfo
     *
     * Get nonce revelations count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters seed nonce revelation operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters seed nonce revelation operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetNonceRevelationsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetNonceRevelationsCountWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetNonceRevelationsCount'][0]
    ): array
    {
        $request = $this->operationsGetNonceRevelationsCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('int', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'int';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetNonceRevelationsCountAsync
     *
     * Get nonce revelations count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters seed nonce revelation operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters seed nonce revelation operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetNonceRevelationsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetNonceRevelationsCountAsync(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetNonceRevelationsCount'][0]
    ): PromiseInterface
    {
        return $this->operationsGetNonceRevelationsCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetNonceRevelationsCountAsyncWithHttpInfo
     *
     * Get nonce revelations count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters seed nonce revelation operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters seed nonce revelation operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetNonceRevelationsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetNonceRevelationsCountAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetNonceRevelationsCount'][0]
    ): PromiseInterface
    {
        $returnType = 'int';
        $request = $this->operationsGetNonceRevelationsCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetNonceRevelationsCount'
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters seed nonce revelation operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters seed nonce revelation operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetNonceRevelationsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetNonceRevelationsCountRequest(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetNonceRevelationsCount'][0]
    ): Request
    {




        $resourcePath = '/v1/operations/nonce_revelations/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetOriginationByHash
     *
     * Get origination by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\MichelineFormat|null $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetOriginationByHash'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\OriginationOperation[]
     */
    public function operationsGetOriginationByHash(
        string $hash,
        ?\Tzkt\Model\MichelineFormat $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetOriginationByHash'][0]
    ): array
    {
        list($response) = $this->operationsGetOriginationByHashWithHttpInfo($hash, $micheline, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetOriginationByHashWithHttpInfo
     *
     * Get origination by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\MichelineFormat|null $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetOriginationByHash'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\OriginationOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetOriginationByHashWithHttpInfo(
        string $hash,
        ?\Tzkt\Model\MichelineFormat $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetOriginationByHash'][0]
    ): array
    {
        $request = $this->operationsGetOriginationByHashRequest($hash, $micheline, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\OriginationOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\OriginationOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\OriginationOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\OriginationOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\OriginationOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetOriginationByHashAsync
     *
     * Get origination by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\MichelineFormat|null $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetOriginationByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetOriginationByHashAsync(
        string $hash,
        ?\Tzkt\Model\MichelineFormat $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetOriginationByHash'][0]
    ): PromiseInterface
    {
        return $this->operationsGetOriginationByHashAsyncWithHttpInfo($hash, $micheline, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetOriginationByHashAsyncWithHttpInfo
     *
     * Get origination by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\MichelineFormat|null $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetOriginationByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetOriginationByHashAsyncWithHttpInfo(
        string $hash,
        ?\Tzkt\Model\MichelineFormat $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetOriginationByHash'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\OriginationOperation[]';
        $request = $this->operationsGetOriginationByHashRequest($hash, $micheline, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetOriginationByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\MichelineFormat|null $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetOriginationByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetOriginationByHashRequest(
        string $hash,
        ?\Tzkt\Model\MichelineFormat $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetOriginationByHash'][0]
    ): Request
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetOriginationByHash'
            );
        }




        $resourcePath = '/v1/operations/originations/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $micheline?->value,
            'micheline', // param base name
            'MichelineFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetOriginationStatus
     *
     * Get origination status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetOriginationStatus'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return bool
     */
    public function operationsGetOriginationStatus(
        string $hash,
        string $contentType = self::contentTypes['operationsGetOriginationStatus'][0]
    ): bool
    {
        list($response) = $this->operationsGetOriginationStatusWithHttpInfo($hash, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetOriginationStatusWithHttpInfo
     *
     * Get origination status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetOriginationStatus'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of bool, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetOriginationStatusWithHttpInfo(
        string $hash,
        string $contentType = self::contentTypes['operationsGetOriginationStatus'][0]
    ): array
    {
        $request = $this->operationsGetOriginationStatusRequest($hash, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('bool', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('bool' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'bool', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'bool';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'bool',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetOriginationStatusAsync
     *
     * Get origination status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetOriginationStatus'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetOriginationStatusAsync(
        string $hash,
        string $contentType = self::contentTypes['operationsGetOriginationStatus'][0]
    ): PromiseInterface
    {
        return $this->operationsGetOriginationStatusAsyncWithHttpInfo($hash, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetOriginationStatusAsyncWithHttpInfo
     *
     * Get origination status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetOriginationStatus'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetOriginationStatusAsyncWithHttpInfo(
        string $hash,
        string $contentType = self::contentTypes['operationsGetOriginationStatus'][0]
    ): PromiseInterface
    {
        $returnType = 'bool';
        $request = $this->operationsGetOriginationStatusRequest($hash, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetOriginationStatus'
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetOriginationStatus'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetOriginationStatusRequest(
        string $hash,
        string $contentType = self::contentTypes['operationsGetOriginationStatus'][0]
    ): Request
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetOriginationStatus'
            );
        }


        $resourcePath = '/v1/operations/originations/{hash}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetOriginations
     *
     * Get originations
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters originations by any of the specified fields. Example: &#x60;anyof.sender.initiator&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;initiator&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all originations associated with a specified account. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $initiator Filters origination operations by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;contractManager&#x60;, &#x60;contractDelegate&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters origination operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;contractManager&#x60;, &#x60;contractDelegate&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $contract_manager Filters origination operations by manager. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;contractDelegate&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $contract_delegate Filters origination operations by delegate. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;contractManager&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $originated_contract Filters origination operations by originated contract. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters origination operations by internal TzKT id (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $type_hash Filters origination operations by 32-bit hash of originated contract parameter and storage types (helpful for searching originations of similar contracts) (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $code_hash Filters origination operations by 32-bit hash of originated contract code (helpful for searching originations of same contracts) (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters origination operations by level. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filters origination operations by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $sender_code_hash Filters by &#x60;senderCodeHash&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $any_code_hash Filters by either &#x60;senderCodeHash&#x60; or &#x60;codeHash&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters origination operations by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts originations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;, &#x60;allocationFee&#x60;, &#x60;contractBalance&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetOriginations'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\OriginationOperation[]
     */
    public function operationsGetOriginations(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $initiator = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $contract_manager = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $contract_delegate = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $originated_contract = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetIdParameter $type_hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $code_hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetIdParameter $sender_code_hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $any_code_hash = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetOriginations'][0]
    ): array
    {
        list($response) = $this->operationsGetOriginationsWithHttpInfo($anyof, $initiator, $sender, $contract_manager, $contract_delegate, $originated_contract, $id, $type_hash, $code_hash, $level, $timestamp, $sender_code_hash, $any_code_hash, $status, $select, $sort, $offset, $limit, $micheline, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetOriginationsWithHttpInfo
     *
     * Get originations
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters originations by any of the specified fields. Example: &#x60;anyof.sender.initiator&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;initiator&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all originations associated with a specified account. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $initiator Filters origination operations by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;contractManager&#x60;, &#x60;contractDelegate&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters origination operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;contractManager&#x60;, &#x60;contractDelegate&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $contract_manager Filters origination operations by manager. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;contractDelegate&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $contract_delegate Filters origination operations by delegate. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;contractManager&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $originated_contract Filters origination operations by originated contract. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters origination operations by internal TzKT id (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $type_hash Filters origination operations by 32-bit hash of originated contract parameter and storage types (helpful for searching originations of similar contracts) (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $code_hash Filters origination operations by 32-bit hash of originated contract code (helpful for searching originations of same contracts) (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters origination operations by level. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filters origination operations by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $sender_code_hash Filters by &#x60;senderCodeHash&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $any_code_hash Filters by either &#x60;senderCodeHash&#x60; or &#x60;codeHash&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters origination operations by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts originations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;, &#x60;allocationFee&#x60;, &#x60;contractBalance&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetOriginations'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\OriginationOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetOriginationsWithHttpInfo(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $initiator = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $contract_manager = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $contract_delegate = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $originated_contract = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetIdParameter $type_hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $code_hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetIdParameter $sender_code_hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $any_code_hash = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetOriginations'][0]
    ): array
    {
        $request = $this->operationsGetOriginationsRequest($anyof, $initiator, $sender, $contract_manager, $contract_delegate, $originated_contract, $id, $type_hash, $code_hash, $level, $timestamp, $sender_code_hash, $any_code_hash, $status, $select, $sort, $offset, $limit, $micheline, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\OriginationOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\OriginationOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\OriginationOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\OriginationOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\OriginationOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetOriginationsAsync
     *
     * Get originations
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters originations by any of the specified fields. Example: &#x60;anyof.sender.initiator&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;initiator&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all originations associated with a specified account. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $initiator Filters origination operations by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;contractManager&#x60;, &#x60;contractDelegate&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters origination operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;contractManager&#x60;, &#x60;contractDelegate&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $contract_manager Filters origination operations by manager. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;contractDelegate&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $contract_delegate Filters origination operations by delegate. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;contractManager&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $originated_contract Filters origination operations by originated contract. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters origination operations by internal TzKT id (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $type_hash Filters origination operations by 32-bit hash of originated contract parameter and storage types (helpful for searching originations of similar contracts) (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $code_hash Filters origination operations by 32-bit hash of originated contract code (helpful for searching originations of same contracts) (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters origination operations by level. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filters origination operations by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $sender_code_hash Filters by &#x60;senderCodeHash&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $any_code_hash Filters by either &#x60;senderCodeHash&#x60; or &#x60;codeHash&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters origination operations by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts originations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;, &#x60;allocationFee&#x60;, &#x60;contractBalance&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetOriginations'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetOriginationsAsync(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $initiator = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $contract_manager = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $contract_delegate = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $originated_contract = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetIdParameter $type_hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $code_hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetIdParameter $sender_code_hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $any_code_hash = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetOriginations'][0]
    ): PromiseInterface
    {
        return $this->operationsGetOriginationsAsyncWithHttpInfo($anyof, $initiator, $sender, $contract_manager, $contract_delegate, $originated_contract, $id, $type_hash, $code_hash, $level, $timestamp, $sender_code_hash, $any_code_hash, $status, $select, $sort, $offset, $limit, $micheline, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetOriginationsAsyncWithHttpInfo
     *
     * Get originations
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters originations by any of the specified fields. Example: &#x60;anyof.sender.initiator&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;initiator&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all originations associated with a specified account. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $initiator Filters origination operations by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;contractManager&#x60;, &#x60;contractDelegate&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters origination operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;contractManager&#x60;, &#x60;contractDelegate&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $contract_manager Filters origination operations by manager. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;contractDelegate&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $contract_delegate Filters origination operations by delegate. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;contractManager&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $originated_contract Filters origination operations by originated contract. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters origination operations by internal TzKT id (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $type_hash Filters origination operations by 32-bit hash of originated contract parameter and storage types (helpful for searching originations of similar contracts) (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $code_hash Filters origination operations by 32-bit hash of originated contract code (helpful for searching originations of same contracts) (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters origination operations by level. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filters origination operations by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $sender_code_hash Filters by &#x60;senderCodeHash&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $any_code_hash Filters by either &#x60;senderCodeHash&#x60; or &#x60;codeHash&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters origination operations by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts originations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;, &#x60;allocationFee&#x60;, &#x60;contractBalance&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetOriginations'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetOriginationsAsyncWithHttpInfo(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $initiator = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $contract_manager = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $contract_delegate = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $originated_contract = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetIdParameter $type_hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $code_hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetIdParameter $sender_code_hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $any_code_hash = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetOriginations'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\OriginationOperation[]';
        $request = $this->operationsGetOriginationsRequest($anyof, $initiator, $sender, $contract_manager, $contract_delegate, $originated_contract, $id, $type_hash, $code_hash, $level, $timestamp, $sender_code_hash, $any_code_hash, $status, $select, $sort, $offset, $limit, $micheline, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetOriginations'
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters originations by any of the specified fields. Example: &#x60;anyof.sender.initiator&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;initiator&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all originations associated with a specified account. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $initiator Filters origination operations by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;contractManager&#x60;, &#x60;contractDelegate&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters origination operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;contractManager&#x60;, &#x60;contractDelegate&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $contract_manager Filters origination operations by manager. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;contractDelegate&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $contract_delegate Filters origination operations by delegate. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;contractManager&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $originated_contract Filters origination operations by originated contract. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters origination operations by internal TzKT id (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $type_hash Filters origination operations by 32-bit hash of originated contract parameter and storage types (helpful for searching originations of similar contracts) (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $code_hash Filters origination operations by 32-bit hash of originated contract code (helpful for searching originations of same contracts) (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters origination operations by level. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filters origination operations by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $sender_code_hash Filters by &#x60;senderCodeHash&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $any_code_hash Filters by either &#x60;senderCodeHash&#x60; or &#x60;codeHash&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters origination operations by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts originations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;, &#x60;allocationFee&#x60;, &#x60;contractBalance&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetOriginations'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetOriginationsRequest(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $initiator = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $contract_manager = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $contract_delegate = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $originated_contract = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetIdParameter $type_hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $code_hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetIdParameter $sender_code_hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $any_code_hash = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetOriginations'][0]
    ): Request
    {


















        if ($limit !== null && $limit > 10000) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetOriginations, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetOriginations, must be bigger than or equal to 0.');
        }
        



        $resourcePath = '/v1/operations/originations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $anyof,
            'anyof', // param base name
            '\Tzkt\Model\AnyOfParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $initiator,
            'initiator', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $contract_manager,
            'contractManager', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $contract_delegate,
            'contractDelegate', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $originated_contract,
            'originatedContract', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            '\Tzkt\Model\Int64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type_hash,
            'typeHash', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $code_hash,
            'codeHash', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\TimestampParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender_code_hash,
            'senderCodeHash', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $any_code_hash,
            'anyCodeHash', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            '\Tzkt\Model\OperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            '\Tzkt\Model\SelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            '\Tzkt\Model\SortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            '\Tzkt\Model\OffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $micheline,
            'micheline', // param base name
            '\Tzkt\Model\MichelineFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetOriginationsCount
     *
     * Get originations count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters originations by level. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filters originations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetOriginationsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return int
     */
    public function operationsGetOriginationsCount(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetOriginationsCount'][0]
    ): int
    {
        list($response) = $this->operationsGetOriginationsCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetOriginationsCountWithHttpInfo
     *
     * Get originations count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters originations by level. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filters originations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetOriginationsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetOriginationsCountWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetOriginationsCount'][0]
    ): array
    {
        $request = $this->operationsGetOriginationsCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('int', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'int';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetOriginationsCountAsync
     *
     * Get originations count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters originations by level. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filters originations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetOriginationsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetOriginationsCountAsync(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetOriginationsCount'][0]
    ): PromiseInterface
    {
        return $this->operationsGetOriginationsCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetOriginationsCountAsyncWithHttpInfo
     *
     * Get originations count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters originations by level. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filters originations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetOriginationsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetOriginationsCountAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetOriginationsCount'][0]
    ): PromiseInterface
    {
        $returnType = 'int';
        $request = $this->operationsGetOriginationsCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetOriginationsCount'
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters originations by level. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filters originations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetOriginationsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetOriginationsCountRequest(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetOriginationsCount'][0]
    ): Request
    {




        $resourcePath = '/v1/operations/originations/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\TimestampParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetPreendorsementByHash
     *
     * Get preendorsement by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetPreendorsementByHash'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\PreendorsementOperation[]
     */
    public function operationsGetPreendorsementByHash(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetPreendorsementByHash'][0]
    ): array
    {
        list($response) = $this->operationsGetPreendorsementByHashWithHttpInfo($hash, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetPreendorsementByHashWithHttpInfo
     *
     * Get preendorsement by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetPreendorsementByHash'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\PreendorsementOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetPreendorsementByHashWithHttpInfo(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetPreendorsementByHash'][0]
    ): array
    {
        $request = $this->operationsGetPreendorsementByHashRequest($hash, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\PreendorsementOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\PreendorsementOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\PreendorsementOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\PreendorsementOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\PreendorsementOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetPreendorsementByHashAsync
     *
     * Get preendorsement by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetPreendorsementByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetPreendorsementByHashAsync(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetPreendorsementByHash'][0]
    ): PromiseInterface
    {
        return $this->operationsGetPreendorsementByHashAsyncWithHttpInfo($hash, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetPreendorsementByHashAsyncWithHttpInfo
     *
     * Get preendorsement by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetPreendorsementByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetPreendorsementByHashAsyncWithHttpInfo(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetPreendorsementByHash'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\PreendorsementOperation[]';
        $request = $this->operationsGetPreendorsementByHashRequest($hash, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetPreendorsementByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetPreendorsementByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetPreendorsementByHashRequest(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetPreendorsementByHash'][0]
    ): Request
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetPreendorsementByHash'
            );
        }



        $resourcePath = '/v1/operations/preendorsements/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetPreendorsements
     *
     * Get preendorsements
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $delegate Filters by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetPreendorsements'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\PreendorsementOperation[]
     */
    public function operationsGetPreendorsements(
        ?\Tzkt\Model\AccountsGetDelegateParameter $delegate = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetPreendorsements'][0]
    ): array
    {
        list($response) = $this->operationsGetPreendorsementsWithHttpInfo($delegate, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetPreendorsementsWithHttpInfo
     *
     * Get preendorsements
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $delegate Filters by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetPreendorsements'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\PreendorsementOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetPreendorsementsWithHttpInfo(
        ?\Tzkt\Model\AccountsGetDelegateParameter $delegate = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetPreendorsements'][0]
    ): array
    {
        $request = $this->operationsGetPreendorsementsRequest($delegate, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\PreendorsementOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\PreendorsementOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\PreendorsementOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\PreendorsementOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\PreendorsementOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetPreendorsementsAsync
     *
     * Get preendorsements
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $delegate Filters by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetPreendorsements'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetPreendorsementsAsync(
        ?\Tzkt\Model\AccountsGetDelegateParameter $delegate = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetPreendorsements'][0]
    ): PromiseInterface
    {
        return $this->operationsGetPreendorsementsAsyncWithHttpInfo($delegate, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetPreendorsementsAsyncWithHttpInfo
     *
     * Get preendorsements
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $delegate Filters by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetPreendorsements'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetPreendorsementsAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetDelegateParameter $delegate = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetPreendorsements'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\PreendorsementOperation[]';
        $request = $this->operationsGetPreendorsementsRequest($delegate, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetPreendorsements'
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $delegate Filters by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetPreendorsements'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetPreendorsementsRequest(
        ?\Tzkt\Model\AccountsGetDelegateParameter $delegate = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetPreendorsements'][0]
    ): Request
    {







        if ($limit !== null && $limit > 10000) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetPreendorsements, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetPreendorsements, must be bigger than or equal to 0.');
        }
        


        $resourcePath = '/v1/operations/preendorsements';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $delegate,
            'delegate', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            '\Tzkt\Model\SelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            '\Tzkt\Model\SortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            '\Tzkt\Model\OffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetPreendorsementsCount
     *
     * Get preendorsements count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetPreendorsementsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return int
     */
    public function operationsGetPreendorsementsCount(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetPreendorsementsCount'][0]
    ): int
    {
        list($response) = $this->operationsGetPreendorsementsCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetPreendorsementsCountWithHttpInfo
     *
     * Get preendorsements count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetPreendorsementsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetPreendorsementsCountWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetPreendorsementsCount'][0]
    ): array
    {
        $request = $this->operationsGetPreendorsementsCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('int', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'int';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetPreendorsementsCountAsync
     *
     * Get preendorsements count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetPreendorsementsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetPreendorsementsCountAsync(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetPreendorsementsCount'][0]
    ): PromiseInterface
    {
        return $this->operationsGetPreendorsementsCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetPreendorsementsCountAsyncWithHttpInfo
     *
     * Get preendorsements count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetPreendorsementsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetPreendorsementsCountAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetPreendorsementsCount'][0]
    ): PromiseInterface
    {
        $returnType = 'int';
        $request = $this->operationsGetPreendorsementsCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetPreendorsementsCount'
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetPreendorsementsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetPreendorsementsCountRequest(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetPreendorsementsCount'][0]
    ): Request
    {




        $resourcePath = '/v1/operations/preendorsements/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetProposalByHash
     *
     * Get proposal by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetProposalByHash'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\ProposalOperation[]
     */
    public function operationsGetProposalByHash(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetProposalByHash'][0]
    ): array
    {
        list($response) = $this->operationsGetProposalByHashWithHttpInfo($hash, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetProposalByHashWithHttpInfo
     *
     * Get proposal by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetProposalByHash'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\ProposalOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetProposalByHashWithHttpInfo(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetProposalByHash'][0]
    ): array
    {
        $request = $this->operationsGetProposalByHashRequest($hash, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\ProposalOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\ProposalOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\ProposalOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\ProposalOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\ProposalOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetProposalByHashAsync
     *
     * Get proposal by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetProposalByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetProposalByHashAsync(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetProposalByHash'][0]
    ): PromiseInterface
    {
        return $this->operationsGetProposalByHashAsyncWithHttpInfo($hash, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetProposalByHashAsyncWithHttpInfo
     *
     * Get proposal by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetProposalByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetProposalByHashAsyncWithHttpInfo(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetProposalByHash'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\ProposalOperation[]';
        $request = $this->operationsGetProposalByHashRequest($hash, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetProposalByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetProposalByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetProposalByHashRequest(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetProposalByHash'][0]
    ): Request
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetProposalByHash'
            );
        }



        $resourcePath = '/v1/operations/proposals/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetProposals
     *
     * Get proposals
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $delegate Filters proposal operations by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters proposal operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters proposal operations by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $epoch Filters proposal operations by voting epoch. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $period Filters proposal operations by voting period. (optional)
     * @param  \Tzkt\Model\OperationsGetBallotsProposalParameter|null $proposal Filters proposal operations by proposal hash. (optional)
     * @param  \Tzkt\Model\AccountsGetStakedParameter|null $duplicated Specify whether to include or exclude duplicates, which didn&#39;t actually upvote a proposal. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts proposal operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetProposals'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\ProposalOperation[]
     */
    public function operationsGetProposals(
        ?\Tzkt\Model\AccountsGetDelegateParameter $delegate = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetIdParameter $epoch = null,
        ?\Tzkt\Model\AccountsGetIdParameter $period = null,
        ?\Tzkt\Model\OperationsGetBallotsProposalParameter $proposal = null,
        ?\Tzkt\Model\AccountsGetStakedParameter $duplicated = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetProposals'][0]
    ): array
    {
        list($response) = $this->operationsGetProposalsWithHttpInfo($delegate, $level, $timestamp, $epoch, $period, $proposal, $duplicated, $select, $sort, $offset, $limit, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetProposalsWithHttpInfo
     *
     * Get proposals
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $delegate Filters proposal operations by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters proposal operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters proposal operations by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $epoch Filters proposal operations by voting epoch. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $period Filters proposal operations by voting period. (optional)
     * @param  \Tzkt\Model\OperationsGetBallotsProposalParameter|null $proposal Filters proposal operations by proposal hash. (optional)
     * @param  \Tzkt\Model\AccountsGetStakedParameter|null $duplicated Specify whether to include or exclude duplicates, which didn&#39;t actually upvote a proposal. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts proposal operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetProposals'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\ProposalOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetProposalsWithHttpInfo(
        ?\Tzkt\Model\AccountsGetDelegateParameter $delegate = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetIdParameter $epoch = null,
        ?\Tzkt\Model\AccountsGetIdParameter $period = null,
        ?\Tzkt\Model\OperationsGetBallotsProposalParameter $proposal = null,
        ?\Tzkt\Model\AccountsGetStakedParameter $duplicated = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetProposals'][0]
    ): array
    {
        $request = $this->operationsGetProposalsRequest($delegate, $level, $timestamp, $epoch, $period, $proposal, $duplicated, $select, $sort, $offset, $limit, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\ProposalOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\ProposalOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\ProposalOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\ProposalOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\ProposalOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetProposalsAsync
     *
     * Get proposals
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $delegate Filters proposal operations by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters proposal operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters proposal operations by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $epoch Filters proposal operations by voting epoch. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $period Filters proposal operations by voting period. (optional)
     * @param  \Tzkt\Model\OperationsGetBallotsProposalParameter|null $proposal Filters proposal operations by proposal hash. (optional)
     * @param  \Tzkt\Model\AccountsGetStakedParameter|null $duplicated Specify whether to include or exclude duplicates, which didn&#39;t actually upvote a proposal. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts proposal operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetProposals'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetProposalsAsync(
        ?\Tzkt\Model\AccountsGetDelegateParameter $delegate = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetIdParameter $epoch = null,
        ?\Tzkt\Model\AccountsGetIdParameter $period = null,
        ?\Tzkt\Model\OperationsGetBallotsProposalParameter $proposal = null,
        ?\Tzkt\Model\AccountsGetStakedParameter $duplicated = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetProposals'][0]
    ): PromiseInterface
    {
        return $this->operationsGetProposalsAsyncWithHttpInfo($delegate, $level, $timestamp, $epoch, $period, $proposal, $duplicated, $select, $sort, $offset, $limit, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetProposalsAsyncWithHttpInfo
     *
     * Get proposals
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $delegate Filters proposal operations by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters proposal operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters proposal operations by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $epoch Filters proposal operations by voting epoch. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $period Filters proposal operations by voting period. (optional)
     * @param  \Tzkt\Model\OperationsGetBallotsProposalParameter|null $proposal Filters proposal operations by proposal hash. (optional)
     * @param  \Tzkt\Model\AccountsGetStakedParameter|null $duplicated Specify whether to include or exclude duplicates, which didn&#39;t actually upvote a proposal. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts proposal operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetProposals'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetProposalsAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetDelegateParameter $delegate = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetIdParameter $epoch = null,
        ?\Tzkt\Model\AccountsGetIdParameter $period = null,
        ?\Tzkt\Model\OperationsGetBallotsProposalParameter $proposal = null,
        ?\Tzkt\Model\AccountsGetStakedParameter $duplicated = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetProposals'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\ProposalOperation[]';
        $request = $this->operationsGetProposalsRequest($delegate, $level, $timestamp, $epoch, $period, $proposal, $duplicated, $select, $sort, $offset, $limit, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetProposals'
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $delegate Filters proposal operations by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters proposal operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters proposal operations by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $epoch Filters proposal operations by voting epoch. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $period Filters proposal operations by voting period. (optional)
     * @param  \Tzkt\Model\OperationsGetBallotsProposalParameter|null $proposal Filters proposal operations by proposal hash. (optional)
     * @param  \Tzkt\Model\AccountsGetStakedParameter|null $duplicated Specify whether to include or exclude duplicates, which didn&#39;t actually upvote a proposal. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts proposal operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetProposals'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetProposalsRequest(
        ?\Tzkt\Model\AccountsGetDelegateParameter $delegate = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetIdParameter $epoch = null,
        ?\Tzkt\Model\AccountsGetIdParameter $period = null,
        ?\Tzkt\Model\OperationsGetBallotsProposalParameter $proposal = null,
        ?\Tzkt\Model\AccountsGetStakedParameter $duplicated = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetProposals'][0]
    ): Request
    {











        if ($limit !== null && $limit > 10000) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetProposals, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetProposals, must be bigger than or equal to 0.');
        }
        


        $resourcePath = '/v1/operations/proposals';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $delegate,
            'delegate', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $epoch,
            'epoch', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $period,
            'period', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $proposal,
            'proposal', // param base name
            '\Tzkt\Model\ProtocolParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $duplicated,
            'duplicated', // param base name
            '\Tzkt\Model\BoolParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            '\Tzkt\Model\SelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            '\Tzkt\Model\SortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            '\Tzkt\Model\OffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetProposalsCount
     *
     * Get proposals count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters proposal operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters proposal operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetProposalsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return int
     */
    public function operationsGetProposalsCount(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetProposalsCount'][0]
    ): int
    {
        list($response) = $this->operationsGetProposalsCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetProposalsCountWithHttpInfo
     *
     * Get proposals count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters proposal operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters proposal operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetProposalsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetProposalsCountWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetProposalsCount'][0]
    ): array
    {
        $request = $this->operationsGetProposalsCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('int', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'int';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetProposalsCountAsync
     *
     * Get proposals count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters proposal operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters proposal operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetProposalsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetProposalsCountAsync(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetProposalsCount'][0]
    ): PromiseInterface
    {
        return $this->operationsGetProposalsCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetProposalsCountAsyncWithHttpInfo
     *
     * Get proposals count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters proposal operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters proposal operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetProposalsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetProposalsCountAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetProposalsCount'][0]
    ): PromiseInterface
    {
        $returnType = 'int';
        $request = $this->operationsGetProposalsCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetProposalsCount'
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters proposal operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters proposal operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetProposalsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetProposalsCountRequest(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetProposalsCount'][0]
    ): Request
    {




        $resourcePath = '/v1/operations/proposals/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetRegisterConstantByHash
     *
     * Get register constant by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the constant value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRegisterConstantByHash'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\RegisterConstantOperation[]
     */
    public function operationsGetRegisterConstantByHash(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetRegisterConstantByHash'][0]
    ): array
    {
        list($response) = $this->operationsGetRegisterConstantByHashWithHttpInfo($hash, $micheline, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetRegisterConstantByHashWithHttpInfo
     *
     * Get register constant by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the constant value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRegisterConstantByHash'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\RegisterConstantOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetRegisterConstantByHashWithHttpInfo(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetRegisterConstantByHash'][0]
    ): array
    {
        $request = $this->operationsGetRegisterConstantByHashRequest($hash, $micheline, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\RegisterConstantOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\RegisterConstantOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\RegisterConstantOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\RegisterConstantOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\RegisterConstantOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetRegisterConstantByHashAsync
     *
     * Get register constant by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the constant value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRegisterConstantByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetRegisterConstantByHashAsync(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetRegisterConstantByHash'][0]
    ): PromiseInterface
    {
        return $this->operationsGetRegisterConstantByHashAsyncWithHttpInfo($hash, $micheline, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetRegisterConstantByHashAsyncWithHttpInfo
     *
     * Get register constant by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the constant value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRegisterConstantByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetRegisterConstantByHashAsyncWithHttpInfo(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetRegisterConstantByHash'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\RegisterConstantOperation[]';
        $request = $this->operationsGetRegisterConstantByHashRequest($hash, $micheline, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetRegisterConstantByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the constant value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRegisterConstantByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetRegisterConstantByHashRequest(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetRegisterConstantByHash'][0]
    ): Request
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetRegisterConstantByHash'
            );
        }




        $resourcePath = '/v1/operations/register_constants/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $micheline,
            'micheline', // param base name
            '\Tzkt\Model\MichelineFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetRegisterConstantStatus
     *
     * Get register constant status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRegisterConstantStatus'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return bool
     */
    public function operationsGetRegisterConstantStatus(
        string $hash,
        string $contentType = self::contentTypes['operationsGetRegisterConstantStatus'][0]
    ): bool
    {
        list($response) = $this->operationsGetRegisterConstantStatusWithHttpInfo($hash, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetRegisterConstantStatusWithHttpInfo
     *
     * Get register constant status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRegisterConstantStatus'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of bool, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetRegisterConstantStatusWithHttpInfo(
        string $hash,
        string $contentType = self::contentTypes['operationsGetRegisterConstantStatus'][0]
    ): array
    {
        $request = $this->operationsGetRegisterConstantStatusRequest($hash, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('bool', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('bool' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'bool', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'bool';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'bool',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetRegisterConstantStatusAsync
     *
     * Get register constant status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRegisterConstantStatus'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetRegisterConstantStatusAsync(
        string $hash,
        string $contentType = self::contentTypes['operationsGetRegisterConstantStatus'][0]
    ): PromiseInterface
    {
        return $this->operationsGetRegisterConstantStatusAsyncWithHttpInfo($hash, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetRegisterConstantStatusAsyncWithHttpInfo
     *
     * Get register constant status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRegisterConstantStatus'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetRegisterConstantStatusAsyncWithHttpInfo(
        string $hash,
        string $contentType = self::contentTypes['operationsGetRegisterConstantStatus'][0]
    ): PromiseInterface
    {
        $returnType = 'bool';
        $request = $this->operationsGetRegisterConstantStatusRequest($hash, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetRegisterConstantStatus'
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRegisterConstantStatus'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetRegisterConstantStatusRequest(
        string $hash,
        string $contentType = self::contentTypes['operationsGetRegisterConstantStatus'][0]
    ): Request
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetRegisterConstantStatus'
            );
        }


        $resourcePath = '/v1/operations/register_constants/{hash}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetRegisterConstants
     *
     * Get register constants
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysHashParameter|null $address Filters operations by global address of the created constant (starts with &#x60;expr..&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters operations by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters operations by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the constant value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRegisterConstants'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\RegisterConstantOperation[]
     */
    public function operationsGetRegisterConstants(
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysHashParameter $address = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetRegisterConstants'][0]
    ): array
    {
        list($response) = $this->operationsGetRegisterConstantsWithHttpInfo($sender, $address, $level, $timestamp, $status, $select, $sort, $offset, $limit, $micheline, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetRegisterConstantsWithHttpInfo
     *
     * Get register constants
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysHashParameter|null $address Filters operations by global address of the created constant (starts with &#x60;expr..&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters operations by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters operations by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the constant value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRegisterConstants'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\RegisterConstantOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetRegisterConstantsWithHttpInfo(
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysHashParameter $address = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetRegisterConstants'][0]
    ): array
    {
        $request = $this->operationsGetRegisterConstantsRequest($sender, $address, $level, $timestamp, $status, $select, $sort, $offset, $limit, $micheline, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\RegisterConstantOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\RegisterConstantOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\RegisterConstantOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\RegisterConstantOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\RegisterConstantOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetRegisterConstantsAsync
     *
     * Get register constants
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysHashParameter|null $address Filters operations by global address of the created constant (starts with &#x60;expr..&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters operations by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters operations by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the constant value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRegisterConstants'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetRegisterConstantsAsync(
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysHashParameter $address = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetRegisterConstants'][0]
    ): PromiseInterface
    {
        return $this->operationsGetRegisterConstantsAsyncWithHttpInfo($sender, $address, $level, $timestamp, $status, $select, $sort, $offset, $limit, $micheline, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetRegisterConstantsAsyncWithHttpInfo
     *
     * Get register constants
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysHashParameter|null $address Filters operations by global address of the created constant (starts with &#x60;expr..&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters operations by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters operations by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the constant value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRegisterConstants'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetRegisterConstantsAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysHashParameter $address = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetRegisterConstants'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\RegisterConstantOperation[]';
        $request = $this->operationsGetRegisterConstantsRequest($sender, $address, $level, $timestamp, $status, $select, $sort, $offset, $limit, $micheline, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetRegisterConstants'
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysHashParameter|null $address Filters operations by global address of the created constant (starts with &#x60;expr..&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters operations by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters operations by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the constant value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRegisterConstants'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetRegisterConstantsRequest(
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysHashParameter $address = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetRegisterConstants'][0]
    ): Request
    {









        if ($limit !== null && $limit > 10000) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetRegisterConstants, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetRegisterConstants, must be bigger than or equal to 0.');
        }
        



        $resourcePath = '/v1/operations/register_constants';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $address,
            'address', // param base name
            '\Tzkt\Model\ExpressionParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            '\Tzkt\Model\OperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            '\Tzkt\Model\SelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            '\Tzkt\Model\SortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            '\Tzkt\Model\OffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $micheline,
            'micheline', // param base name
            '\Tzkt\Model\MichelineFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetRegisterConstantsCount
     *
     * Get register constants count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRegisterConstantsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return int
     */
    public function operationsGetRegisterConstantsCount(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetRegisterConstantsCount'][0]
    ): int
    {
        list($response) = $this->operationsGetRegisterConstantsCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetRegisterConstantsCountWithHttpInfo
     *
     * Get register constants count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRegisterConstantsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetRegisterConstantsCountWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetRegisterConstantsCount'][0]
    ): array
    {
        $request = $this->operationsGetRegisterConstantsCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('int', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'int';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetRegisterConstantsCountAsync
     *
     * Get register constants count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRegisterConstantsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetRegisterConstantsCountAsync(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetRegisterConstantsCount'][0]
    ): PromiseInterface
    {
        return $this->operationsGetRegisterConstantsCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetRegisterConstantsCountAsyncWithHttpInfo
     *
     * Get register constants count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRegisterConstantsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetRegisterConstantsCountAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetRegisterConstantsCount'][0]
    ): PromiseInterface
    {
        $returnType = 'int';
        $request = $this->operationsGetRegisterConstantsCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetRegisterConstantsCount'
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRegisterConstantsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetRegisterConstantsCountRequest(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetRegisterConstantsCount'][0]
    ): Request
    {




        $resourcePath = '/v1/operations/register_constants/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetRevealByHash
     *
     * Get reveal by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRevealByHash'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\RevealOperation[]
     */
    public function operationsGetRevealByHash(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetRevealByHash'][0]
    ): array
    {
        list($response) = $this->operationsGetRevealByHashWithHttpInfo($hash, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetRevealByHashWithHttpInfo
     *
     * Get reveal by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRevealByHash'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\RevealOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetRevealByHashWithHttpInfo(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetRevealByHash'][0]
    ): array
    {
        $request = $this->operationsGetRevealByHashRequest($hash, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\RevealOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\RevealOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\RevealOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\RevealOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\RevealOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetRevealByHashAsync
     *
     * Get reveal by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRevealByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetRevealByHashAsync(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetRevealByHash'][0]
    ): PromiseInterface
    {
        return $this->operationsGetRevealByHashAsyncWithHttpInfo($hash, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetRevealByHashAsyncWithHttpInfo
     *
     * Get reveal by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRevealByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetRevealByHashAsyncWithHttpInfo(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetRevealByHash'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\RevealOperation[]';
        $request = $this->operationsGetRevealByHashRequest($hash, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetRevealByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRevealByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetRevealByHashRequest(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetRevealByHash'][0]
    ): Request
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetRevealByHash'
            );
        }



        $resourcePath = '/v1/operations/reveals/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetRevealStatus
     *
     * Get reveal status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRevealStatus'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return bool
     */
    public function operationsGetRevealStatus(
        string $hash,
        string $contentType = self::contentTypes['operationsGetRevealStatus'][0]
    ): bool
    {
        list($response) = $this->operationsGetRevealStatusWithHttpInfo($hash, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetRevealStatusWithHttpInfo
     *
     * Get reveal status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRevealStatus'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of bool, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetRevealStatusWithHttpInfo(
        string $hash,
        string $contentType = self::contentTypes['operationsGetRevealStatus'][0]
    ): array
    {
        $request = $this->operationsGetRevealStatusRequest($hash, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('bool', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('bool' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'bool', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'bool';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'bool',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetRevealStatusAsync
     *
     * Get reveal status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRevealStatus'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetRevealStatusAsync(
        string $hash,
        string $contentType = self::contentTypes['operationsGetRevealStatus'][0]
    ): PromiseInterface
    {
        return $this->operationsGetRevealStatusAsyncWithHttpInfo($hash, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetRevealStatusAsyncWithHttpInfo
     *
     * Get reveal status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRevealStatus'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetRevealStatusAsyncWithHttpInfo(
        string $hash,
        string $contentType = self::contentTypes['operationsGetRevealStatus'][0]
    ): PromiseInterface
    {
        $returnType = 'bool';
        $request = $this->operationsGetRevealStatusRequest($hash, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetRevealStatus'
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRevealStatus'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetRevealStatusRequest(
        string $hash,
        string $contentType = self::contentTypes['operationsGetRevealStatus'][0]
    ): Request
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetRevealStatus'
            );
        }


        $resourcePath = '/v1/operations/reveals/{hash}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetReveals
     *
     * Get reveals
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters reveal operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters reveal operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters reveal operations by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters reveal operations by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts reveals by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetReveals'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\RevealOperation[]
     */
    public function operationsGetReveals(
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetReveals'][0]
    ): array
    {
        list($response) = $this->operationsGetRevealsWithHttpInfo($sender, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetRevealsWithHttpInfo
     *
     * Get reveals
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters reveal operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters reveal operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters reveal operations by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters reveal operations by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts reveals by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetReveals'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\RevealOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetRevealsWithHttpInfo(
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetReveals'][0]
    ): array
    {
        $request = $this->operationsGetRevealsRequest($sender, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\RevealOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\RevealOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\RevealOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\RevealOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\RevealOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetRevealsAsync
     *
     * Get reveals
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters reveal operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters reveal operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters reveal operations by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters reveal operations by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts reveals by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetReveals'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetRevealsAsync(
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetReveals'][0]
    ): PromiseInterface
    {
        return $this->operationsGetRevealsAsyncWithHttpInfo($sender, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetRevealsAsyncWithHttpInfo
     *
     * Get reveals
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters reveal operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters reveal operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters reveal operations by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters reveal operations by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts reveals by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetReveals'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetRevealsAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetReveals'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\RevealOperation[]';
        $request = $this->operationsGetRevealsRequest($sender, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetReveals'
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters reveal operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters reveal operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters reveal operations by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters reveal operations by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts reveals by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetReveals'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetRevealsRequest(
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetReveals'][0]
    ): Request
    {








        if ($limit !== null && $limit > 10000) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetReveals, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetReveals, must be bigger than or equal to 0.');
        }
        


        $resourcePath = '/v1/operations/reveals';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            '\Tzkt\Model\OperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            '\Tzkt\Model\SelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            '\Tzkt\Model\SortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            '\Tzkt\Model\OffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetRevealsCount
     *
     * Get reveals count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters reveals by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters reveals by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRevealsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return int
     */
    public function operationsGetRevealsCount(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetRevealsCount'][0]
    ): int
    {
        list($response) = $this->operationsGetRevealsCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetRevealsCountWithHttpInfo
     *
     * Get reveals count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters reveals by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters reveals by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRevealsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetRevealsCountWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetRevealsCount'][0]
    ): array
    {
        $request = $this->operationsGetRevealsCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('int', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'int';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetRevealsCountAsync
     *
     * Get reveals count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters reveals by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters reveals by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRevealsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetRevealsCountAsync(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetRevealsCount'][0]
    ): PromiseInterface
    {
        return $this->operationsGetRevealsCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetRevealsCountAsyncWithHttpInfo
     *
     * Get reveals count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters reveals by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters reveals by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRevealsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetRevealsCountAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetRevealsCount'][0]
    ): PromiseInterface
    {
        $returnType = 'int';
        $request = $this->operationsGetRevealsCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetRevealsCount'
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters reveals by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters reveals by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRevealsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetRevealsCountRequest(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetRevealsCount'][0]
    ): Request
    {




        $resourcePath = '/v1/operations/reveals/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetRevelationPenalties
     *
     * Get revelation penalties
     *
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters operations by internal TzKT id. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $baker Filters revelation penalty operations by baker. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters revelation penalty operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters revelation penalty operations by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts revelation penalty operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRevelationPenalties'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\RevelationPenaltyOperation[]
     */
    public function operationsGetRevelationPenalties(
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $baker = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetRevelationPenalties'][0]
    ): array
    {
        list($response) = $this->operationsGetRevelationPenaltiesWithHttpInfo($id, $baker, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetRevelationPenaltiesWithHttpInfo
     *
     * Get revelation penalties
     *
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters operations by internal TzKT id. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $baker Filters revelation penalty operations by baker. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters revelation penalty operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters revelation penalty operations by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts revelation penalty operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRevelationPenalties'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\RevelationPenaltyOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetRevelationPenaltiesWithHttpInfo(
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $baker = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetRevelationPenalties'][0]
    ): array
    {
        $request = $this->operationsGetRevelationPenaltiesRequest($id, $baker, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\RevelationPenaltyOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\RevelationPenaltyOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\RevelationPenaltyOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\RevelationPenaltyOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\RevelationPenaltyOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetRevelationPenaltiesAsync
     *
     * Get revelation penalties
     *
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters operations by internal TzKT id. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $baker Filters revelation penalty operations by baker. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters revelation penalty operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters revelation penalty operations by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts revelation penalty operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRevelationPenalties'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetRevelationPenaltiesAsync(
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $baker = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetRevelationPenalties'][0]
    ): PromiseInterface
    {
        return $this->operationsGetRevelationPenaltiesAsyncWithHttpInfo($id, $baker, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetRevelationPenaltiesAsyncWithHttpInfo
     *
     * Get revelation penalties
     *
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters operations by internal TzKT id. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $baker Filters revelation penalty operations by baker. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters revelation penalty operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters revelation penalty operations by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts revelation penalty operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRevelationPenalties'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetRevelationPenaltiesAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $baker = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetRevelationPenalties'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\RevelationPenaltyOperation[]';
        $request = $this->operationsGetRevelationPenaltiesRequest($id, $baker, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetRevelationPenalties'
     *
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters operations by internal TzKT id. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $baker Filters revelation penalty operations by baker. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters revelation penalty operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters revelation penalty operations by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts revelation penalty operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRevelationPenalties'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetRevelationPenaltiesRequest(
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $baker = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetRevelationPenalties'][0]
    ): Request
    {








        if ($limit !== null && $limit > 10000) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetRevelationPenalties, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetRevelationPenalties, must be bigger than or equal to 0.');
        }
        


        $resourcePath = '/v1/operations/revelation_penalties';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            '\Tzkt\Model\Int64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $baker,
            'baker', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            '\Tzkt\Model\SelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            '\Tzkt\Model\SortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            '\Tzkt\Model\OffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetRevelationPenaltiesCount
     *
     * Get revelation penalties count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters revelation penalty operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters revelation penalty operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRevelationPenaltiesCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return int
     */
    public function operationsGetRevelationPenaltiesCount(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetRevelationPenaltiesCount'][0]
    ): int
    {
        list($response) = $this->operationsGetRevelationPenaltiesCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetRevelationPenaltiesCountWithHttpInfo
     *
     * Get revelation penalties count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters revelation penalty operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters revelation penalty operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRevelationPenaltiesCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetRevelationPenaltiesCountWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetRevelationPenaltiesCount'][0]
    ): array
    {
        $request = $this->operationsGetRevelationPenaltiesCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('int', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'int';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetRevelationPenaltiesCountAsync
     *
     * Get revelation penalties count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters revelation penalty operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters revelation penalty operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRevelationPenaltiesCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetRevelationPenaltiesCountAsync(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetRevelationPenaltiesCount'][0]
    ): PromiseInterface
    {
        return $this->operationsGetRevelationPenaltiesCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetRevelationPenaltiesCountAsyncWithHttpInfo
     *
     * Get revelation penalties count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters revelation penalty operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters revelation penalty operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRevelationPenaltiesCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetRevelationPenaltiesCountAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetRevelationPenaltiesCount'][0]
    ): PromiseInterface
    {
        $returnType = 'int';
        $request = $this->operationsGetRevelationPenaltiesCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetRevelationPenaltiesCount'
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters revelation penalty operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters revelation penalty operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRevelationPenaltiesCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetRevelationPenaltiesCountRequest(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetRevelationPenaltiesCount'][0]
    ): Request
    {




        $resourcePath = '/v1/operations/revelation_penalties/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetRevelationPenaltyById
     *
     * Get revelation penalty by id
     *
     * @param  int $id Operation id (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRevelationPenaltyById'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\RevelationPenaltyOperation
     */
    public function operationsGetRevelationPenaltyById(
        int $id,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetRevelationPenaltyById'][0]
    ): \Tzkt\Model\RevelationPenaltyOperation
    {
        list($response) = $this->operationsGetRevelationPenaltyByIdWithHttpInfo($id, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetRevelationPenaltyByIdWithHttpInfo
     *
     * Get revelation penalty by id
     *
     * @param  int $id Operation id (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRevelationPenaltyById'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\RevelationPenaltyOperation, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetRevelationPenaltyByIdWithHttpInfo(
        int $id,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetRevelationPenaltyById'][0]
    ): array
    {
        $request = $this->operationsGetRevelationPenaltyByIdRequest($id, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\RevelationPenaltyOperation', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\RevelationPenaltyOperation' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\RevelationPenaltyOperation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\RevelationPenaltyOperation';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\RevelationPenaltyOperation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetRevelationPenaltyByIdAsync
     *
     * Get revelation penalty by id
     *
     * @param  int $id Operation id (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRevelationPenaltyById'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetRevelationPenaltyByIdAsync(
        int $id,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetRevelationPenaltyById'][0]
    ): PromiseInterface
    {
        return $this->operationsGetRevelationPenaltyByIdAsyncWithHttpInfo($id, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetRevelationPenaltyByIdAsyncWithHttpInfo
     *
     * Get revelation penalty by id
     *
     * @param  int $id Operation id (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRevelationPenaltyById'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetRevelationPenaltyByIdAsyncWithHttpInfo(
        int $id,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetRevelationPenaltyById'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\RevelationPenaltyOperation';
        $request = $this->operationsGetRevelationPenaltyByIdRequest($id, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetRevelationPenaltyById'
     *
     * @param  int $id Operation id (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRevelationPenaltyById'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetRevelationPenaltyByIdRequest(
        int $id,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetRevelationPenaltyById'][0]
    ): Request
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling operationsGetRevelationPenaltyById'
            );
        }



        $resourcePath = '/v1/operations/revelation_penalties/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetSetDelegateParametersOps
     *
     * Get set_delegate_parameters ops
     *
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int|null $limit Maximum number of items to return. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysSelectParameter|null $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSetDelegateParametersOps'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\SetDelegateParametersOperation[]
     */
    public function operationsGetSetDelegateParametersOps(
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetSetDelegateParametersOps'][0]
    ): array
    {
        list($response) = $this->operationsGetSetDelegateParametersOpsWithHttpInfo($id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetSetDelegateParametersOpsWithHttpInfo
     *
     * Get set_delegate_parameters ops
     *
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int|null $limit Maximum number of items to return. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysSelectParameter|null $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSetDelegateParametersOps'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\SetDelegateParametersOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetSetDelegateParametersOpsWithHttpInfo(
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetSetDelegateParametersOps'][0]
    ): array
    {
        $request = $this->operationsGetSetDelegateParametersOpsRequest($id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\SetDelegateParametersOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\SetDelegateParametersOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\SetDelegateParametersOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\SetDelegateParametersOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\SetDelegateParametersOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetSetDelegateParametersOpsAsync
     *
     * Get set_delegate_parameters ops
     *
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int|null $limit Maximum number of items to return. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysSelectParameter|null $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSetDelegateParametersOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetSetDelegateParametersOpsAsync(
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetSetDelegateParametersOps'][0]
    ): PromiseInterface
    {
        return $this->operationsGetSetDelegateParametersOpsAsyncWithHttpInfo($id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetSetDelegateParametersOpsAsyncWithHttpInfo
     *
     * Get set_delegate_parameters ops
     *
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int|null $limit Maximum number of items to return. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysSelectParameter|null $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSetDelegateParametersOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetSetDelegateParametersOpsAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetSetDelegateParametersOps'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\SetDelegateParametersOperation[]';
        $request = $this->operationsGetSetDelegateParametersOpsRequest($id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetSetDelegateParametersOps'
     *
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int|null $limit Maximum number of items to return. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysSelectParameter|null $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSetDelegateParametersOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetSetDelegateParametersOpsRequest(
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetSetDelegateParametersOps'][0]
    ): Request
    {










        if ($limit !== null && $limit > 10000) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetSetDelegateParametersOps, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetSetDelegateParametersOps, must be bigger than or equal to 0.');
        }
        



        $resourcePath = '/v1/operations/set_delegate_parameters';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            '\Tzkt\Model\Int64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hash,
            'hash', // param base name
            '\Tzkt\Model\OpHashParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $counter,
            'counter', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\TimestampParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            '\Tzkt\Model\OperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            '\Tzkt\Model\SortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            '\Tzkt\Model\OffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            '\Tzkt\Model\SelectionParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetSetDelegateParametersOpsCount
     *
     * Get set_delegate_parameters ops count
     *
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSetDelegateParametersOpsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return int
     */
    public function operationsGetSetDelegateParametersOpsCount(
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        string $contentType = self::contentTypes['operationsGetSetDelegateParametersOpsCount'][0]
    ): int
    {
        list($response) = $this->operationsGetSetDelegateParametersOpsCountWithHttpInfo($id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetSetDelegateParametersOpsCountWithHttpInfo
     *
     * Get set_delegate_parameters ops count
     *
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSetDelegateParametersOpsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetSetDelegateParametersOpsCountWithHttpInfo(
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        string $contentType = self::contentTypes['operationsGetSetDelegateParametersOpsCount'][0]
    ): array
    {
        $request = $this->operationsGetSetDelegateParametersOpsCountRequest($id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('int', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'int';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetSetDelegateParametersOpsCountAsync
     *
     * Get set_delegate_parameters ops count
     *
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSetDelegateParametersOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetSetDelegateParametersOpsCountAsync(
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        string $contentType = self::contentTypes['operationsGetSetDelegateParametersOpsCount'][0]
    ): PromiseInterface
    {
        return $this->operationsGetSetDelegateParametersOpsCountAsyncWithHttpInfo($id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetSetDelegateParametersOpsCountAsyncWithHttpInfo
     *
     * Get set_delegate_parameters ops count
     *
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSetDelegateParametersOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetSetDelegateParametersOpsCountAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        string $contentType = self::contentTypes['operationsGetSetDelegateParametersOpsCount'][0]
    ): PromiseInterface
    {
        $returnType = 'int';
        $request = $this->operationsGetSetDelegateParametersOpsCountRequest($id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetSetDelegateParametersOpsCount'
     *
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSetDelegateParametersOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetSetDelegateParametersOpsCountRequest(
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        string $contentType = self::contentTypes['operationsGetSetDelegateParametersOpsCount'][0]
    ): Request
    {









        $resourcePath = '/v1/operations/set_delegate_parameters/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            '\Tzkt\Model\Int64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hash,
            'hash', // param base name
            '\Tzkt\Model\OpHashParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $counter,
            'counter', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\TimestampParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            '\Tzkt\Model\OperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetSetDepositsLimitByHash
     *
     * Get set deposits limit by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSetDepositsLimitByHash'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\SetDepositsLimitOperation[]
     */
    public function operationsGetSetDepositsLimitByHash(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetSetDepositsLimitByHash'][0]
    ): array
    {
        list($response) = $this->operationsGetSetDepositsLimitByHashWithHttpInfo($hash, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetSetDepositsLimitByHashWithHttpInfo
     *
     * Get set deposits limit by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSetDepositsLimitByHash'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\SetDepositsLimitOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetSetDepositsLimitByHashWithHttpInfo(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetSetDepositsLimitByHash'][0]
    ): array
    {
        $request = $this->operationsGetSetDepositsLimitByHashRequest($hash, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\SetDepositsLimitOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\SetDepositsLimitOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\SetDepositsLimitOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\SetDepositsLimitOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\SetDepositsLimitOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetSetDepositsLimitByHashAsync
     *
     * Get set deposits limit by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSetDepositsLimitByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetSetDepositsLimitByHashAsync(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetSetDepositsLimitByHash'][0]
    ): PromiseInterface
    {
        return $this->operationsGetSetDepositsLimitByHashAsyncWithHttpInfo($hash, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetSetDepositsLimitByHashAsyncWithHttpInfo
     *
     * Get set deposits limit by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSetDepositsLimitByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetSetDepositsLimitByHashAsyncWithHttpInfo(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetSetDepositsLimitByHash'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\SetDepositsLimitOperation[]';
        $request = $this->operationsGetSetDepositsLimitByHashRequest($hash, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetSetDepositsLimitByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSetDepositsLimitByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetSetDepositsLimitByHashRequest(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetSetDepositsLimitByHash'][0]
    ): Request
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetSetDepositsLimitByHash'
            );
        }



        $resourcePath = '/v1/operations/set_deposits_limits/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetSetDepositsLimitStatus
     *
     * Get set deposits limit status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSetDepositsLimitStatus'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return bool
     */
    public function operationsGetSetDepositsLimitStatus(
        string $hash,
        string $contentType = self::contentTypes['operationsGetSetDepositsLimitStatus'][0]
    ): bool
    {
        list($response) = $this->operationsGetSetDepositsLimitStatusWithHttpInfo($hash, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetSetDepositsLimitStatusWithHttpInfo
     *
     * Get set deposits limit status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSetDepositsLimitStatus'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of bool, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetSetDepositsLimitStatusWithHttpInfo(
        string $hash,
        string $contentType = self::contentTypes['operationsGetSetDepositsLimitStatus'][0]
    ): array
    {
        $request = $this->operationsGetSetDepositsLimitStatusRequest($hash, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('bool', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('bool' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'bool', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'bool';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'bool',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetSetDepositsLimitStatusAsync
     *
     * Get set deposits limit status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSetDepositsLimitStatus'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetSetDepositsLimitStatusAsync(
        string $hash,
        string $contentType = self::contentTypes['operationsGetSetDepositsLimitStatus'][0]
    ): PromiseInterface
    {
        return $this->operationsGetSetDepositsLimitStatusAsyncWithHttpInfo($hash, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetSetDepositsLimitStatusAsyncWithHttpInfo
     *
     * Get set deposits limit status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSetDepositsLimitStatus'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetSetDepositsLimitStatusAsyncWithHttpInfo(
        string $hash,
        string $contentType = self::contentTypes['operationsGetSetDepositsLimitStatus'][0]
    ): PromiseInterface
    {
        $returnType = 'bool';
        $request = $this->operationsGetSetDepositsLimitStatusRequest($hash, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetSetDepositsLimitStatus'
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSetDepositsLimitStatus'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetSetDepositsLimitStatusRequest(
        string $hash,
        string $contentType = self::contentTypes['operationsGetSetDepositsLimitStatus'][0]
    ): Request
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetSetDepositsLimitStatus'
            );
        }


        $resourcePath = '/v1/operations/set_deposits_limits/{hash}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetSetDepositsLimits
     *
     * Get set deposits limits
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSetDepositsLimits'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\SetDepositsLimitOperation[]
     */
    public function operationsGetSetDepositsLimits(
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetSetDepositsLimits'][0]
    ): array
    {
        list($response) = $this->operationsGetSetDepositsLimitsWithHttpInfo($sender, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetSetDepositsLimitsWithHttpInfo
     *
     * Get set deposits limits
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSetDepositsLimits'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\SetDepositsLimitOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetSetDepositsLimitsWithHttpInfo(
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetSetDepositsLimits'][0]
    ): array
    {
        $request = $this->operationsGetSetDepositsLimitsRequest($sender, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\SetDepositsLimitOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\SetDepositsLimitOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\SetDepositsLimitOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\SetDepositsLimitOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\SetDepositsLimitOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetSetDepositsLimitsAsync
     *
     * Get set deposits limits
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSetDepositsLimits'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetSetDepositsLimitsAsync(
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetSetDepositsLimits'][0]
    ): PromiseInterface
    {
        return $this->operationsGetSetDepositsLimitsAsyncWithHttpInfo($sender, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetSetDepositsLimitsAsyncWithHttpInfo
     *
     * Get set deposits limits
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSetDepositsLimits'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetSetDepositsLimitsAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetSetDepositsLimits'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\SetDepositsLimitOperation[]';
        $request = $this->operationsGetSetDepositsLimitsRequest($sender, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetSetDepositsLimits'
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSetDepositsLimits'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetSetDepositsLimitsRequest(
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetSetDepositsLimits'][0]
    ): Request
    {








        if ($limit !== null && $limit > 10000) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetSetDepositsLimits, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetSetDepositsLimits, must be bigger than or equal to 0.');
        }
        


        $resourcePath = '/v1/operations/set_deposits_limits';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            '\Tzkt\Model\OperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            '\Tzkt\Model\SelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            '\Tzkt\Model\SortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            '\Tzkt\Model\OffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetSetDepositsLimitsCount
     *
     * Get set deposits limits count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSetDepositsLimitsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return int
     */
    public function operationsGetSetDepositsLimitsCount(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetSetDepositsLimitsCount'][0]
    ): int
    {
        list($response) = $this->operationsGetSetDepositsLimitsCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetSetDepositsLimitsCountWithHttpInfo
     *
     * Get set deposits limits count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSetDepositsLimitsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetSetDepositsLimitsCountWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetSetDepositsLimitsCount'][0]
    ): array
    {
        $request = $this->operationsGetSetDepositsLimitsCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('int', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'int';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetSetDepositsLimitsCountAsync
     *
     * Get set deposits limits count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSetDepositsLimitsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetSetDepositsLimitsCountAsync(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetSetDepositsLimitsCount'][0]
    ): PromiseInterface
    {
        return $this->operationsGetSetDepositsLimitsCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetSetDepositsLimitsCountAsyncWithHttpInfo
     *
     * Get set deposits limits count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSetDepositsLimitsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetSetDepositsLimitsCountAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetSetDepositsLimitsCount'][0]
    ): PromiseInterface
    {
        $returnType = 'int';
        $request = $this->operationsGetSetDepositsLimitsCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetSetDepositsLimitsCount'
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSetDepositsLimitsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetSetDepositsLimitsCountRequest(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetSetDepositsLimitsCount'][0]
    ): Request
    {




        $resourcePath = '/v1/operations/set_deposits_limits/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetSmartRollupAddMessagesOps
     *
     * Get smart rollup add messages
     *
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int|null $limit Maximum number of items to return. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysSelectParameter|null $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupAddMessagesOps'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\SmartRollupAddMessagesOperation[]
     */
    public function operationsGetSmartRollupAddMessagesOps(
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupAddMessagesOps'][0]
    ): array
    {
        list($response) = $this->operationsGetSmartRollupAddMessagesOpsWithHttpInfo($id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetSmartRollupAddMessagesOpsWithHttpInfo
     *
     * Get smart rollup add messages
     *
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int|null $limit Maximum number of items to return. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysSelectParameter|null $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupAddMessagesOps'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\SmartRollupAddMessagesOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetSmartRollupAddMessagesOpsWithHttpInfo(
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupAddMessagesOps'][0]
    ): array
    {
        $request = $this->operationsGetSmartRollupAddMessagesOpsRequest($id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\SmartRollupAddMessagesOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\SmartRollupAddMessagesOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\SmartRollupAddMessagesOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\SmartRollupAddMessagesOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\SmartRollupAddMessagesOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetSmartRollupAddMessagesOpsAsync
     *
     * Get smart rollup add messages
     *
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int|null $limit Maximum number of items to return. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysSelectParameter|null $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupAddMessagesOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetSmartRollupAddMessagesOpsAsync(
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupAddMessagesOps'][0]
    ): PromiseInterface
    {
        return $this->operationsGetSmartRollupAddMessagesOpsAsyncWithHttpInfo($id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetSmartRollupAddMessagesOpsAsyncWithHttpInfo
     *
     * Get smart rollup add messages
     *
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int|null $limit Maximum number of items to return. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysSelectParameter|null $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupAddMessagesOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetSmartRollupAddMessagesOpsAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupAddMessagesOps'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\SmartRollupAddMessagesOperation[]';
        $request = $this->operationsGetSmartRollupAddMessagesOpsRequest($id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetSmartRollupAddMessagesOps'
     *
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int|null $limit Maximum number of items to return. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysSelectParameter|null $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupAddMessagesOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetSmartRollupAddMessagesOpsRequest(
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupAddMessagesOps'][0]
    ): Request
    {










        if ($limit !== null && $limit > 10000) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetSmartRollupAddMessagesOps, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetSmartRollupAddMessagesOps, must be bigger than or equal to 0.');
        }
        



        $resourcePath = '/v1/operations/sr_add_messages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            '\Tzkt\Model\Int64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hash,
            'hash', // param base name
            '\Tzkt\Model\OpHashParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $counter,
            'counter', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\TimestampParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            '\Tzkt\Model\OperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            '\Tzkt\Model\SortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            '\Tzkt\Model\OffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            '\Tzkt\Model\SelectionParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetSmartRollupAddMessagesOpsCount
     *
     * Get smart rollup add messages count
     *
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupAddMessagesOpsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return int
     */
    public function operationsGetSmartRollupAddMessagesOpsCount(
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupAddMessagesOpsCount'][0]
    ): int
    {
        list($response) = $this->operationsGetSmartRollupAddMessagesOpsCountWithHttpInfo($id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetSmartRollupAddMessagesOpsCountWithHttpInfo
     *
     * Get smart rollup add messages count
     *
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupAddMessagesOpsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetSmartRollupAddMessagesOpsCountWithHttpInfo(
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupAddMessagesOpsCount'][0]
    ): array
    {
        $request = $this->operationsGetSmartRollupAddMessagesOpsCountRequest($id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('int', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'int';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetSmartRollupAddMessagesOpsCountAsync
     *
     * Get smart rollup add messages count
     *
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupAddMessagesOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetSmartRollupAddMessagesOpsCountAsync(
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupAddMessagesOpsCount'][0]
    ): PromiseInterface
    {
        return $this->operationsGetSmartRollupAddMessagesOpsCountAsyncWithHttpInfo($id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetSmartRollupAddMessagesOpsCountAsyncWithHttpInfo
     *
     * Get smart rollup add messages count
     *
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupAddMessagesOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetSmartRollupAddMessagesOpsCountAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupAddMessagesOpsCount'][0]
    ): PromiseInterface
    {
        $returnType = 'int';
        $request = $this->operationsGetSmartRollupAddMessagesOpsCountRequest($id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetSmartRollupAddMessagesOpsCount'
     *
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupAddMessagesOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetSmartRollupAddMessagesOpsCountRequest(
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupAddMessagesOpsCount'][0]
    ): Request
    {









        $resourcePath = '/v1/operations/sr_add_messages/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            '\Tzkt\Model\Int64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hash,
            'hash', // param base name
            '\Tzkt\Model\OpHashParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $counter,
            'counter', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\TimestampParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            '\Tzkt\Model\OperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetSmartRollupCementOps
     *
     * Get smart rollup cement
     *
     * @param  \Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter|null $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int|null $limit Maximum number of items to return. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysSelectParameter|null $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupCementOps'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\SmartRollupCementOperation[]
     */
    public function operationsGetSmartRollupCementOps(
        ?\Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupCementOps'][0]
    ): array
    {
        list($response) = $this->operationsGetSmartRollupCementOpsWithHttpInfo($rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetSmartRollupCementOpsWithHttpInfo
     *
     * Get smart rollup cement
     *
     * @param  \Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter|null $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int|null $limit Maximum number of items to return. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysSelectParameter|null $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupCementOps'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\SmartRollupCementOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetSmartRollupCementOpsWithHttpInfo(
        ?\Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupCementOps'][0]
    ): array
    {
        $request = $this->operationsGetSmartRollupCementOpsRequest($rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\SmartRollupCementOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\SmartRollupCementOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\SmartRollupCementOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\SmartRollupCementOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\SmartRollupCementOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetSmartRollupCementOpsAsync
     *
     * Get smart rollup cement
     *
     * @param  \Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter|null $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int|null $limit Maximum number of items to return. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysSelectParameter|null $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupCementOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetSmartRollupCementOpsAsync(
        ?\Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupCementOps'][0]
    ): PromiseInterface
    {
        return $this->operationsGetSmartRollupCementOpsAsyncWithHttpInfo($rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetSmartRollupCementOpsAsyncWithHttpInfo
     *
     * Get smart rollup cement
     *
     * @param  \Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter|null $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int|null $limit Maximum number of items to return. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysSelectParameter|null $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupCementOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetSmartRollupCementOpsAsyncWithHttpInfo(
        ?\Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupCementOps'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\SmartRollupCementOperation[]';
        $request = $this->operationsGetSmartRollupCementOpsRequest($rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetSmartRollupCementOps'
     *
     * @param  \Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter|null $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int|null $limit Maximum number of items to return. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysSelectParameter|null $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupCementOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetSmartRollupCementOpsRequest(
        ?\Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupCementOps'][0]
    ): Request
    {











        if ($limit !== null && $limit > 10000) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetSmartRollupCementOps, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetSmartRollupCementOps, must be bigger than or equal to 0.');
        }
        



        $resourcePath = '/v1/operations/sr_cement';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rollup,
            'rollup', // param base name
            '\Tzkt\Model\SmartRollupParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            '\Tzkt\Model\Int64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hash,
            'hash', // param base name
            '\Tzkt\Model\OpHashParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $counter,
            'counter', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\TimestampParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            '\Tzkt\Model\OperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            '\Tzkt\Model\SortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            '\Tzkt\Model\OffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            '\Tzkt\Model\SelectionParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetSmartRollupCementOpsCount
     *
     * Get smart rollup cement count
     *
     * @param  \Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter|null $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupCementOpsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return int
     */
    public function operationsGetSmartRollupCementOpsCount(
        ?\Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupCementOpsCount'][0]
    ): int
    {
        list($response) = $this->operationsGetSmartRollupCementOpsCountWithHttpInfo($rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetSmartRollupCementOpsCountWithHttpInfo
     *
     * Get smart rollup cement count
     *
     * @param  \Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter|null $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupCementOpsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetSmartRollupCementOpsCountWithHttpInfo(
        ?\Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupCementOpsCount'][0]
    ): array
    {
        $request = $this->operationsGetSmartRollupCementOpsCountRequest($rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('int', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'int';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetSmartRollupCementOpsCountAsync
     *
     * Get smart rollup cement count
     *
     * @param  \Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter|null $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupCementOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetSmartRollupCementOpsCountAsync(
        ?\Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupCementOpsCount'][0]
    ): PromiseInterface
    {
        return $this->operationsGetSmartRollupCementOpsCountAsyncWithHttpInfo($rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetSmartRollupCementOpsCountAsyncWithHttpInfo
     *
     * Get smart rollup cement count
     *
     * @param  \Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter|null $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupCementOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetSmartRollupCementOpsCountAsyncWithHttpInfo(
        ?\Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupCementOpsCount'][0]
    ): PromiseInterface
    {
        $returnType = 'int';
        $request = $this->operationsGetSmartRollupCementOpsCountRequest($rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetSmartRollupCementOpsCount'
     *
     * @param  \Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter|null $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupCementOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetSmartRollupCementOpsCountRequest(
        ?\Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupCementOpsCount'][0]
    ): Request
    {










        $resourcePath = '/v1/operations/sr_cement/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rollup,
            'rollup', // param base name
            '\Tzkt\Model\SmartRollupParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            '\Tzkt\Model\Int64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hash,
            'hash', // param base name
            '\Tzkt\Model\OpHashParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $counter,
            'counter', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\TimestampParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            '\Tzkt\Model\OperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetSmartRollupExecuteOps
     *
     * Get smart rollup execute
     *
     * @param  \Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter|null $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int|null $limit Maximum number of items to return. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysSelectParameter|null $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupExecuteOps'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\SmartRollupExecuteOperation[]
     */
    public function operationsGetSmartRollupExecuteOps(
        ?\Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupExecuteOps'][0]
    ): array
    {
        list($response) = $this->operationsGetSmartRollupExecuteOpsWithHttpInfo($rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetSmartRollupExecuteOpsWithHttpInfo
     *
     * Get smart rollup execute
     *
     * @param  \Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter|null $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int|null $limit Maximum number of items to return. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysSelectParameter|null $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupExecuteOps'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\SmartRollupExecuteOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetSmartRollupExecuteOpsWithHttpInfo(
        ?\Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupExecuteOps'][0]
    ): array
    {
        $request = $this->operationsGetSmartRollupExecuteOpsRequest($rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\SmartRollupExecuteOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\SmartRollupExecuteOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\SmartRollupExecuteOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\SmartRollupExecuteOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\SmartRollupExecuteOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetSmartRollupExecuteOpsAsync
     *
     * Get smart rollup execute
     *
     * @param  \Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter|null $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int|null $limit Maximum number of items to return. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysSelectParameter|null $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupExecuteOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetSmartRollupExecuteOpsAsync(
        ?\Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupExecuteOps'][0]
    ): PromiseInterface
    {
        return $this->operationsGetSmartRollupExecuteOpsAsyncWithHttpInfo($rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetSmartRollupExecuteOpsAsyncWithHttpInfo
     *
     * Get smart rollup execute
     *
     * @param  \Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter|null $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int|null $limit Maximum number of items to return. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysSelectParameter|null $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupExecuteOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetSmartRollupExecuteOpsAsyncWithHttpInfo(
        ?\Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupExecuteOps'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\SmartRollupExecuteOperation[]';
        $request = $this->operationsGetSmartRollupExecuteOpsRequest($rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetSmartRollupExecuteOps'
     *
     * @param  \Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter|null $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int|null $limit Maximum number of items to return. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysSelectParameter|null $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupExecuteOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetSmartRollupExecuteOpsRequest(
        ?\Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupExecuteOps'][0]
    ): Request
    {











        if ($limit !== null && $limit > 10000) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetSmartRollupExecuteOps, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetSmartRollupExecuteOps, must be bigger than or equal to 0.');
        }
        



        $resourcePath = '/v1/operations/sr_execute';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rollup,
            'rollup', // param base name
            '\Tzkt\Model\SmartRollupParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            '\Tzkt\Model\Int64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hash,
            'hash', // param base name
            '\Tzkt\Model\OpHashParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $counter,
            'counter', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\TimestampParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            '\Tzkt\Model\OperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            '\Tzkt\Model\SortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            '\Tzkt\Model\OffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            '\Tzkt\Model\SelectionParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetSmartRollupExecuteOpsCount
     *
     * Get smart rollup execute count
     *
     * @param  \Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter|null $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupExecuteOpsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return int
     */
    public function operationsGetSmartRollupExecuteOpsCount(
        ?\Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupExecuteOpsCount'][0]
    ): int
    {
        list($response) = $this->operationsGetSmartRollupExecuteOpsCountWithHttpInfo($rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetSmartRollupExecuteOpsCountWithHttpInfo
     *
     * Get smart rollup execute count
     *
     * @param  \Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter|null $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupExecuteOpsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetSmartRollupExecuteOpsCountWithHttpInfo(
        ?\Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupExecuteOpsCount'][0]
    ): array
    {
        $request = $this->operationsGetSmartRollupExecuteOpsCountRequest($rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('int', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'int';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetSmartRollupExecuteOpsCountAsync
     *
     * Get smart rollup execute count
     *
     * @param  \Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter|null $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupExecuteOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetSmartRollupExecuteOpsCountAsync(
        ?\Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupExecuteOpsCount'][0]
    ): PromiseInterface
    {
        return $this->operationsGetSmartRollupExecuteOpsCountAsyncWithHttpInfo($rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetSmartRollupExecuteOpsCountAsyncWithHttpInfo
     *
     * Get smart rollup execute count
     *
     * @param  \Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter|null $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupExecuteOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetSmartRollupExecuteOpsCountAsyncWithHttpInfo(
        ?\Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupExecuteOpsCount'][0]
    ): PromiseInterface
    {
        $returnType = 'int';
        $request = $this->operationsGetSmartRollupExecuteOpsCountRequest($rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetSmartRollupExecuteOpsCount'
     *
     * @param  \Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter|null $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupExecuteOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetSmartRollupExecuteOpsCountRequest(
        ?\Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupExecuteOpsCount'][0]
    ): Request
    {










        $resourcePath = '/v1/operations/sr_execute/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rollup,
            'rollup', // param base name
            '\Tzkt\Model\SmartRollupParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            '\Tzkt\Model\Int64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hash,
            'hash', // param base name
            '\Tzkt\Model\OpHashParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $counter,
            'counter', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\TimestampParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            '\Tzkt\Model\OperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetSmartRollupOriginateOps
     *
     * Get smart rollup originate
     *
     * @param  \Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter|null $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int|null $limit Maximum number of items to return. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysSelectParameter|null $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the parameter type value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupOriginateOps'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\SmartRollupOriginateOperation[]
     */
    public function operationsGetSmartRollupOriginateOps(
        ?\Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupOriginateOps'][0]
    ): array
    {
        list($response) = $this->operationsGetSmartRollupOriginateOpsWithHttpInfo($rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $micheline, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetSmartRollupOriginateOpsWithHttpInfo
     *
     * Get smart rollup originate
     *
     * @param  \Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter|null $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int|null $limit Maximum number of items to return. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysSelectParameter|null $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the parameter type value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupOriginateOps'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\SmartRollupOriginateOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetSmartRollupOriginateOpsWithHttpInfo(
        ?\Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupOriginateOps'][0]
    ): array
    {
        $request = $this->operationsGetSmartRollupOriginateOpsRequest($rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $micheline, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\SmartRollupOriginateOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\SmartRollupOriginateOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\SmartRollupOriginateOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\SmartRollupOriginateOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\SmartRollupOriginateOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetSmartRollupOriginateOpsAsync
     *
     * Get smart rollup originate
     *
     * @param  \Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter|null $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int|null $limit Maximum number of items to return. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysSelectParameter|null $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the parameter type value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupOriginateOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetSmartRollupOriginateOpsAsync(
        ?\Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupOriginateOps'][0]
    ): PromiseInterface
    {
        return $this->operationsGetSmartRollupOriginateOpsAsyncWithHttpInfo($rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $micheline, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetSmartRollupOriginateOpsAsyncWithHttpInfo
     *
     * Get smart rollup originate
     *
     * @param  \Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter|null $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int|null $limit Maximum number of items to return. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysSelectParameter|null $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the parameter type value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupOriginateOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetSmartRollupOriginateOpsAsyncWithHttpInfo(
        ?\Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupOriginateOps'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\SmartRollupOriginateOperation[]';
        $request = $this->operationsGetSmartRollupOriginateOpsRequest($rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $micheline, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetSmartRollupOriginateOps'
     *
     * @param  \Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter|null $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int|null $limit Maximum number of items to return. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysSelectParameter|null $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the parameter type value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupOriginateOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetSmartRollupOriginateOpsRequest(
        ?\Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupOriginateOps'][0]
    ): Request
    {











        if ($limit !== null && $limit > 10000) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetSmartRollupOriginateOps, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetSmartRollupOriginateOps, must be bigger than or equal to 0.');
        }
        




        $resourcePath = '/v1/operations/sr_originate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rollup,
            'rollup', // param base name
            '\Tzkt\Model\SmartRollupParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            '\Tzkt\Model\Int64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hash,
            'hash', // param base name
            '\Tzkt\Model\OpHashParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $counter,
            'counter', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\TimestampParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            '\Tzkt\Model\OperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            '\Tzkt\Model\SortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            '\Tzkt\Model\OffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            '\Tzkt\Model\SelectionParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $micheline,
            'micheline', // param base name
            '\Tzkt\Model\MichelineFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetSmartRollupOriginateOpsCount
     *
     * Get smart rollup originate count
     *
     * @param  \Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter|null $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupOriginateOpsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return int
     */
    public function operationsGetSmartRollupOriginateOpsCount(
        ?\Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupOriginateOpsCount'][0]
    ): int
    {
        list($response) = $this->operationsGetSmartRollupOriginateOpsCountWithHttpInfo($rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetSmartRollupOriginateOpsCountWithHttpInfo
     *
     * Get smart rollup originate count
     *
     * @param  \Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter|null $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupOriginateOpsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetSmartRollupOriginateOpsCountWithHttpInfo(
        ?\Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupOriginateOpsCount'][0]
    ): array
    {
        $request = $this->operationsGetSmartRollupOriginateOpsCountRequest($rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('int', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'int';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetSmartRollupOriginateOpsCountAsync
     *
     * Get smart rollup originate count
     *
     * @param  \Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter|null $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupOriginateOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetSmartRollupOriginateOpsCountAsync(
        ?\Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupOriginateOpsCount'][0]
    ): PromiseInterface
    {
        return $this->operationsGetSmartRollupOriginateOpsCountAsyncWithHttpInfo($rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetSmartRollupOriginateOpsCountAsyncWithHttpInfo
     *
     * Get smart rollup originate count
     *
     * @param  \Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter|null $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupOriginateOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetSmartRollupOriginateOpsCountAsyncWithHttpInfo(
        ?\Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupOriginateOpsCount'][0]
    ): PromiseInterface
    {
        $returnType = 'int';
        $request = $this->operationsGetSmartRollupOriginateOpsCountRequest($rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetSmartRollupOriginateOpsCount'
     *
     * @param  \Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter|null $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupOriginateOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetSmartRollupOriginateOpsCountRequest(
        ?\Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupOriginateOpsCount'][0]
    ): Request
    {










        $resourcePath = '/v1/operations/sr_originate/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rollup,
            'rollup', // param base name
            '\Tzkt\Model\SmartRollupParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            '\Tzkt\Model\Int64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hash,
            'hash', // param base name
            '\Tzkt\Model\OpHashParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $counter,
            'counter', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\TimestampParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            '\Tzkt\Model\OperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetSmartRollupPublishOps
     *
     * Get smart rollup publish
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $commitment_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupPublishOpsCommitmentHashParameter|null $commitment_hash Filter by commitment hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter|null $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int|null $limit Maximum number of items to return. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysSelectParameter|null $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupPublishOps'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\SmartRollupPublishOperation[]
     */
    public function operationsGetSmartRollupPublishOps(
        ?\Tzkt\Model\AccountsGetIdParameter $commitment_id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupPublishOpsCommitmentHashParameter $commitment_hash = null,
        ?\Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupPublishOps'][0]
    ): array
    {
        list($response) = $this->operationsGetSmartRollupPublishOpsWithHttpInfo($commitment_id, $commitment_hash, $rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetSmartRollupPublishOpsWithHttpInfo
     *
     * Get smart rollup publish
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $commitment_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupPublishOpsCommitmentHashParameter|null $commitment_hash Filter by commitment hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter|null $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int|null $limit Maximum number of items to return. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysSelectParameter|null $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupPublishOps'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\SmartRollupPublishOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetSmartRollupPublishOpsWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $commitment_id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupPublishOpsCommitmentHashParameter $commitment_hash = null,
        ?\Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupPublishOps'][0]
    ): array
    {
        $request = $this->operationsGetSmartRollupPublishOpsRequest($commitment_id, $commitment_hash, $rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\SmartRollupPublishOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\SmartRollupPublishOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\SmartRollupPublishOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\SmartRollupPublishOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\SmartRollupPublishOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetSmartRollupPublishOpsAsync
     *
     * Get smart rollup publish
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $commitment_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupPublishOpsCommitmentHashParameter|null $commitment_hash Filter by commitment hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter|null $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int|null $limit Maximum number of items to return. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysSelectParameter|null $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupPublishOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetSmartRollupPublishOpsAsync(
        ?\Tzkt\Model\AccountsGetIdParameter $commitment_id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupPublishOpsCommitmentHashParameter $commitment_hash = null,
        ?\Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupPublishOps'][0]
    ): PromiseInterface
    {
        return $this->operationsGetSmartRollupPublishOpsAsyncWithHttpInfo($commitment_id, $commitment_hash, $rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetSmartRollupPublishOpsAsyncWithHttpInfo
     *
     * Get smart rollup publish
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $commitment_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupPublishOpsCommitmentHashParameter|null $commitment_hash Filter by commitment hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter|null $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int|null $limit Maximum number of items to return. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysSelectParameter|null $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupPublishOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetSmartRollupPublishOpsAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $commitment_id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupPublishOpsCommitmentHashParameter $commitment_hash = null,
        ?\Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupPublishOps'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\SmartRollupPublishOperation[]';
        $request = $this->operationsGetSmartRollupPublishOpsRequest($commitment_id, $commitment_hash, $rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetSmartRollupPublishOps'
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $commitment_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupPublishOpsCommitmentHashParameter|null $commitment_hash Filter by commitment hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter|null $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int|null $limit Maximum number of items to return. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysSelectParameter|null $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupPublishOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetSmartRollupPublishOpsRequest(
        ?\Tzkt\Model\AccountsGetIdParameter $commitment_id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupPublishOpsCommitmentHashParameter $commitment_hash = null,
        ?\Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupPublishOps'][0]
    ): Request
    {













        if ($limit !== null && $limit > 10000) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetSmartRollupPublishOps, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetSmartRollupPublishOps, must be bigger than or equal to 0.');
        }
        



        $resourcePath = '/v1/operations/sr_publish';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $commitment_id,
            'commitment.id', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $commitment_hash,
            'commitment.hash', // param base name
            '\Tzkt\Model\Src1HashParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rollup,
            'rollup', // param base name
            '\Tzkt\Model\SmartRollupParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            '\Tzkt\Model\Int64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hash,
            'hash', // param base name
            '\Tzkt\Model\OpHashParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $counter,
            'counter', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\TimestampParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            '\Tzkt\Model\OperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            '\Tzkt\Model\SortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            '\Tzkt\Model\OffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            '\Tzkt\Model\SelectionParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetSmartRollupPublishOpsCount
     *
     * Get smart rollup publish count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $commitment_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupPublishOpsCommitmentHashParameter|null $commitment_hash Filter by commitment hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter|null $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupPublishOpsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return int
     */
    public function operationsGetSmartRollupPublishOpsCount(
        ?\Tzkt\Model\AccountsGetIdParameter $commitment_id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupPublishOpsCommitmentHashParameter $commitment_hash = null,
        ?\Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupPublishOpsCount'][0]
    ): int
    {
        list($response) = $this->operationsGetSmartRollupPublishOpsCountWithHttpInfo($commitment_id, $commitment_hash, $rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetSmartRollupPublishOpsCountWithHttpInfo
     *
     * Get smart rollup publish count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $commitment_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupPublishOpsCommitmentHashParameter|null $commitment_hash Filter by commitment hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter|null $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupPublishOpsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetSmartRollupPublishOpsCountWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $commitment_id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupPublishOpsCommitmentHashParameter $commitment_hash = null,
        ?\Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupPublishOpsCount'][0]
    ): array
    {
        $request = $this->operationsGetSmartRollupPublishOpsCountRequest($commitment_id, $commitment_hash, $rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('int', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'int';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetSmartRollupPublishOpsCountAsync
     *
     * Get smart rollup publish count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $commitment_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupPublishOpsCommitmentHashParameter|null $commitment_hash Filter by commitment hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter|null $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupPublishOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetSmartRollupPublishOpsCountAsync(
        ?\Tzkt\Model\AccountsGetIdParameter $commitment_id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupPublishOpsCommitmentHashParameter $commitment_hash = null,
        ?\Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupPublishOpsCount'][0]
    ): PromiseInterface
    {
        return $this->operationsGetSmartRollupPublishOpsCountAsyncWithHttpInfo($commitment_id, $commitment_hash, $rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetSmartRollupPublishOpsCountAsyncWithHttpInfo
     *
     * Get smart rollup publish count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $commitment_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupPublishOpsCommitmentHashParameter|null $commitment_hash Filter by commitment hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter|null $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupPublishOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetSmartRollupPublishOpsCountAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $commitment_id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupPublishOpsCommitmentHashParameter $commitment_hash = null,
        ?\Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupPublishOpsCount'][0]
    ): PromiseInterface
    {
        $returnType = 'int';
        $request = $this->operationsGetSmartRollupPublishOpsCountRequest($commitment_id, $commitment_hash, $rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetSmartRollupPublishOpsCount'
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $commitment_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupPublishOpsCommitmentHashParameter|null $commitment_hash Filter by commitment hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter|null $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupPublishOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetSmartRollupPublishOpsCountRequest(
        ?\Tzkt\Model\AccountsGetIdParameter $commitment_id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupPublishOpsCommitmentHashParameter $commitment_hash = null,
        ?\Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupPublishOpsCount'][0]
    ): Request
    {












        $resourcePath = '/v1/operations/sr_publish/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $commitment_id,
            'commitment.id', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $commitment_hash,
            'commitment.hash', // param base name
            '\Tzkt\Model\Src1HashParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rollup,
            'rollup', // param base name
            '\Tzkt\Model\SmartRollupParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            '\Tzkt\Model\Int64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hash,
            'hash', // param base name
            '\Tzkt\Model\OpHashParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $counter,
            'counter', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\TimestampParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            '\Tzkt\Model\OperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetSmartRollupRecoverBondOps
     *
     * Get smart rollup recover bond
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filter by any of the specified fields (&#x60;sender&#x60; or &#x60;staker&#x60;). Example: &#x60;anyof.sender.staker&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;staker&#x60; is equal to the specified value. This parameter is useful when you need to get all operations somehow related to the account in a single request.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $staker Filter by staker address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter|null $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int|null $limit Maximum number of items to return. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysSelectParameter|null $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupRecoverBondOps'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\SmartRollupRecoverBondOperation[]
     */
    public function operationsGetSmartRollupRecoverBondOps(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $staker = null,
        ?\Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupRecoverBondOps'][0]
    ): array
    {
        list($response) = $this->operationsGetSmartRollupRecoverBondOpsWithHttpInfo($anyof, $staker, $rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetSmartRollupRecoverBondOpsWithHttpInfo
     *
     * Get smart rollup recover bond
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filter by any of the specified fields (&#x60;sender&#x60; or &#x60;staker&#x60;). Example: &#x60;anyof.sender.staker&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;staker&#x60; is equal to the specified value. This parameter is useful when you need to get all operations somehow related to the account in a single request.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $staker Filter by staker address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter|null $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int|null $limit Maximum number of items to return. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysSelectParameter|null $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupRecoverBondOps'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\SmartRollupRecoverBondOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetSmartRollupRecoverBondOpsWithHttpInfo(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $staker = null,
        ?\Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupRecoverBondOps'][0]
    ): array
    {
        $request = $this->operationsGetSmartRollupRecoverBondOpsRequest($anyof, $staker, $rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\SmartRollupRecoverBondOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\SmartRollupRecoverBondOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\SmartRollupRecoverBondOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\SmartRollupRecoverBondOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\SmartRollupRecoverBondOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetSmartRollupRecoverBondOpsAsync
     *
     * Get smart rollup recover bond
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filter by any of the specified fields (&#x60;sender&#x60; or &#x60;staker&#x60;). Example: &#x60;anyof.sender.staker&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;staker&#x60; is equal to the specified value. This parameter is useful when you need to get all operations somehow related to the account in a single request.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $staker Filter by staker address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter|null $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int|null $limit Maximum number of items to return. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysSelectParameter|null $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupRecoverBondOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetSmartRollupRecoverBondOpsAsync(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $staker = null,
        ?\Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupRecoverBondOps'][0]
    ): PromiseInterface
    {
        return $this->operationsGetSmartRollupRecoverBondOpsAsyncWithHttpInfo($anyof, $staker, $rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetSmartRollupRecoverBondOpsAsyncWithHttpInfo
     *
     * Get smart rollup recover bond
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filter by any of the specified fields (&#x60;sender&#x60; or &#x60;staker&#x60;). Example: &#x60;anyof.sender.staker&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;staker&#x60; is equal to the specified value. This parameter is useful when you need to get all operations somehow related to the account in a single request.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $staker Filter by staker address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter|null $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int|null $limit Maximum number of items to return. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysSelectParameter|null $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupRecoverBondOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetSmartRollupRecoverBondOpsAsyncWithHttpInfo(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $staker = null,
        ?\Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupRecoverBondOps'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\SmartRollupRecoverBondOperation[]';
        $request = $this->operationsGetSmartRollupRecoverBondOpsRequest($anyof, $staker, $rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetSmartRollupRecoverBondOps'
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filter by any of the specified fields (&#x60;sender&#x60; or &#x60;staker&#x60;). Example: &#x60;anyof.sender.staker&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;staker&#x60; is equal to the specified value. This parameter is useful when you need to get all operations somehow related to the account in a single request.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $staker Filter by staker address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter|null $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int|null $limit Maximum number of items to return. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysSelectParameter|null $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupRecoverBondOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetSmartRollupRecoverBondOpsRequest(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $staker = null,
        ?\Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupRecoverBondOps'][0]
    ): Request
    {













        if ($limit !== null && $limit > 10000) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetSmartRollupRecoverBondOps, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetSmartRollupRecoverBondOps, must be bigger than or equal to 0.');
        }
        



        $resourcePath = '/v1/operations/sr_recover_bond';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $anyof,
            'anyof', // param base name
            '\Tzkt\Model\AnyOfParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $staker,
            'staker', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rollup,
            'rollup', // param base name
            '\Tzkt\Model\SmartRollupParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            '\Tzkt\Model\Int64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hash,
            'hash', // param base name
            '\Tzkt\Model\OpHashParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $counter,
            'counter', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\TimestampParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            '\Tzkt\Model\OperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            '\Tzkt\Model\SortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            '\Tzkt\Model\OffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            '\Tzkt\Model\SelectionParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetSmartRollupRecoverBondOpsCount
     *
     * Get smart rollup recover bond count
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filter by any of the specified fields (&#x60;sender&#x60; or &#x60;staker&#x60;). Example: &#x60;anyof.sender.staker&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;staker&#x60; is equal to the specified value. This parameter is useful when you need to get all operations somehow related to the account in a single request.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $staker Filter by staker address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter|null $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupRecoverBondOpsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return int
     */
    public function operationsGetSmartRollupRecoverBondOpsCount(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $staker = null,
        ?\Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupRecoverBondOpsCount'][0]
    ): int
    {
        list($response) = $this->operationsGetSmartRollupRecoverBondOpsCountWithHttpInfo($anyof, $staker, $rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetSmartRollupRecoverBondOpsCountWithHttpInfo
     *
     * Get smart rollup recover bond count
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filter by any of the specified fields (&#x60;sender&#x60; or &#x60;staker&#x60;). Example: &#x60;anyof.sender.staker&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;staker&#x60; is equal to the specified value. This parameter is useful when you need to get all operations somehow related to the account in a single request.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $staker Filter by staker address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter|null $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupRecoverBondOpsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetSmartRollupRecoverBondOpsCountWithHttpInfo(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $staker = null,
        ?\Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupRecoverBondOpsCount'][0]
    ): array
    {
        $request = $this->operationsGetSmartRollupRecoverBondOpsCountRequest($anyof, $staker, $rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('int', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'int';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetSmartRollupRecoverBondOpsCountAsync
     *
     * Get smart rollup recover bond count
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filter by any of the specified fields (&#x60;sender&#x60; or &#x60;staker&#x60;). Example: &#x60;anyof.sender.staker&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;staker&#x60; is equal to the specified value. This parameter is useful when you need to get all operations somehow related to the account in a single request.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $staker Filter by staker address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter|null $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupRecoverBondOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetSmartRollupRecoverBondOpsCountAsync(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $staker = null,
        ?\Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupRecoverBondOpsCount'][0]
    ): PromiseInterface
    {
        return $this->operationsGetSmartRollupRecoverBondOpsCountAsyncWithHttpInfo($anyof, $staker, $rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetSmartRollupRecoverBondOpsCountAsyncWithHttpInfo
     *
     * Get smart rollup recover bond count
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filter by any of the specified fields (&#x60;sender&#x60; or &#x60;staker&#x60;). Example: &#x60;anyof.sender.staker&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;staker&#x60; is equal to the specified value. This parameter is useful when you need to get all operations somehow related to the account in a single request.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $staker Filter by staker address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter|null $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupRecoverBondOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetSmartRollupRecoverBondOpsCountAsyncWithHttpInfo(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $staker = null,
        ?\Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupRecoverBondOpsCount'][0]
    ): PromiseInterface
    {
        $returnType = 'int';
        $request = $this->operationsGetSmartRollupRecoverBondOpsCountRequest($anyof, $staker, $rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetSmartRollupRecoverBondOpsCount'
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filter by any of the specified fields (&#x60;sender&#x60; or &#x60;staker&#x60;). Example: &#x60;anyof.sender.staker&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;staker&#x60; is equal to the specified value. This parameter is useful when you need to get all operations somehow related to the account in a single request.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $staker Filter by staker address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter|null $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupRecoverBondOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetSmartRollupRecoverBondOpsCountRequest(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $staker = null,
        ?\Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupRecoverBondOpsCount'][0]
    ): Request
    {












        $resourcePath = '/v1/operations/sr_recover_bond/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $anyof,
            'anyof', // param base name
            '\Tzkt\Model\AnyOfParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $staker,
            'staker', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rollup,
            'rollup', // param base name
            '\Tzkt\Model\SmartRollupParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            '\Tzkt\Model\Int64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hash,
            'hash', // param base name
            '\Tzkt\Model\OpHashParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $counter,
            'counter', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\TimestampParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            '\Tzkt\Model\OperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetSmartRollupRefuteOps
     *
     * Get smart rollup refute
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filter by any of the specified fields (&#x60;sender&#x60;, &#x60;initiator&#x60;, or &#x60;opponent&#x60;). Example: &#x60;anyof.initiator.opponent&#x3D;tz1...&#x60; will return operations where &#x60;initiator&#x60; OR &#x60;opponent&#x60; is equal to the specified value. This parameter is useful when you need to get all operations somehow related to the account in a single request.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $game_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $game_initiator Filter by initiator (who found a wrong commitment and started the refutation game).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $game_initiator_commitment_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupPublishOpsCommitmentHashParameter|null $game_initiator_commitment_hash Filter by commitment hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $game_opponent Filter by opponent (who was accused in publishing a wrong commitment).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $game_opponent_commitment_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupPublishOpsCommitmentHashParameter|null $game_opponent_commitment_hash Filter by commitment hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupRefuteOpsMoveParameter|null $move Filter by refutation game move (&#x60;start&#x60;, &#x60;dissection&#x60;, &#x60;proof&#x60;, or &#x60;timeout&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupRefuteOpsGameStatusParameter|null $game_status Filter by refutation game status (&#x60;none&#x60;, &#x60;ongoing&#x60;, &#x60;loser&#x60;, or &#x60;draw&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter|null $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int|null $limit Maximum number of items to return. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysSelectParameter|null $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupRefuteOps'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\SmartRollupRefuteOperation[]
     */
    public function operationsGetSmartRollupRefuteOps(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetIdParameter $game_id = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $game_initiator = null,
        ?\Tzkt\Model\AccountsGetIdParameter $game_initiator_commitment_id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupPublishOpsCommitmentHashParameter $game_initiator_commitment_hash = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $game_opponent = null,
        ?\Tzkt\Model\AccountsGetIdParameter $game_opponent_commitment_id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupPublishOpsCommitmentHashParameter $game_opponent_commitment_hash = null,
        ?\Tzkt\Model\OperationsGetSmartRollupRefuteOpsMoveParameter $move = null,
        ?\Tzkt\Model\OperationsGetSmartRollupRefuteOpsGameStatusParameter $game_status = null,
        ?\Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupRefuteOps'][0]
    ): array
    {
        list($response) = $this->operationsGetSmartRollupRefuteOpsWithHttpInfo($anyof, $game_id, $game_initiator, $game_initiator_commitment_id, $game_initiator_commitment_hash, $game_opponent, $game_opponent_commitment_id, $game_opponent_commitment_hash, $move, $game_status, $rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetSmartRollupRefuteOpsWithHttpInfo
     *
     * Get smart rollup refute
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filter by any of the specified fields (&#x60;sender&#x60;, &#x60;initiator&#x60;, or &#x60;opponent&#x60;). Example: &#x60;anyof.initiator.opponent&#x3D;tz1...&#x60; will return operations where &#x60;initiator&#x60; OR &#x60;opponent&#x60; is equal to the specified value. This parameter is useful when you need to get all operations somehow related to the account in a single request.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $game_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $game_initiator Filter by initiator (who found a wrong commitment and started the refutation game).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $game_initiator_commitment_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupPublishOpsCommitmentHashParameter|null $game_initiator_commitment_hash Filter by commitment hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $game_opponent Filter by opponent (who was accused in publishing a wrong commitment).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $game_opponent_commitment_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupPublishOpsCommitmentHashParameter|null $game_opponent_commitment_hash Filter by commitment hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupRefuteOpsMoveParameter|null $move Filter by refutation game move (&#x60;start&#x60;, &#x60;dissection&#x60;, &#x60;proof&#x60;, or &#x60;timeout&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupRefuteOpsGameStatusParameter|null $game_status Filter by refutation game status (&#x60;none&#x60;, &#x60;ongoing&#x60;, &#x60;loser&#x60;, or &#x60;draw&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter|null $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int|null $limit Maximum number of items to return. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysSelectParameter|null $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupRefuteOps'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\SmartRollupRefuteOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetSmartRollupRefuteOpsWithHttpInfo(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetIdParameter $game_id = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $game_initiator = null,
        ?\Tzkt\Model\AccountsGetIdParameter $game_initiator_commitment_id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupPublishOpsCommitmentHashParameter $game_initiator_commitment_hash = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $game_opponent = null,
        ?\Tzkt\Model\AccountsGetIdParameter $game_opponent_commitment_id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupPublishOpsCommitmentHashParameter $game_opponent_commitment_hash = null,
        ?\Tzkt\Model\OperationsGetSmartRollupRefuteOpsMoveParameter $move = null,
        ?\Tzkt\Model\OperationsGetSmartRollupRefuteOpsGameStatusParameter $game_status = null,
        ?\Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupRefuteOps'][0]
    ): array
    {
        $request = $this->operationsGetSmartRollupRefuteOpsRequest($anyof, $game_id, $game_initiator, $game_initiator_commitment_id, $game_initiator_commitment_hash, $game_opponent, $game_opponent_commitment_id, $game_opponent_commitment_hash, $move, $game_status, $rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\SmartRollupRefuteOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\SmartRollupRefuteOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\SmartRollupRefuteOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\SmartRollupRefuteOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\SmartRollupRefuteOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetSmartRollupRefuteOpsAsync
     *
     * Get smart rollup refute
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filter by any of the specified fields (&#x60;sender&#x60;, &#x60;initiator&#x60;, or &#x60;opponent&#x60;). Example: &#x60;anyof.initiator.opponent&#x3D;tz1...&#x60; will return operations where &#x60;initiator&#x60; OR &#x60;opponent&#x60; is equal to the specified value. This parameter is useful when you need to get all operations somehow related to the account in a single request.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $game_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $game_initiator Filter by initiator (who found a wrong commitment and started the refutation game).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $game_initiator_commitment_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupPublishOpsCommitmentHashParameter|null $game_initiator_commitment_hash Filter by commitment hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $game_opponent Filter by opponent (who was accused in publishing a wrong commitment).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $game_opponent_commitment_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupPublishOpsCommitmentHashParameter|null $game_opponent_commitment_hash Filter by commitment hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupRefuteOpsMoveParameter|null $move Filter by refutation game move (&#x60;start&#x60;, &#x60;dissection&#x60;, &#x60;proof&#x60;, or &#x60;timeout&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupRefuteOpsGameStatusParameter|null $game_status Filter by refutation game status (&#x60;none&#x60;, &#x60;ongoing&#x60;, &#x60;loser&#x60;, or &#x60;draw&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter|null $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int|null $limit Maximum number of items to return. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysSelectParameter|null $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupRefuteOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetSmartRollupRefuteOpsAsync(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetIdParameter $game_id = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $game_initiator = null,
        ?\Tzkt\Model\AccountsGetIdParameter $game_initiator_commitment_id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupPublishOpsCommitmentHashParameter $game_initiator_commitment_hash = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $game_opponent = null,
        ?\Tzkt\Model\AccountsGetIdParameter $game_opponent_commitment_id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupPublishOpsCommitmentHashParameter $game_opponent_commitment_hash = null,
        ?\Tzkt\Model\OperationsGetSmartRollupRefuteOpsMoveParameter $move = null,
        ?\Tzkt\Model\OperationsGetSmartRollupRefuteOpsGameStatusParameter $game_status = null,
        ?\Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupRefuteOps'][0]
    ): PromiseInterface
    {
        return $this->operationsGetSmartRollupRefuteOpsAsyncWithHttpInfo($anyof, $game_id, $game_initiator, $game_initiator_commitment_id, $game_initiator_commitment_hash, $game_opponent, $game_opponent_commitment_id, $game_opponent_commitment_hash, $move, $game_status, $rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetSmartRollupRefuteOpsAsyncWithHttpInfo
     *
     * Get smart rollup refute
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filter by any of the specified fields (&#x60;sender&#x60;, &#x60;initiator&#x60;, or &#x60;opponent&#x60;). Example: &#x60;anyof.initiator.opponent&#x3D;tz1...&#x60; will return operations where &#x60;initiator&#x60; OR &#x60;opponent&#x60; is equal to the specified value. This parameter is useful when you need to get all operations somehow related to the account in a single request.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $game_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $game_initiator Filter by initiator (who found a wrong commitment and started the refutation game).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $game_initiator_commitment_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupPublishOpsCommitmentHashParameter|null $game_initiator_commitment_hash Filter by commitment hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $game_opponent Filter by opponent (who was accused in publishing a wrong commitment).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $game_opponent_commitment_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupPublishOpsCommitmentHashParameter|null $game_opponent_commitment_hash Filter by commitment hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupRefuteOpsMoveParameter|null $move Filter by refutation game move (&#x60;start&#x60;, &#x60;dissection&#x60;, &#x60;proof&#x60;, or &#x60;timeout&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupRefuteOpsGameStatusParameter|null $game_status Filter by refutation game status (&#x60;none&#x60;, &#x60;ongoing&#x60;, &#x60;loser&#x60;, or &#x60;draw&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter|null $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int|null $limit Maximum number of items to return. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysSelectParameter|null $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupRefuteOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetSmartRollupRefuteOpsAsyncWithHttpInfo(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetIdParameter $game_id = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $game_initiator = null,
        ?\Tzkt\Model\AccountsGetIdParameter $game_initiator_commitment_id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupPublishOpsCommitmentHashParameter $game_initiator_commitment_hash = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $game_opponent = null,
        ?\Tzkt\Model\AccountsGetIdParameter $game_opponent_commitment_id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupPublishOpsCommitmentHashParameter $game_opponent_commitment_hash = null,
        ?\Tzkt\Model\OperationsGetSmartRollupRefuteOpsMoveParameter $move = null,
        ?\Tzkt\Model\OperationsGetSmartRollupRefuteOpsGameStatusParameter $game_status = null,
        ?\Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupRefuteOps'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\SmartRollupRefuteOperation[]';
        $request = $this->operationsGetSmartRollupRefuteOpsRequest($anyof, $game_id, $game_initiator, $game_initiator_commitment_id, $game_initiator_commitment_hash, $game_opponent, $game_opponent_commitment_id, $game_opponent_commitment_hash, $move, $game_status, $rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetSmartRollupRefuteOps'
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filter by any of the specified fields (&#x60;sender&#x60;, &#x60;initiator&#x60;, or &#x60;opponent&#x60;). Example: &#x60;anyof.initiator.opponent&#x3D;tz1...&#x60; will return operations where &#x60;initiator&#x60; OR &#x60;opponent&#x60; is equal to the specified value. This parameter is useful when you need to get all operations somehow related to the account in a single request.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $game_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $game_initiator Filter by initiator (who found a wrong commitment and started the refutation game).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $game_initiator_commitment_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupPublishOpsCommitmentHashParameter|null $game_initiator_commitment_hash Filter by commitment hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $game_opponent Filter by opponent (who was accused in publishing a wrong commitment).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $game_opponent_commitment_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupPublishOpsCommitmentHashParameter|null $game_opponent_commitment_hash Filter by commitment hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupRefuteOpsMoveParameter|null $move Filter by refutation game move (&#x60;start&#x60;, &#x60;dissection&#x60;, &#x60;proof&#x60;, or &#x60;timeout&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupRefuteOpsGameStatusParameter|null $game_status Filter by refutation game status (&#x60;none&#x60;, &#x60;ongoing&#x60;, &#x60;loser&#x60;, or &#x60;draw&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter|null $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int|null $limit Maximum number of items to return. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysSelectParameter|null $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupRefuteOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetSmartRollupRefuteOpsRequest(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetIdParameter $game_id = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $game_initiator = null,
        ?\Tzkt\Model\AccountsGetIdParameter $game_initiator_commitment_id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupPublishOpsCommitmentHashParameter $game_initiator_commitment_hash = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $game_opponent = null,
        ?\Tzkt\Model\AccountsGetIdParameter $game_opponent_commitment_id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupPublishOpsCommitmentHashParameter $game_opponent_commitment_hash = null,
        ?\Tzkt\Model\OperationsGetSmartRollupRefuteOpsMoveParameter $move = null,
        ?\Tzkt\Model\OperationsGetSmartRollupRefuteOpsGameStatusParameter $game_status = null,
        ?\Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupRefuteOps'][0]
    ): Request
    {





















        if ($limit !== null && $limit > 10000) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetSmartRollupRefuteOps, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetSmartRollupRefuteOps, must be bigger than or equal to 0.');
        }
        



        $resourcePath = '/v1/operations/sr_refute';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $anyof,
            'anyof', // param base name
            '\Tzkt\Model\AnyOfParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $game_id,
            'game.id', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $game_initiator,
            'game.initiator', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $game_initiator_commitment_id,
            'game.initiatorCommitment.id', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $game_initiator_commitment_hash,
            'game.initiatorCommitment.hash', // param base name
            '\Tzkt\Model\Src1HashParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $game_opponent,
            'game.opponent', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $game_opponent_commitment_id,
            'game.opponentCommitment.id', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $game_opponent_commitment_hash,
            'game.opponentCommitment.hash', // param base name
            '\Tzkt\Model\Src1HashParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $move,
            'move', // param base name
            '\Tzkt\Model\RefutationMoveParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $game_status,
            'gameStatus', // param base name
            '\Tzkt\Model\RefutationGameStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rollup,
            'rollup', // param base name
            '\Tzkt\Model\SmartRollupParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            '\Tzkt\Model\Int64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hash,
            'hash', // param base name
            '\Tzkt\Model\OpHashParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $counter,
            'counter', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\TimestampParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            '\Tzkt\Model\OperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            '\Tzkt\Model\SortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            '\Tzkt\Model\OffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            '\Tzkt\Model\SelectionParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetSmartRollupRefuteOpsCount
     *
     * Get smart rollup refute count
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filter by any of the specified fields (&#x60;sender&#x60;, &#x60;initiator&#x60;, or &#x60;opponent&#x60;). Example: &#x60;anyof.initiator.opponent&#x3D;tz1...&#x60; will return operations where &#x60;initiator&#x60; OR &#x60;opponent&#x60; is equal to the specified value. This parameter is useful when you need to get all operations somehow related to the account in a single request.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $game_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $game_initiator Filter by initiator (who found a wrong commitment and started the refutation game).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $game_initiator_commitment_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupPublishOpsCommitmentHashParameter|null $game_initiator_commitment_hash Filter by commitment hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $game_opponent Filter by opponent (who was accused in publishing a wrong commitment).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $game_opponent_commitment_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupPublishOpsCommitmentHashParameter|null $game_opponent_commitment_hash Filter by commitment hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupRefuteOpsMoveParameter|null $move Filter by refutation game move (&#x60;start&#x60;, &#x60;dissection&#x60;, &#x60;proof&#x60;, or &#x60;timeout&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupRefuteOpsGameStatusParameter|null $game_status Filter by refutation game status (&#x60;none&#x60;, &#x60;ongoing&#x60;, &#x60;loser&#x60;, or &#x60;draw&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter|null $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupRefuteOpsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return int
     */
    public function operationsGetSmartRollupRefuteOpsCount(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetIdParameter $game_id = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $game_initiator = null,
        ?\Tzkt\Model\AccountsGetIdParameter $game_initiator_commitment_id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupPublishOpsCommitmentHashParameter $game_initiator_commitment_hash = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $game_opponent = null,
        ?\Tzkt\Model\AccountsGetIdParameter $game_opponent_commitment_id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupPublishOpsCommitmentHashParameter $game_opponent_commitment_hash = null,
        ?\Tzkt\Model\OperationsGetSmartRollupRefuteOpsMoveParameter $move = null,
        ?\Tzkt\Model\OperationsGetSmartRollupRefuteOpsGameStatusParameter $game_status = null,
        ?\Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupRefuteOpsCount'][0]
    ): int
    {
        list($response) = $this->operationsGetSmartRollupRefuteOpsCountWithHttpInfo($anyof, $game_id, $game_initiator, $game_initiator_commitment_id, $game_initiator_commitment_hash, $game_opponent, $game_opponent_commitment_id, $game_opponent_commitment_hash, $move, $game_status, $rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetSmartRollupRefuteOpsCountWithHttpInfo
     *
     * Get smart rollup refute count
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filter by any of the specified fields (&#x60;sender&#x60;, &#x60;initiator&#x60;, or &#x60;opponent&#x60;). Example: &#x60;anyof.initiator.opponent&#x3D;tz1...&#x60; will return operations where &#x60;initiator&#x60; OR &#x60;opponent&#x60; is equal to the specified value. This parameter is useful when you need to get all operations somehow related to the account in a single request.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $game_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $game_initiator Filter by initiator (who found a wrong commitment and started the refutation game).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $game_initiator_commitment_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupPublishOpsCommitmentHashParameter|null $game_initiator_commitment_hash Filter by commitment hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $game_opponent Filter by opponent (who was accused in publishing a wrong commitment).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $game_opponent_commitment_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupPublishOpsCommitmentHashParameter|null $game_opponent_commitment_hash Filter by commitment hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupRefuteOpsMoveParameter|null $move Filter by refutation game move (&#x60;start&#x60;, &#x60;dissection&#x60;, &#x60;proof&#x60;, or &#x60;timeout&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupRefuteOpsGameStatusParameter|null $game_status Filter by refutation game status (&#x60;none&#x60;, &#x60;ongoing&#x60;, &#x60;loser&#x60;, or &#x60;draw&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter|null $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupRefuteOpsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetSmartRollupRefuteOpsCountWithHttpInfo(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetIdParameter $game_id = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $game_initiator = null,
        ?\Tzkt\Model\AccountsGetIdParameter $game_initiator_commitment_id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupPublishOpsCommitmentHashParameter $game_initiator_commitment_hash = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $game_opponent = null,
        ?\Tzkt\Model\AccountsGetIdParameter $game_opponent_commitment_id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupPublishOpsCommitmentHashParameter $game_opponent_commitment_hash = null,
        ?\Tzkt\Model\OperationsGetSmartRollupRefuteOpsMoveParameter $move = null,
        ?\Tzkt\Model\OperationsGetSmartRollupRefuteOpsGameStatusParameter $game_status = null,
        ?\Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupRefuteOpsCount'][0]
    ): array
    {
        $request = $this->operationsGetSmartRollupRefuteOpsCountRequest($anyof, $game_id, $game_initiator, $game_initiator_commitment_id, $game_initiator_commitment_hash, $game_opponent, $game_opponent_commitment_id, $game_opponent_commitment_hash, $move, $game_status, $rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('int', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'int';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetSmartRollupRefuteOpsCountAsync
     *
     * Get smart rollup refute count
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filter by any of the specified fields (&#x60;sender&#x60;, &#x60;initiator&#x60;, or &#x60;opponent&#x60;). Example: &#x60;anyof.initiator.opponent&#x3D;tz1...&#x60; will return operations where &#x60;initiator&#x60; OR &#x60;opponent&#x60; is equal to the specified value. This parameter is useful when you need to get all operations somehow related to the account in a single request.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $game_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $game_initiator Filter by initiator (who found a wrong commitment and started the refutation game).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $game_initiator_commitment_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupPublishOpsCommitmentHashParameter|null $game_initiator_commitment_hash Filter by commitment hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $game_opponent Filter by opponent (who was accused in publishing a wrong commitment).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $game_opponent_commitment_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupPublishOpsCommitmentHashParameter|null $game_opponent_commitment_hash Filter by commitment hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupRefuteOpsMoveParameter|null $move Filter by refutation game move (&#x60;start&#x60;, &#x60;dissection&#x60;, &#x60;proof&#x60;, or &#x60;timeout&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupRefuteOpsGameStatusParameter|null $game_status Filter by refutation game status (&#x60;none&#x60;, &#x60;ongoing&#x60;, &#x60;loser&#x60;, or &#x60;draw&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter|null $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupRefuteOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetSmartRollupRefuteOpsCountAsync(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetIdParameter $game_id = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $game_initiator = null,
        ?\Tzkt\Model\AccountsGetIdParameter $game_initiator_commitment_id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupPublishOpsCommitmentHashParameter $game_initiator_commitment_hash = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $game_opponent = null,
        ?\Tzkt\Model\AccountsGetIdParameter $game_opponent_commitment_id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupPublishOpsCommitmentHashParameter $game_opponent_commitment_hash = null,
        ?\Tzkt\Model\OperationsGetSmartRollupRefuteOpsMoveParameter $move = null,
        ?\Tzkt\Model\OperationsGetSmartRollupRefuteOpsGameStatusParameter $game_status = null,
        ?\Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupRefuteOpsCount'][0]
    ): PromiseInterface
    {
        return $this->operationsGetSmartRollupRefuteOpsCountAsyncWithHttpInfo($anyof, $game_id, $game_initiator, $game_initiator_commitment_id, $game_initiator_commitment_hash, $game_opponent, $game_opponent_commitment_id, $game_opponent_commitment_hash, $move, $game_status, $rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetSmartRollupRefuteOpsCountAsyncWithHttpInfo
     *
     * Get smart rollup refute count
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filter by any of the specified fields (&#x60;sender&#x60;, &#x60;initiator&#x60;, or &#x60;opponent&#x60;). Example: &#x60;anyof.initiator.opponent&#x3D;tz1...&#x60; will return operations where &#x60;initiator&#x60; OR &#x60;opponent&#x60; is equal to the specified value. This parameter is useful when you need to get all operations somehow related to the account in a single request.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $game_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $game_initiator Filter by initiator (who found a wrong commitment and started the refutation game).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $game_initiator_commitment_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupPublishOpsCommitmentHashParameter|null $game_initiator_commitment_hash Filter by commitment hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $game_opponent Filter by opponent (who was accused in publishing a wrong commitment).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $game_opponent_commitment_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupPublishOpsCommitmentHashParameter|null $game_opponent_commitment_hash Filter by commitment hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupRefuteOpsMoveParameter|null $move Filter by refutation game move (&#x60;start&#x60;, &#x60;dissection&#x60;, &#x60;proof&#x60;, or &#x60;timeout&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupRefuteOpsGameStatusParameter|null $game_status Filter by refutation game status (&#x60;none&#x60;, &#x60;ongoing&#x60;, &#x60;loser&#x60;, or &#x60;draw&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter|null $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupRefuteOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetSmartRollupRefuteOpsCountAsyncWithHttpInfo(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetIdParameter $game_id = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $game_initiator = null,
        ?\Tzkt\Model\AccountsGetIdParameter $game_initiator_commitment_id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupPublishOpsCommitmentHashParameter $game_initiator_commitment_hash = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $game_opponent = null,
        ?\Tzkt\Model\AccountsGetIdParameter $game_opponent_commitment_id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupPublishOpsCommitmentHashParameter $game_opponent_commitment_hash = null,
        ?\Tzkt\Model\OperationsGetSmartRollupRefuteOpsMoveParameter $move = null,
        ?\Tzkt\Model\OperationsGetSmartRollupRefuteOpsGameStatusParameter $game_status = null,
        ?\Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupRefuteOpsCount'][0]
    ): PromiseInterface
    {
        $returnType = 'int';
        $request = $this->operationsGetSmartRollupRefuteOpsCountRequest($anyof, $game_id, $game_initiator, $game_initiator_commitment_id, $game_initiator_commitment_hash, $game_opponent, $game_opponent_commitment_id, $game_opponent_commitment_hash, $move, $game_status, $rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetSmartRollupRefuteOpsCount'
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filter by any of the specified fields (&#x60;sender&#x60;, &#x60;initiator&#x60;, or &#x60;opponent&#x60;). Example: &#x60;anyof.initiator.opponent&#x3D;tz1...&#x60; will return operations where &#x60;initiator&#x60; OR &#x60;opponent&#x60; is equal to the specified value. This parameter is useful when you need to get all operations somehow related to the account in a single request.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $game_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $game_initiator Filter by initiator (who found a wrong commitment and started the refutation game).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $game_initiator_commitment_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupPublishOpsCommitmentHashParameter|null $game_initiator_commitment_hash Filter by commitment hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $game_opponent Filter by opponent (who was accused in publishing a wrong commitment).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $game_opponent_commitment_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupPublishOpsCommitmentHashParameter|null $game_opponent_commitment_hash Filter by commitment hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupRefuteOpsMoveParameter|null $move Filter by refutation game move (&#x60;start&#x60;, &#x60;dissection&#x60;, &#x60;proof&#x60;, or &#x60;timeout&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupRefuteOpsGameStatusParameter|null $game_status Filter by refutation game status (&#x60;none&#x60;, &#x60;ongoing&#x60;, &#x60;loser&#x60;, or &#x60;draw&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter|null $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupRefuteOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetSmartRollupRefuteOpsCountRequest(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetIdParameter $game_id = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $game_initiator = null,
        ?\Tzkt\Model\AccountsGetIdParameter $game_initiator_commitment_id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupPublishOpsCommitmentHashParameter $game_initiator_commitment_hash = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $game_opponent = null,
        ?\Tzkt\Model\AccountsGetIdParameter $game_opponent_commitment_id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupPublishOpsCommitmentHashParameter $game_opponent_commitment_hash = null,
        ?\Tzkt\Model\OperationsGetSmartRollupRefuteOpsMoveParameter $move = null,
        ?\Tzkt\Model\OperationsGetSmartRollupRefuteOpsGameStatusParameter $game_status = null,
        ?\Tzkt\Model\OperationsGetSmartRollupCementOpsRollupParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        string $contentType = self::contentTypes['operationsGetSmartRollupRefuteOpsCount'][0]
    ): Request
    {




















        $resourcePath = '/v1/operations/sr_refute/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $anyof,
            'anyof', // param base name
            '\Tzkt\Model\AnyOfParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $game_id,
            'game.id', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $game_initiator,
            'game.initiator', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $game_initiator_commitment_id,
            'game.initiatorCommitment.id', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $game_initiator_commitment_hash,
            'game.initiatorCommitment.hash', // param base name
            '\Tzkt\Model\Src1HashParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $game_opponent,
            'game.opponent', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $game_opponent_commitment_id,
            'game.opponentCommitment.id', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $game_opponent_commitment_hash,
            'game.opponentCommitment.hash', // param base name
            '\Tzkt\Model\Src1HashParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $move,
            'move', // param base name
            '\Tzkt\Model\RefutationMoveParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $game_status,
            'gameStatus', // param base name
            '\Tzkt\Model\RefutationGameStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rollup,
            'rollup', // param base name
            '\Tzkt\Model\SmartRollupParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            '\Tzkt\Model\Int64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hash,
            'hash', // param base name
            '\Tzkt\Model\OpHashParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $counter,
            'counter', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\TimestampParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            '\Tzkt\Model\OperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetStakingOps
     *
     * Get staking ops
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filter by any of the specified fields (&#x60;sender&#x60;, or &#x60;baker&#x60;). Example: &#x60;anyof.sender.baker&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;baker&#x60; is equal to the specified value. This parameter is useful when you need to get all operations somehow related to the account in a single request.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $baker Filter by baker address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetStakingOpsActionParameter|null $action Filter by staking action (&#x60;stake&#x60;, &#x60;unstake&#x60;, &#x60;finalize&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int|null $limit Maximum number of items to return. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysSelectParameter|null $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetStakingOps'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\StakingOperation[]
     */
    public function operationsGetStakingOps(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $baker = null,
        ?\Tzkt\Model\OperationsGetStakingOpsActionParameter $action = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetStakingOps'][0]
    ): array
    {
        list($response) = $this->operationsGetStakingOpsWithHttpInfo($anyof, $baker, $action, $id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetStakingOpsWithHttpInfo
     *
     * Get staking ops
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filter by any of the specified fields (&#x60;sender&#x60;, or &#x60;baker&#x60;). Example: &#x60;anyof.sender.baker&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;baker&#x60; is equal to the specified value. This parameter is useful when you need to get all operations somehow related to the account in a single request.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $baker Filter by baker address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetStakingOpsActionParameter|null $action Filter by staking action (&#x60;stake&#x60;, &#x60;unstake&#x60;, &#x60;finalize&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int|null $limit Maximum number of items to return. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysSelectParameter|null $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetStakingOps'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\StakingOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetStakingOpsWithHttpInfo(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $baker = null,
        ?\Tzkt\Model\OperationsGetStakingOpsActionParameter $action = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetStakingOps'][0]
    ): array
    {
        $request = $this->operationsGetStakingOpsRequest($anyof, $baker, $action, $id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\StakingOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\StakingOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\StakingOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\StakingOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\StakingOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetStakingOpsAsync
     *
     * Get staking ops
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filter by any of the specified fields (&#x60;sender&#x60;, or &#x60;baker&#x60;). Example: &#x60;anyof.sender.baker&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;baker&#x60; is equal to the specified value. This parameter is useful when you need to get all operations somehow related to the account in a single request.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $baker Filter by baker address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetStakingOpsActionParameter|null $action Filter by staking action (&#x60;stake&#x60;, &#x60;unstake&#x60;, &#x60;finalize&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int|null $limit Maximum number of items to return. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysSelectParameter|null $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetStakingOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetStakingOpsAsync(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $baker = null,
        ?\Tzkt\Model\OperationsGetStakingOpsActionParameter $action = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetStakingOps'][0]
    ): PromiseInterface
    {
        return $this->operationsGetStakingOpsAsyncWithHttpInfo($anyof, $baker, $action, $id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetStakingOpsAsyncWithHttpInfo
     *
     * Get staking ops
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filter by any of the specified fields (&#x60;sender&#x60;, or &#x60;baker&#x60;). Example: &#x60;anyof.sender.baker&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;baker&#x60; is equal to the specified value. This parameter is useful when you need to get all operations somehow related to the account in a single request.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $baker Filter by baker address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetStakingOpsActionParameter|null $action Filter by staking action (&#x60;stake&#x60;, &#x60;unstake&#x60;, &#x60;finalize&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int|null $limit Maximum number of items to return. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysSelectParameter|null $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetStakingOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetStakingOpsAsyncWithHttpInfo(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $baker = null,
        ?\Tzkt\Model\OperationsGetStakingOpsActionParameter $action = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetStakingOps'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\StakingOperation[]';
        $request = $this->operationsGetStakingOpsRequest($anyof, $baker, $action, $id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetStakingOps'
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filter by any of the specified fields (&#x60;sender&#x60;, or &#x60;baker&#x60;). Example: &#x60;anyof.sender.baker&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;baker&#x60; is equal to the specified value. This parameter is useful when you need to get all operations somehow related to the account in a single request.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $baker Filter by baker address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetStakingOpsActionParameter|null $action Filter by staking action (&#x60;stake&#x60;, &#x60;unstake&#x60;, &#x60;finalize&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int|null $limit Maximum number of items to return. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysSelectParameter|null $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetStakingOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetStakingOpsRequest(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $baker = null,
        ?\Tzkt\Model\OperationsGetStakingOpsActionParameter $action = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetStakingOps'][0]
    ): Request
    {













        if ($limit !== null && $limit > 10000) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetStakingOps, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetStakingOps, must be bigger than or equal to 0.');
        }
        



        $resourcePath = '/v1/operations/staking';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $anyof,
            'anyof', // param base name
            '\Tzkt\Model\AnyOfParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $baker,
            'baker', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $action,
            'action', // param base name
            '\Tzkt\Model\StakingActionParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            '\Tzkt\Model\Int64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hash,
            'hash', // param base name
            '\Tzkt\Model\OpHashParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $counter,
            'counter', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\TimestampParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            '\Tzkt\Model\OperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            '\Tzkt\Model\SortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            '\Tzkt\Model\OffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            '\Tzkt\Model\SelectionParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetStakingOpsCount
     *
     * Get staking ops count
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filter by any of the specified fields (&#x60;sender&#x60;, or &#x60;baker&#x60;). Example: &#x60;anyof.sender.baker&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;baker&#x60; is equal to the specified value. This parameter is useful when you need to get all operations somehow related to the account in a single request.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $baker Filter by baker address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetStakingOpsActionParameter|null $action Filter by staking action (&#x60;stake&#x60;, &#x60;unstake&#x60;, &#x60;finalize&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetStakingOpsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return int
     */
    public function operationsGetStakingOpsCount(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $baker = null,
        ?\Tzkt\Model\OperationsGetStakingOpsActionParameter $action = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        string $contentType = self::contentTypes['operationsGetStakingOpsCount'][0]
    ): int
    {
        list($response) = $this->operationsGetStakingOpsCountWithHttpInfo($anyof, $baker, $action, $id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetStakingOpsCountWithHttpInfo
     *
     * Get staking ops count
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filter by any of the specified fields (&#x60;sender&#x60;, or &#x60;baker&#x60;). Example: &#x60;anyof.sender.baker&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;baker&#x60; is equal to the specified value. This parameter is useful when you need to get all operations somehow related to the account in a single request.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $baker Filter by baker address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetStakingOpsActionParameter|null $action Filter by staking action (&#x60;stake&#x60;, &#x60;unstake&#x60;, &#x60;finalize&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetStakingOpsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetStakingOpsCountWithHttpInfo(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $baker = null,
        ?\Tzkt\Model\OperationsGetStakingOpsActionParameter $action = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        string $contentType = self::contentTypes['operationsGetStakingOpsCount'][0]
    ): array
    {
        $request = $this->operationsGetStakingOpsCountRequest($anyof, $baker, $action, $id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('int', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'int';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetStakingOpsCountAsync
     *
     * Get staking ops count
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filter by any of the specified fields (&#x60;sender&#x60;, or &#x60;baker&#x60;). Example: &#x60;anyof.sender.baker&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;baker&#x60; is equal to the specified value. This parameter is useful when you need to get all operations somehow related to the account in a single request.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $baker Filter by baker address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetStakingOpsActionParameter|null $action Filter by staking action (&#x60;stake&#x60;, &#x60;unstake&#x60;, &#x60;finalize&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetStakingOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetStakingOpsCountAsync(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $baker = null,
        ?\Tzkt\Model\OperationsGetStakingOpsActionParameter $action = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        string $contentType = self::contentTypes['operationsGetStakingOpsCount'][0]
    ): PromiseInterface
    {
        return $this->operationsGetStakingOpsCountAsyncWithHttpInfo($anyof, $baker, $action, $id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetStakingOpsCountAsyncWithHttpInfo
     *
     * Get staking ops count
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filter by any of the specified fields (&#x60;sender&#x60;, or &#x60;baker&#x60;). Example: &#x60;anyof.sender.baker&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;baker&#x60; is equal to the specified value. This parameter is useful when you need to get all operations somehow related to the account in a single request.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $baker Filter by baker address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetStakingOpsActionParameter|null $action Filter by staking action (&#x60;stake&#x60;, &#x60;unstake&#x60;, &#x60;finalize&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetStakingOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetStakingOpsCountAsyncWithHttpInfo(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $baker = null,
        ?\Tzkt\Model\OperationsGetStakingOpsActionParameter $action = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        string $contentType = self::contentTypes['operationsGetStakingOpsCount'][0]
    ): PromiseInterface
    {
        $returnType = 'int';
        $request = $this->operationsGetStakingOpsCountRequest($anyof, $baker, $action, $id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetStakingOpsCount'
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filter by any of the specified fields (&#x60;sender&#x60;, or &#x60;baker&#x60;). Example: &#x60;anyof.sender.baker&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;baker&#x60; is equal to the specified value. This parameter is useful when you need to get all operations somehow related to the account in a single request.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $baker Filter by baker address.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetStakingOpsActionParameter|null $action Filter by staking action (&#x60;stake&#x60;, &#x60;unstake&#x60;, &#x60;finalize&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter|null $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetStakingOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetStakingOpsCountRequest(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $baker = null,
        ?\Tzkt\Model\OperationsGetStakingOpsActionParameter $action = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\OperationsGetSmartRollupAddMessagesOpsHashParameter $hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $counter = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        string $contentType = self::contentTypes['operationsGetStakingOpsCount'][0]
    ): Request
    {












        $resourcePath = '/v1/operations/staking/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $anyof,
            'anyof', // param base name
            '\Tzkt\Model\AnyOfParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $baker,
            'baker', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $action,
            'action', // param base name
            '\Tzkt\Model\StakingActionParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            '\Tzkt\Model\Int64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hash,
            'hash', // param base name
            '\Tzkt\Model\OpHashParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $counter,
            'counter', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\TimestampParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            '\Tzkt\Model\OperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetStatus
     *
     * Get operation status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetStatus'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return bool
     */
    public function operationsGetStatus(
        string $hash,
        string $contentType = self::contentTypes['operationsGetStatus'][0]
    ): bool
    {
        list($response) = $this->operationsGetStatusWithHttpInfo($hash, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetStatusWithHttpInfo
     *
     * Get operation status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetStatus'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of bool, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetStatusWithHttpInfo(
        string $hash,
        string $contentType = self::contentTypes['operationsGetStatus'][0]
    ): array
    {
        $request = $this->operationsGetStatusRequest($hash, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('bool', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('bool' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'bool', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'bool';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'bool',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetStatusAsync
     *
     * Get operation status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetStatus'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetStatusAsync(
        string $hash,
        string $contentType = self::contentTypes['operationsGetStatus'][0]
    ): PromiseInterface
    {
        return $this->operationsGetStatusAsyncWithHttpInfo($hash, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetStatusAsyncWithHttpInfo
     *
     * Get operation status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetStatus'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetStatusAsyncWithHttpInfo(
        string $hash,
        string $contentType = self::contentTypes['operationsGetStatus'][0]
    ): PromiseInterface
    {
        $returnType = 'bool';
        $request = $this->operationsGetStatusRequest($hash, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetStatus'
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetStatus'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetStatusRequest(
        string $hash,
        string $contentType = self::contentTypes['operationsGetStatus'][0]
    ): Request
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetStatus'
            );
        }


        $resourcePath = '/v1/operations/{hash}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTransactionByHash
     *
     * Get transaction by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransactionByHash'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\TransactionOperation[]
     */
    public function operationsGetTransactionByHash(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTransactionByHash'][0]
    ): array
    {
        list($response) = $this->operationsGetTransactionByHashWithHttpInfo($hash, $micheline, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTransactionByHashWithHttpInfo
     *
     * Get transaction by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransactionByHash'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\TransactionOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTransactionByHashWithHttpInfo(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTransactionByHash'][0]
    ): array
    {
        $request = $this->operationsGetTransactionByHashRequest($hash, $micheline, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\TransactionOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\TransactionOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\TransactionOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\TransactionOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\TransactionOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTransactionByHashAsync
     *
     * Get transaction by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransactionByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTransactionByHashAsync(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTransactionByHash'][0]
    ): PromiseInterface
    {
        return $this->operationsGetTransactionByHashAsyncWithHttpInfo($hash, $micheline, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTransactionByHashAsyncWithHttpInfo
     *
     * Get transaction by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransactionByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTransactionByHashAsyncWithHttpInfo(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTransactionByHash'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\TransactionOperation[]';
        $request = $this->operationsGetTransactionByHashRequest($hash, $micheline, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTransactionByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransactionByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTransactionByHashRequest(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTransactionByHash'][0]
    ): Request
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetTransactionByHash'
            );
        }




        $resourcePath = '/v1/operations/transactions/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $micheline,
            'micheline', // param base name
            '\Tzkt\Model\MichelineFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTransactionByHashCounter
     *
     * Get transaction by hash and counter
     *
     * @param  string $hash Operation hash (required)
     * @param  int $counter Operation counter (required)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransactionByHashCounter'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\TransactionOperation[]
     */
    public function operationsGetTransactionByHashCounter(
        string $hash,
        int $counter,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTransactionByHashCounter'][0]
    ): array
    {
        list($response) = $this->operationsGetTransactionByHashCounterWithHttpInfo($hash, $counter, $micheline, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTransactionByHashCounterWithHttpInfo
     *
     * Get transaction by hash and counter
     *
     * @param  string $hash Operation hash (required)
     * @param  int $counter Operation counter (required)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransactionByHashCounter'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\TransactionOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTransactionByHashCounterWithHttpInfo(
        string $hash,
        int $counter,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTransactionByHashCounter'][0]
    ): array
    {
        $request = $this->operationsGetTransactionByHashCounterRequest($hash, $counter, $micheline, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\TransactionOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\TransactionOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\TransactionOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\TransactionOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\TransactionOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTransactionByHashCounterAsync
     *
     * Get transaction by hash and counter
     *
     * @param  string $hash Operation hash (required)
     * @param  int $counter Operation counter (required)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransactionByHashCounter'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTransactionByHashCounterAsync(
        string $hash,
        int $counter,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTransactionByHashCounter'][0]
    ): PromiseInterface
    {
        return $this->operationsGetTransactionByHashCounterAsyncWithHttpInfo($hash, $counter, $micheline, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTransactionByHashCounterAsyncWithHttpInfo
     *
     * Get transaction by hash and counter
     *
     * @param  string $hash Operation hash (required)
     * @param  int $counter Operation counter (required)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransactionByHashCounter'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTransactionByHashCounterAsyncWithHttpInfo(
        string $hash,
        int $counter,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTransactionByHashCounter'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\TransactionOperation[]';
        $request = $this->operationsGetTransactionByHashCounterRequest($hash, $counter, $micheline, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTransactionByHashCounter'
     *
     * @param  string $hash Operation hash (required)
     * @param  int $counter Operation counter (required)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransactionByHashCounter'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTransactionByHashCounterRequest(
        string $hash,
        int $counter,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTransactionByHashCounter'][0]
    ): Request
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetTransactionByHashCounter'
            );
        }

        // verify the required parameter 'counter' is set
        if ($counter === null || (is_array($counter) && count($counter) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $counter when calling operationsGetTransactionByHashCounter'
            );
        }




        $resourcePath = '/v1/operations/transactions/{hash}/{counter}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $micheline,
            'micheline', // param base name
            '\Tzkt\Model\MichelineFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }
        // path params
        if ($counter !== null) {
            $resourcePath = str_replace(
                '{' . 'counter' . '}',
                ObjectSerializer::toPathValue($counter),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTransactionByHashCounterNonce
     *
     * Get transaction by hash, counter and nonce
     *
     * @param  string $hash Operation hash (required)
     * @param  int $counter Operation counter (required)
     * @param  int $nonce Operation nonce (internal) (required)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransactionByHashCounterNonce'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\TransactionOperation[]
     */
    public function operationsGetTransactionByHashCounterNonce(
        string $hash,
        int $counter,
        int $nonce,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTransactionByHashCounterNonce'][0]
    ): array
    {
        list($response) = $this->operationsGetTransactionByHashCounterNonceWithHttpInfo($hash, $counter, $nonce, $micheline, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTransactionByHashCounterNonceWithHttpInfo
     *
     * Get transaction by hash, counter and nonce
     *
     * @param  string $hash Operation hash (required)
     * @param  int $counter Operation counter (required)
     * @param  int $nonce Operation nonce (internal) (required)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransactionByHashCounterNonce'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\TransactionOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTransactionByHashCounterNonceWithHttpInfo(
        string $hash,
        int $counter,
        int $nonce,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTransactionByHashCounterNonce'][0]
    ): array
    {
        $request = $this->operationsGetTransactionByHashCounterNonceRequest($hash, $counter, $nonce, $micheline, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\TransactionOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\TransactionOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\TransactionOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\TransactionOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\TransactionOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTransactionByHashCounterNonceAsync
     *
     * Get transaction by hash, counter and nonce
     *
     * @param  string $hash Operation hash (required)
     * @param  int $counter Operation counter (required)
     * @param  int $nonce Operation nonce (internal) (required)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransactionByHashCounterNonce'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTransactionByHashCounterNonceAsync(
        string $hash,
        int $counter,
        int $nonce,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTransactionByHashCounterNonce'][0]
    ): PromiseInterface
    {
        return $this->operationsGetTransactionByHashCounterNonceAsyncWithHttpInfo($hash, $counter, $nonce, $micheline, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTransactionByHashCounterNonceAsyncWithHttpInfo
     *
     * Get transaction by hash, counter and nonce
     *
     * @param  string $hash Operation hash (required)
     * @param  int $counter Operation counter (required)
     * @param  int $nonce Operation nonce (internal) (required)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransactionByHashCounterNonce'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTransactionByHashCounterNonceAsyncWithHttpInfo(
        string $hash,
        int $counter,
        int $nonce,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTransactionByHashCounterNonce'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\TransactionOperation[]';
        $request = $this->operationsGetTransactionByHashCounterNonceRequest($hash, $counter, $nonce, $micheline, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTransactionByHashCounterNonce'
     *
     * @param  string $hash Operation hash (required)
     * @param  int $counter Operation counter (required)
     * @param  int $nonce Operation nonce (internal) (required)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransactionByHashCounterNonce'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTransactionByHashCounterNonceRequest(
        string $hash,
        int $counter,
        int $nonce,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTransactionByHashCounterNonce'][0]
    ): Request
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetTransactionByHashCounterNonce'
            );
        }

        // verify the required parameter 'counter' is set
        if ($counter === null || (is_array($counter) && count($counter) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $counter when calling operationsGetTransactionByHashCounterNonce'
            );
        }

        // verify the required parameter 'nonce' is set
        if ($nonce === null || (is_array($nonce) && count($nonce) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $nonce when calling operationsGetTransactionByHashCounterNonce'
            );
        }




        $resourcePath = '/v1/operations/transactions/{hash}/{counter}/{nonce}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $micheline,
            'micheline', // param base name
            '\Tzkt\Model\MichelineFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }
        // path params
        if ($counter !== null) {
            $resourcePath = str_replace(
                '{' . 'counter' . '}',
                ObjectSerializer::toPathValue($counter),
                $resourcePath
            );
        }
        // path params
        if ($nonce !== null) {
            $resourcePath = str_replace(
                '{' . 'nonce' . '}',
                ObjectSerializer::toPathValue($nonce),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTransactionStatus
     *
     * Get transaction status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransactionStatus'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return bool
     */
    public function operationsGetTransactionStatus(
        string $hash,
        string $contentType = self::contentTypes['operationsGetTransactionStatus'][0]
    ): bool
    {
        list($response) = $this->operationsGetTransactionStatusWithHttpInfo($hash, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTransactionStatusWithHttpInfo
     *
     * Get transaction status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransactionStatus'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of bool, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTransactionStatusWithHttpInfo(
        string $hash,
        string $contentType = self::contentTypes['operationsGetTransactionStatus'][0]
    ): array
    {
        $request = $this->operationsGetTransactionStatusRequest($hash, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('bool', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('bool' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'bool', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'bool';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'bool',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTransactionStatusAsync
     *
     * Get transaction status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransactionStatus'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTransactionStatusAsync(
        string $hash,
        string $contentType = self::contentTypes['operationsGetTransactionStatus'][0]
    ): PromiseInterface
    {
        return $this->operationsGetTransactionStatusAsyncWithHttpInfo($hash, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTransactionStatusAsyncWithHttpInfo
     *
     * Get transaction status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransactionStatus'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTransactionStatusAsyncWithHttpInfo(
        string $hash,
        string $contentType = self::contentTypes['operationsGetTransactionStatus'][0]
    ): PromiseInterface
    {
        $returnType = 'bool';
        $request = $this->operationsGetTransactionStatusRequest($hash, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTransactionStatus'
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransactionStatus'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTransactionStatusRequest(
        string $hash,
        string $contentType = self::contentTypes['operationsGetTransactionStatus'][0]
    ): Request
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetTransactionStatus'
            );
        }


        $resourcePath = '/v1/operations/transactions/{hash}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTransactions
     *
     * Get transactions
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters transactions by any of the specified fields. Example: &#x60;anyof.sender.target&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;target&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all transactions associated with a specified account. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $initiator Filters transactions by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;target&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters transactions by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;target&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $target Filters transactions by target. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;sender&#x60;, &#x60;initiator&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $amount Filters transactions by amount (micro tez). (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters transactions by id. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters transactions by level. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filters transactions by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $sender_code_hash Filters by &#x60;senderCodeHash&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $target_code_hash Filters by &#x60;targetCodeHash&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $code_hash Filters by either &#x60;senderCodeHash&#x60; or &#x60;targetCodeHash&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsEntrypointParameter|null $entrypoint Filters transactions by entrypoint called on the target contract. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsParameterParameter|null $parameter Filters transactions by parameter value. Note, this query parameter supports the following format: &#x60;?parameter{.path?}{.mode?}&#x3D;...&#x60;,             so you can specify a path to a particular field to filter by, for example: &#x60;?parameter.token_id&#x3D;...&#x60; or &#x60;?parameter.sigs.0.ne&#x3D;...&#x60;.             Also, note that &#x60;.value&#x60; part must be omitted in the path, so, for example, filtering by &#x60;parameter.value.foo&#x60; must be specified as &#x60;?parameter.foo&#x3D;...&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetStakedParameter|null $has_internals Filters transactions by presence of internal operations. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters transactions by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts transactions by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;, &#x60;allocationFee&#x60;, &#x60;amount&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransactions'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\TransactionOperation[]
     */
    public function operationsGetTransactions(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $initiator = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $target = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $amount = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetIdParameter $sender_code_hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $target_code_hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $code_hash = null,
        ?\Tzkt\Model\AccountsGetOperationsEntrypointParameter $entrypoint = null,
        ?\Tzkt\Model\AccountsGetOperationsParameterParameter $parameter = null,
        ?\Tzkt\Model\AccountsGetStakedParameter $has_internals = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTransactions'][0]
    ): array
    {
        list($response) = $this->operationsGetTransactionsWithHttpInfo($anyof, $initiator, $sender, $target, $amount, $id, $level, $timestamp, $sender_code_hash, $target_code_hash, $code_hash, $entrypoint, $parameter, $has_internals, $status, $select, $sort, $offset, $limit, $micheline, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTransactionsWithHttpInfo
     *
     * Get transactions
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters transactions by any of the specified fields. Example: &#x60;anyof.sender.target&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;target&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all transactions associated with a specified account. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $initiator Filters transactions by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;target&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters transactions by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;target&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $target Filters transactions by target. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;sender&#x60;, &#x60;initiator&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $amount Filters transactions by amount (micro tez). (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters transactions by id. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters transactions by level. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filters transactions by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $sender_code_hash Filters by &#x60;senderCodeHash&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $target_code_hash Filters by &#x60;targetCodeHash&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $code_hash Filters by either &#x60;senderCodeHash&#x60; or &#x60;targetCodeHash&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsEntrypointParameter|null $entrypoint Filters transactions by entrypoint called on the target contract. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsParameterParameter|null $parameter Filters transactions by parameter value. Note, this query parameter supports the following format: &#x60;?parameter{.path?}{.mode?}&#x3D;...&#x60;,             so you can specify a path to a particular field to filter by, for example: &#x60;?parameter.token_id&#x3D;...&#x60; or &#x60;?parameter.sigs.0.ne&#x3D;...&#x60;.             Also, note that &#x60;.value&#x60; part must be omitted in the path, so, for example, filtering by &#x60;parameter.value.foo&#x60; must be specified as &#x60;?parameter.foo&#x3D;...&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetStakedParameter|null $has_internals Filters transactions by presence of internal operations. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters transactions by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts transactions by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;, &#x60;allocationFee&#x60;, &#x60;amount&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransactions'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\TransactionOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTransactionsWithHttpInfo(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $initiator = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $target = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $amount = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetIdParameter $sender_code_hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $target_code_hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $code_hash = null,
        ?\Tzkt\Model\AccountsGetOperationsEntrypointParameter $entrypoint = null,
        ?\Tzkt\Model\AccountsGetOperationsParameterParameter $parameter = null,
        ?\Tzkt\Model\AccountsGetStakedParameter $has_internals = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTransactions'][0]
    ): array
    {
        $request = $this->operationsGetTransactionsRequest($anyof, $initiator, $sender, $target, $amount, $id, $level, $timestamp, $sender_code_hash, $target_code_hash, $code_hash, $entrypoint, $parameter, $has_internals, $status, $select, $sort, $offset, $limit, $micheline, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\TransactionOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\TransactionOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\TransactionOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\TransactionOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\TransactionOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTransactionsAsync
     *
     * Get transactions
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters transactions by any of the specified fields. Example: &#x60;anyof.sender.target&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;target&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all transactions associated with a specified account. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $initiator Filters transactions by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;target&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters transactions by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;target&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $target Filters transactions by target. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;sender&#x60;, &#x60;initiator&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $amount Filters transactions by amount (micro tez). (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters transactions by id. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters transactions by level. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filters transactions by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $sender_code_hash Filters by &#x60;senderCodeHash&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $target_code_hash Filters by &#x60;targetCodeHash&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $code_hash Filters by either &#x60;senderCodeHash&#x60; or &#x60;targetCodeHash&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsEntrypointParameter|null $entrypoint Filters transactions by entrypoint called on the target contract. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsParameterParameter|null $parameter Filters transactions by parameter value. Note, this query parameter supports the following format: &#x60;?parameter{.path?}{.mode?}&#x3D;...&#x60;,             so you can specify a path to a particular field to filter by, for example: &#x60;?parameter.token_id&#x3D;...&#x60; or &#x60;?parameter.sigs.0.ne&#x3D;...&#x60;.             Also, note that &#x60;.value&#x60; part must be omitted in the path, so, for example, filtering by &#x60;parameter.value.foo&#x60; must be specified as &#x60;?parameter.foo&#x3D;...&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetStakedParameter|null $has_internals Filters transactions by presence of internal operations. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters transactions by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts transactions by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;, &#x60;allocationFee&#x60;, &#x60;amount&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransactions'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTransactionsAsync(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $initiator = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $target = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $amount = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetIdParameter $sender_code_hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $target_code_hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $code_hash = null,
        ?\Tzkt\Model\AccountsGetOperationsEntrypointParameter $entrypoint = null,
        ?\Tzkt\Model\AccountsGetOperationsParameterParameter $parameter = null,
        ?\Tzkt\Model\AccountsGetStakedParameter $has_internals = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTransactions'][0]
    ): PromiseInterface
    {
        return $this->operationsGetTransactionsAsyncWithHttpInfo($anyof, $initiator, $sender, $target, $amount, $id, $level, $timestamp, $sender_code_hash, $target_code_hash, $code_hash, $entrypoint, $parameter, $has_internals, $status, $select, $sort, $offset, $limit, $micheline, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTransactionsAsyncWithHttpInfo
     *
     * Get transactions
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters transactions by any of the specified fields. Example: &#x60;anyof.sender.target&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;target&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all transactions associated with a specified account. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $initiator Filters transactions by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;target&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters transactions by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;target&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $target Filters transactions by target. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;sender&#x60;, &#x60;initiator&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $amount Filters transactions by amount (micro tez). (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters transactions by id. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters transactions by level. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filters transactions by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $sender_code_hash Filters by &#x60;senderCodeHash&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $target_code_hash Filters by &#x60;targetCodeHash&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $code_hash Filters by either &#x60;senderCodeHash&#x60; or &#x60;targetCodeHash&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsEntrypointParameter|null $entrypoint Filters transactions by entrypoint called on the target contract. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsParameterParameter|null $parameter Filters transactions by parameter value. Note, this query parameter supports the following format: &#x60;?parameter{.path?}{.mode?}&#x3D;...&#x60;,             so you can specify a path to a particular field to filter by, for example: &#x60;?parameter.token_id&#x3D;...&#x60; or &#x60;?parameter.sigs.0.ne&#x3D;...&#x60;.             Also, note that &#x60;.value&#x60; part must be omitted in the path, so, for example, filtering by &#x60;parameter.value.foo&#x60; must be specified as &#x60;?parameter.foo&#x3D;...&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetStakedParameter|null $has_internals Filters transactions by presence of internal operations. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters transactions by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts transactions by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;, &#x60;allocationFee&#x60;, &#x60;amount&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransactions'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTransactionsAsyncWithHttpInfo(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $initiator = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $target = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $amount = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetIdParameter $sender_code_hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $target_code_hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $code_hash = null,
        ?\Tzkt\Model\AccountsGetOperationsEntrypointParameter $entrypoint = null,
        ?\Tzkt\Model\AccountsGetOperationsParameterParameter $parameter = null,
        ?\Tzkt\Model\AccountsGetStakedParameter $has_internals = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTransactions'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\TransactionOperation[]';
        $request = $this->operationsGetTransactionsRequest($anyof, $initiator, $sender, $target, $amount, $id, $level, $timestamp, $sender_code_hash, $target_code_hash, $code_hash, $entrypoint, $parameter, $has_internals, $status, $select, $sort, $offset, $limit, $micheline, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTransactions'
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters transactions by any of the specified fields. Example: &#x60;anyof.sender.target&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;target&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all transactions associated with a specified account. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $initiator Filters transactions by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;target&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters transactions by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;target&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $target Filters transactions by target. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;sender&#x60;, &#x60;initiator&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $amount Filters transactions by amount (micro tez). (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters transactions by id. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters transactions by level. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filters transactions by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $sender_code_hash Filters by &#x60;senderCodeHash&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $target_code_hash Filters by &#x60;targetCodeHash&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $code_hash Filters by either &#x60;senderCodeHash&#x60; or &#x60;targetCodeHash&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsEntrypointParameter|null $entrypoint Filters transactions by entrypoint called on the target contract. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsParameterParameter|null $parameter Filters transactions by parameter value. Note, this query parameter supports the following format: &#x60;?parameter{.path?}{.mode?}&#x3D;...&#x60;,             so you can specify a path to a particular field to filter by, for example: &#x60;?parameter.token_id&#x3D;...&#x60; or &#x60;?parameter.sigs.0.ne&#x3D;...&#x60;.             Also, note that &#x60;.value&#x60; part must be omitted in the path, so, for example, filtering by &#x60;parameter.value.foo&#x60; must be specified as &#x60;?parameter.foo&#x3D;...&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetStakedParameter|null $has_internals Filters transactions by presence of internal operations. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters transactions by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts transactions by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;, &#x60;allocationFee&#x60;, &#x60;amount&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransactions'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTransactionsRequest(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $initiator = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $target = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $amount = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetIdParameter $sender_code_hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $target_code_hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $code_hash = null,
        ?\Tzkt\Model\AccountsGetOperationsEntrypointParameter $entrypoint = null,
        ?\Tzkt\Model\AccountsGetOperationsParameterParameter $parameter = null,
        ?\Tzkt\Model\AccountsGetStakedParameter $has_internals = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTransactions'][0]
    ): Request
    {



















        if ($limit !== null && $limit > 10000) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetTransactions, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetTransactions, must be bigger than or equal to 0.');
        }
        



        $resourcePath = '/v1/operations/transactions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $anyof,
            'anyof', // param base name
            '\Tzkt\Model\AnyOfParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $initiator,
            'initiator', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $target,
            'target', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $amount,
            'amount', // param base name
            '\Tzkt\Model\Int64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            '\Tzkt\Model\Int64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\TimestampParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender_code_hash,
            'senderCodeHash', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $target_code_hash,
            'targetCodeHash', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $code_hash,
            'codeHash', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $entrypoint,
            'entrypoint', // param base name
            '\Tzkt\Model\StringParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $parameter,
            'parameter', // param base name
            '\Tzkt\Model\JsonParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $has_internals,
            'hasInternals', // param base name
            '\Tzkt\Model\BoolParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            '\Tzkt\Model\OperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            '\Tzkt\Model\SelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            '\Tzkt\Model\SortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            '\Tzkt\Model\OffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $micheline,
            'micheline', // param base name
            '\Tzkt\Model\MichelineFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTransactionsCount
     *
     * Get transactions count
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters transactions by any of the specified fields. Example: &#x60;anyof.sender.target&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;target&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all transactions associated with a specified account. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $initiator Filters transactions by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;target&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters transactions by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;target&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $target Filters transactions by target. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;sender&#x60;, &#x60;initiator&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $amount Filters transactions by amount (micro tez). (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters transactions by level. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filters transactions by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsEntrypointParameter|null $entrypoint Filters transactions by entrypoint called on the target contract. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsParameterParameter|null $parameter Filters transactions by parameter value. Note, this query parameter supports the following format: &#x60;?parameter{.path?}{.mode?}&#x3D;...&#x60;,             so you can specify a path to a particular field to filter by, for example: &#x60;?parameter.token_id&#x3D;...&#x60; or &#x60;?parameter.sigs.0.ne&#x3D;...&#x60;.             Also, note that &#x60;.value&#x60; part must be omitted in the path, so, for example, filtering by &#x60;parameter.value.foo&#x60; must be specified as &#x60;?parameter.foo&#x3D;...&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters transactions by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransactionsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return int
     */
    public function operationsGetTransactionsCount(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $initiator = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $target = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $amount = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsEntrypointParameter $entrypoint = null,
        ?\Tzkt\Model\AccountsGetOperationsParameterParameter $parameter = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        string $contentType = self::contentTypes['operationsGetTransactionsCount'][0]
    ): int
    {
        list($response) = $this->operationsGetTransactionsCountWithHttpInfo($anyof, $initiator, $sender, $target, $amount, $level, $timestamp, $entrypoint, $parameter, $status, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTransactionsCountWithHttpInfo
     *
     * Get transactions count
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters transactions by any of the specified fields. Example: &#x60;anyof.sender.target&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;target&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all transactions associated with a specified account. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $initiator Filters transactions by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;target&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters transactions by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;target&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $target Filters transactions by target. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;sender&#x60;, &#x60;initiator&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $amount Filters transactions by amount (micro tez). (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters transactions by level. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filters transactions by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsEntrypointParameter|null $entrypoint Filters transactions by entrypoint called on the target contract. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsParameterParameter|null $parameter Filters transactions by parameter value. Note, this query parameter supports the following format: &#x60;?parameter{.path?}{.mode?}&#x3D;...&#x60;,             so you can specify a path to a particular field to filter by, for example: &#x60;?parameter.token_id&#x3D;...&#x60; or &#x60;?parameter.sigs.0.ne&#x3D;...&#x60;.             Also, note that &#x60;.value&#x60; part must be omitted in the path, so, for example, filtering by &#x60;parameter.value.foo&#x60; must be specified as &#x60;?parameter.foo&#x3D;...&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters transactions by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransactionsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTransactionsCountWithHttpInfo(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $initiator = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $target = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $amount = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsEntrypointParameter $entrypoint = null,
        ?\Tzkt\Model\AccountsGetOperationsParameterParameter $parameter = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        string $contentType = self::contentTypes['operationsGetTransactionsCount'][0]
    ): array
    {
        $request = $this->operationsGetTransactionsCountRequest($anyof, $initiator, $sender, $target, $amount, $level, $timestamp, $entrypoint, $parameter, $status, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('int', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'int';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTransactionsCountAsync
     *
     * Get transactions count
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters transactions by any of the specified fields. Example: &#x60;anyof.sender.target&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;target&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all transactions associated with a specified account. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $initiator Filters transactions by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;target&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters transactions by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;target&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $target Filters transactions by target. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;sender&#x60;, &#x60;initiator&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $amount Filters transactions by amount (micro tez). (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters transactions by level. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filters transactions by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsEntrypointParameter|null $entrypoint Filters transactions by entrypoint called on the target contract. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsParameterParameter|null $parameter Filters transactions by parameter value. Note, this query parameter supports the following format: &#x60;?parameter{.path?}{.mode?}&#x3D;...&#x60;,             so you can specify a path to a particular field to filter by, for example: &#x60;?parameter.token_id&#x3D;...&#x60; or &#x60;?parameter.sigs.0.ne&#x3D;...&#x60;.             Also, note that &#x60;.value&#x60; part must be omitted in the path, so, for example, filtering by &#x60;parameter.value.foo&#x60; must be specified as &#x60;?parameter.foo&#x3D;...&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters transactions by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransactionsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTransactionsCountAsync(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $initiator = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $target = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $amount = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsEntrypointParameter $entrypoint = null,
        ?\Tzkt\Model\AccountsGetOperationsParameterParameter $parameter = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        string $contentType = self::contentTypes['operationsGetTransactionsCount'][0]
    ): PromiseInterface
    {
        return $this->operationsGetTransactionsCountAsyncWithHttpInfo($anyof, $initiator, $sender, $target, $amount, $level, $timestamp, $entrypoint, $parameter, $status, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTransactionsCountAsyncWithHttpInfo
     *
     * Get transactions count
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters transactions by any of the specified fields. Example: &#x60;anyof.sender.target&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;target&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all transactions associated with a specified account. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $initiator Filters transactions by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;target&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters transactions by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;target&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $target Filters transactions by target. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;sender&#x60;, &#x60;initiator&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $amount Filters transactions by amount (micro tez). (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters transactions by level. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filters transactions by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsEntrypointParameter|null $entrypoint Filters transactions by entrypoint called on the target contract. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsParameterParameter|null $parameter Filters transactions by parameter value. Note, this query parameter supports the following format: &#x60;?parameter{.path?}{.mode?}&#x3D;...&#x60;,             so you can specify a path to a particular field to filter by, for example: &#x60;?parameter.token_id&#x3D;...&#x60; or &#x60;?parameter.sigs.0.ne&#x3D;...&#x60;.             Also, note that &#x60;.value&#x60; part must be omitted in the path, so, for example, filtering by &#x60;parameter.value.foo&#x60; must be specified as &#x60;?parameter.foo&#x3D;...&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters transactions by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransactionsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTransactionsCountAsyncWithHttpInfo(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $initiator = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $target = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $amount = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsEntrypointParameter $entrypoint = null,
        ?\Tzkt\Model\AccountsGetOperationsParameterParameter $parameter = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        string $contentType = self::contentTypes['operationsGetTransactionsCount'][0]
    ): PromiseInterface
    {
        $returnType = 'int';
        $request = $this->operationsGetTransactionsCountRequest($anyof, $initiator, $sender, $target, $amount, $level, $timestamp, $entrypoint, $parameter, $status, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTransactionsCount'
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters transactions by any of the specified fields. Example: &#x60;anyof.sender.target&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;target&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all transactions associated with a specified account. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $initiator Filters transactions by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;target&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters transactions by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;target&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $target Filters transactions by target. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;sender&#x60;, &#x60;initiator&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $amount Filters transactions by amount (micro tez). (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters transactions by level. (optional)
     * @param  \Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter|null $timestamp Filters transactions by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsEntrypointParameter|null $entrypoint Filters transactions by entrypoint called on the target contract. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsParameterParameter|null $parameter Filters transactions by parameter value. Note, this query parameter supports the following format: &#x60;?parameter{.path?}{.mode?}&#x3D;...&#x60;,             so you can specify a path to a particular field to filter by, for example: &#x60;?parameter.token_id&#x3D;...&#x60; or &#x60;?parameter.sigs.0.ne&#x3D;...&#x60;.             Also, note that &#x60;.value&#x60; part must be omitted in the path, so, for example, filtering by &#x60;parameter.value.foo&#x60; must be specified as &#x60;?parameter.foo&#x3D;...&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters transactions by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransactionsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTransactionsCountRequest(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $initiator = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $target = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $amount = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\BigMapsGetBigMapKeysFirstTimeParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsEntrypointParameter $entrypoint = null,
        ?\Tzkt\Model\AccountsGetOperationsParameterParameter $parameter = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        string $contentType = self::contentTypes['operationsGetTransactionsCount'][0]
    ): Request
    {












        $resourcePath = '/v1/operations/transactions/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $anyof,
            'anyof', // param base name
            '\Tzkt\Model\AnyOfParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $initiator,
            'initiator', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $target,
            'target', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $amount,
            'amount', // param base name
            '\Tzkt\Model\Int64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\TimestampParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $entrypoint,
            'entrypoint', // param base name
            '\Tzkt\Model\StringParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $parameter,
            'parameter', // param base name
            '\Tzkt\Model\JsonParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            '\Tzkt\Model\OperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTransferTicketOps
     *
     * Get transfer ticket
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters by any of the specified fields. Example: &#x60;anyof.sender.target&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;target&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $target Filters by target. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters by id. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $ticketer Filters by ticketer. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the content value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransferTicketOps'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\TransferTicketOperation[]
     */
    public function operationsGetTransferTicketOps(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $target = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $ticketer = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTransferTicketOps'][0]
    ): array
    {
        list($response) = $this->operationsGetTransferTicketOpsWithHttpInfo($anyof, $sender, $target, $id, $ticketer, $level, $timestamp, $status, $select, $sort, $offset, $limit, $micheline, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTransferTicketOpsWithHttpInfo
     *
     * Get transfer ticket
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters by any of the specified fields. Example: &#x60;anyof.sender.target&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;target&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $target Filters by target. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters by id. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $ticketer Filters by ticketer. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the content value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransferTicketOps'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\TransferTicketOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTransferTicketOpsWithHttpInfo(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $target = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $ticketer = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTransferTicketOps'][0]
    ): array
    {
        $request = $this->operationsGetTransferTicketOpsRequest($anyof, $sender, $target, $id, $ticketer, $level, $timestamp, $status, $select, $sort, $offset, $limit, $micheline, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\TransferTicketOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\TransferTicketOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\TransferTicketOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\TransferTicketOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\TransferTicketOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTransferTicketOpsAsync
     *
     * Get transfer ticket
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters by any of the specified fields. Example: &#x60;anyof.sender.target&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;target&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $target Filters by target. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters by id. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $ticketer Filters by ticketer. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the content value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransferTicketOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTransferTicketOpsAsync(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $target = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $ticketer = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTransferTicketOps'][0]
    ): PromiseInterface
    {
        return $this->operationsGetTransferTicketOpsAsyncWithHttpInfo($anyof, $sender, $target, $id, $ticketer, $level, $timestamp, $status, $select, $sort, $offset, $limit, $micheline, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTransferTicketOpsAsyncWithHttpInfo
     *
     * Get transfer ticket
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters by any of the specified fields. Example: &#x60;anyof.sender.target&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;target&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $target Filters by target. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters by id. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $ticketer Filters by ticketer. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the content value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransferTicketOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTransferTicketOpsAsyncWithHttpInfo(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $target = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $ticketer = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTransferTicketOps'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\TransferTicketOperation[]';
        $request = $this->operationsGetTransferTicketOpsRequest($anyof, $sender, $target, $id, $ticketer, $level, $timestamp, $status, $select, $sort, $offset, $limit, $micheline, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTransferTicketOps'
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters by any of the specified fields. Example: &#x60;anyof.sender.target&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;target&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $target Filters by target. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetBalanceParameter|null $id Filters by id. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $ticketer Filters by ticketer. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the content value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransferTicketOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTransferTicketOpsRequest(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $target = null,
        ?\Tzkt\Model\AccountsGetBalanceParameter $id = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $ticketer = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTransferTicketOps'][0]
    ): Request
    {












        if ($limit !== null && $limit > 10000) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetTransferTicketOps, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetTransferTicketOps, must be bigger than or equal to 0.');
        }
        



        $resourcePath = '/v1/operations/transfer_ticket';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $anyof,
            'anyof', // param base name
            '\Tzkt\Model\AnyOfParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $target,
            'target', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            '\Tzkt\Model\Int64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ticketer,
            'ticketer', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            '\Tzkt\Model\OperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            '\Tzkt\Model\SelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            '\Tzkt\Model\SortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            '\Tzkt\Model\OffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $micheline,
            'micheline', // param base name
            '\Tzkt\Model\MichelineFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTransferTicketOpsByHash
     *
     * Get transfer ticket by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the content value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransferTicketOpsByHash'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\TransferTicketOperation[]
     */
    public function operationsGetTransferTicketOpsByHash(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTransferTicketOpsByHash'][0]
    ): array
    {
        list($response) = $this->operationsGetTransferTicketOpsByHashWithHttpInfo($hash, $micheline, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTransferTicketOpsByHashWithHttpInfo
     *
     * Get transfer ticket by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the content value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransferTicketOpsByHash'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\TransferTicketOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTransferTicketOpsByHashWithHttpInfo(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTransferTicketOpsByHash'][0]
    ): array
    {
        $request = $this->operationsGetTransferTicketOpsByHashRequest($hash, $micheline, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\TransferTicketOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\TransferTicketOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\TransferTicketOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\TransferTicketOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\TransferTicketOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTransferTicketOpsByHashAsync
     *
     * Get transfer ticket by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the content value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransferTicketOpsByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTransferTicketOpsByHashAsync(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTransferTicketOpsByHash'][0]
    ): PromiseInterface
    {
        return $this->operationsGetTransferTicketOpsByHashAsyncWithHttpInfo($hash, $micheline, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTransferTicketOpsByHashAsyncWithHttpInfo
     *
     * Get transfer ticket by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the content value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransferTicketOpsByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTransferTicketOpsByHashAsyncWithHttpInfo(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTransferTicketOpsByHash'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\TransferTicketOperation[]';
        $request = $this->operationsGetTransferTicketOpsByHashRequest($hash, $micheline, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTransferTicketOpsByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsMichelineParameter|null $micheline Format of the content value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransferTicketOpsByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTransferTicketOpsByHashRequest(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsMichelineParameter $micheline = null,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTransferTicketOpsByHash'][0]
    ): Request
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetTransferTicketOpsByHash'
            );
        }




        $resourcePath = '/v1/operations/transfer_ticket/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $micheline,
            'micheline', // param base name
            '\Tzkt\Model\MichelineFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTransferTicketOpsCount
     *
     * Get transfer ticket count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransferTicketOpsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return int
     */
    public function operationsGetTransferTicketOpsCount(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetTransferTicketOpsCount'][0]
    ): int
    {
        list($response) = $this->operationsGetTransferTicketOpsCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTransferTicketOpsCountWithHttpInfo
     *
     * Get transfer ticket count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransferTicketOpsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTransferTicketOpsCountWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetTransferTicketOpsCount'][0]
    ): array
    {
        $request = $this->operationsGetTransferTicketOpsCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('int', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'int';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTransferTicketOpsCountAsync
     *
     * Get transfer ticket count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransferTicketOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTransferTicketOpsCountAsync(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetTransferTicketOpsCount'][0]
    ): PromiseInterface
    {
        return $this->operationsGetTransferTicketOpsCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTransferTicketOpsCountAsyncWithHttpInfo
     *
     * Get transfer ticket count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransferTicketOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTransferTicketOpsCountAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetTransferTicketOpsCount'][0]
    ): PromiseInterface
    {
        $returnType = 'int';
        $request = $this->operationsGetTransferTicketOpsCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTransferTicketOpsCount'
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransferTicketOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTransferTicketOpsCountRequest(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetTransferTicketOpsCount'][0]
    ): Request
    {




        $resourcePath = '/v1/operations/transfer_ticket/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTransferTicketStatus
     *
     * Get transfer ticket status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransferTicketStatus'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return bool
     */
    public function operationsGetTransferTicketStatus(
        string $hash,
        string $contentType = self::contentTypes['operationsGetTransferTicketStatus'][0]
    ): bool
    {
        list($response) = $this->operationsGetTransferTicketStatusWithHttpInfo($hash, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTransferTicketStatusWithHttpInfo
     *
     * Get transfer ticket status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransferTicketStatus'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of bool, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTransferTicketStatusWithHttpInfo(
        string $hash,
        string $contentType = self::contentTypes['operationsGetTransferTicketStatus'][0]
    ): array
    {
        $request = $this->operationsGetTransferTicketStatusRequest($hash, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('bool', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('bool' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'bool', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'bool';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'bool',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTransferTicketStatusAsync
     *
     * Get transfer ticket status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransferTicketStatus'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTransferTicketStatusAsync(
        string $hash,
        string $contentType = self::contentTypes['operationsGetTransferTicketStatus'][0]
    ): PromiseInterface
    {
        return $this->operationsGetTransferTicketStatusAsyncWithHttpInfo($hash, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTransferTicketStatusAsyncWithHttpInfo
     *
     * Get transfer ticket status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransferTicketStatus'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTransferTicketStatusAsyncWithHttpInfo(
        string $hash,
        string $contentType = self::contentTypes['operationsGetTransferTicketStatus'][0]
    ): PromiseInterface
    {
        $returnType = 'bool';
        $request = $this->operationsGetTransferTicketStatusRequest($hash, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTransferTicketStatus'
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransferTicketStatus'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTransferTicketStatusRequest(
        string $hash,
        string $contentType = self::contentTypes['operationsGetTransferTicketStatus'][0]
    ): Request
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetTransferTicketStatus'
            );
        }


        $resourcePath = '/v1/operations/transfer_ticket/{hash}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupCommitOps
     *
     * Get tx rollup commit
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupCommitOps'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\TxRollupCommitOperation[]
     */
    public function operationsGetTxRollupCommitOps(
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupCommitOps'][0]
    ): array
    {
        list($response) = $this->operationsGetTxRollupCommitOpsWithHttpInfo($sender, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupCommitOpsWithHttpInfo
     *
     * Get tx rollup commit
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupCommitOps'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\TxRollupCommitOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupCommitOpsWithHttpInfo(
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupCommitOps'][0]
    ): array
    {
        $request = $this->operationsGetTxRollupCommitOpsRequest($sender, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\TxRollupCommitOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\TxRollupCommitOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\TxRollupCommitOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\TxRollupCommitOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\TxRollupCommitOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupCommitOpsAsync
     *
     * Get tx rollup commit
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupCommitOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupCommitOpsAsync(
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupCommitOps'][0]
    ): PromiseInterface
    {
        return $this->operationsGetTxRollupCommitOpsAsyncWithHttpInfo($sender, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupCommitOpsAsyncWithHttpInfo
     *
     * Get tx rollup commit
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupCommitOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupCommitOpsAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupCommitOps'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\TxRollupCommitOperation[]';
        $request = $this->operationsGetTxRollupCommitOpsRequest($sender, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupCommitOps'
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupCommitOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupCommitOpsRequest(
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupCommitOps'][0]
    ): Request
    {









        if ($limit !== null && $limit > 10000) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetTxRollupCommitOps, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetTxRollupCommitOps, must be bigger than or equal to 0.');
        }
        


        $resourcePath = '/v1/operations/tx_rollup_commit';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rollup,
            'rollup', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            '\Tzkt\Model\OperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            '\Tzkt\Model\SelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            '\Tzkt\Model\SortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            '\Tzkt\Model\OffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupCommitOpsByHash
     *
     * Get tx rollup commit by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupCommitOpsByHash'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\TxRollupCommitOperation[]
     */
    public function operationsGetTxRollupCommitOpsByHash(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupCommitOpsByHash'][0]
    ): array
    {
        list($response) = $this->operationsGetTxRollupCommitOpsByHashWithHttpInfo($hash, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupCommitOpsByHashWithHttpInfo
     *
     * Get tx rollup commit by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupCommitOpsByHash'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\TxRollupCommitOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupCommitOpsByHashWithHttpInfo(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupCommitOpsByHash'][0]
    ): array
    {
        $request = $this->operationsGetTxRollupCommitOpsByHashRequest($hash, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\TxRollupCommitOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\TxRollupCommitOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\TxRollupCommitOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\TxRollupCommitOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\TxRollupCommitOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupCommitOpsByHashAsync
     *
     * Get tx rollup commit by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupCommitOpsByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupCommitOpsByHashAsync(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupCommitOpsByHash'][0]
    ): PromiseInterface
    {
        return $this->operationsGetTxRollupCommitOpsByHashAsyncWithHttpInfo($hash, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupCommitOpsByHashAsyncWithHttpInfo
     *
     * Get tx rollup commit by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupCommitOpsByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupCommitOpsByHashAsyncWithHttpInfo(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupCommitOpsByHash'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\TxRollupCommitOperation[]';
        $request = $this->operationsGetTxRollupCommitOpsByHashRequest($hash, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupCommitOpsByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupCommitOpsByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupCommitOpsByHashRequest(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupCommitOpsByHash'][0]
    ): Request
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetTxRollupCommitOpsByHash'
            );
        }



        $resourcePath = '/v1/operations/tx_rollup_commit/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupCommitOpsCount
     *
     * Get tx rollup commit count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupCommitOpsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return int
     */
    public function operationsGetTxRollupCommitOpsCount(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetTxRollupCommitOpsCount'][0]
    ): int
    {
        list($response) = $this->operationsGetTxRollupCommitOpsCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupCommitOpsCountWithHttpInfo
     *
     * Get tx rollup commit count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupCommitOpsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupCommitOpsCountWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetTxRollupCommitOpsCount'][0]
    ): array
    {
        $request = $this->operationsGetTxRollupCommitOpsCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('int', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'int';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupCommitOpsCountAsync
     *
     * Get tx rollup commit count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupCommitOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupCommitOpsCountAsync(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetTxRollupCommitOpsCount'][0]
    ): PromiseInterface
    {
        return $this->operationsGetTxRollupCommitOpsCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupCommitOpsCountAsyncWithHttpInfo
     *
     * Get tx rollup commit count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupCommitOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupCommitOpsCountAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetTxRollupCommitOpsCount'][0]
    ): PromiseInterface
    {
        $returnType = 'int';
        $request = $this->operationsGetTxRollupCommitOpsCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupCommitOpsCount'
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupCommitOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupCommitOpsCountRequest(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetTxRollupCommitOpsCount'][0]
    ): Request
    {




        $resourcePath = '/v1/operations/tx_rollup_commit/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupCommitStatus
     *
     * Get tx rollup commit status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupCommitStatus'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return bool
     */
    public function operationsGetTxRollupCommitStatus(
        string $hash,
        string $contentType = self::contentTypes['operationsGetTxRollupCommitStatus'][0]
    ): bool
    {
        list($response) = $this->operationsGetTxRollupCommitStatusWithHttpInfo($hash, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupCommitStatusWithHttpInfo
     *
     * Get tx rollup commit status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupCommitStatus'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of bool, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupCommitStatusWithHttpInfo(
        string $hash,
        string $contentType = self::contentTypes['operationsGetTxRollupCommitStatus'][0]
    ): array
    {
        $request = $this->operationsGetTxRollupCommitStatusRequest($hash, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('bool', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('bool' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'bool', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'bool';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'bool',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupCommitStatusAsync
     *
     * Get tx rollup commit status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupCommitStatus'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupCommitStatusAsync(
        string $hash,
        string $contentType = self::contentTypes['operationsGetTxRollupCommitStatus'][0]
    ): PromiseInterface
    {
        return $this->operationsGetTxRollupCommitStatusAsyncWithHttpInfo($hash, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupCommitStatusAsyncWithHttpInfo
     *
     * Get tx rollup commit status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupCommitStatus'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupCommitStatusAsyncWithHttpInfo(
        string $hash,
        string $contentType = self::contentTypes['operationsGetTxRollupCommitStatus'][0]
    ): PromiseInterface
    {
        $returnType = 'bool';
        $request = $this->operationsGetTxRollupCommitStatusRequest($hash, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupCommitStatus'
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupCommitStatus'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupCommitStatusRequest(
        string $hash,
        string $contentType = self::contentTypes['operationsGetTxRollupCommitStatus'][0]
    ): Request
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetTxRollupCommitStatus'
            );
        }


        $resourcePath = '/v1/operations/tx_rollup_commit/{hash}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupDispatchTicketsOps
     *
     * Get tx rollup dispatch tickets
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupDispatchTicketsOps'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\TxRollupDispatchTicketsOperation[]
     */
    public function operationsGetTxRollupDispatchTicketsOps(
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupDispatchTicketsOps'][0]
    ): array
    {
        list($response) = $this->operationsGetTxRollupDispatchTicketsOpsWithHttpInfo($sender, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupDispatchTicketsOpsWithHttpInfo
     *
     * Get tx rollup dispatch tickets
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupDispatchTicketsOps'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\TxRollupDispatchTicketsOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupDispatchTicketsOpsWithHttpInfo(
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupDispatchTicketsOps'][0]
    ): array
    {
        $request = $this->operationsGetTxRollupDispatchTicketsOpsRequest($sender, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\TxRollupDispatchTicketsOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\TxRollupDispatchTicketsOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\TxRollupDispatchTicketsOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\TxRollupDispatchTicketsOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\TxRollupDispatchTicketsOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupDispatchTicketsOpsAsync
     *
     * Get tx rollup dispatch tickets
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupDispatchTicketsOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupDispatchTicketsOpsAsync(
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupDispatchTicketsOps'][0]
    ): PromiseInterface
    {
        return $this->operationsGetTxRollupDispatchTicketsOpsAsyncWithHttpInfo($sender, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupDispatchTicketsOpsAsyncWithHttpInfo
     *
     * Get tx rollup dispatch tickets
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupDispatchTicketsOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupDispatchTicketsOpsAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupDispatchTicketsOps'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\TxRollupDispatchTicketsOperation[]';
        $request = $this->operationsGetTxRollupDispatchTicketsOpsRequest($sender, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupDispatchTicketsOps'
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupDispatchTicketsOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupDispatchTicketsOpsRequest(
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupDispatchTicketsOps'][0]
    ): Request
    {









        if ($limit !== null && $limit > 10000) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetTxRollupDispatchTicketsOps, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetTxRollupDispatchTicketsOps, must be bigger than or equal to 0.');
        }
        


        $resourcePath = '/v1/operations/tx_rollup_dispatch_tickets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rollup,
            'rollup', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            '\Tzkt\Model\OperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            '\Tzkt\Model\SelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            '\Tzkt\Model\SortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            '\Tzkt\Model\OffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupDispatchTicketsOpsByHash
     *
     * Get tx rollup dispatch tickets by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupDispatchTicketsOpsByHash'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\TxRollupDispatchTicketsOperation[]
     */
    public function operationsGetTxRollupDispatchTicketsOpsByHash(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupDispatchTicketsOpsByHash'][0]
    ): array
    {
        list($response) = $this->operationsGetTxRollupDispatchTicketsOpsByHashWithHttpInfo($hash, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupDispatchTicketsOpsByHashWithHttpInfo
     *
     * Get tx rollup dispatch tickets by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupDispatchTicketsOpsByHash'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\TxRollupDispatchTicketsOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupDispatchTicketsOpsByHashWithHttpInfo(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupDispatchTicketsOpsByHash'][0]
    ): array
    {
        $request = $this->operationsGetTxRollupDispatchTicketsOpsByHashRequest($hash, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\TxRollupDispatchTicketsOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\TxRollupDispatchTicketsOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\TxRollupDispatchTicketsOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\TxRollupDispatchTicketsOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\TxRollupDispatchTicketsOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupDispatchTicketsOpsByHashAsync
     *
     * Get tx rollup dispatch tickets by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupDispatchTicketsOpsByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupDispatchTicketsOpsByHashAsync(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupDispatchTicketsOpsByHash'][0]
    ): PromiseInterface
    {
        return $this->operationsGetTxRollupDispatchTicketsOpsByHashAsyncWithHttpInfo($hash, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupDispatchTicketsOpsByHashAsyncWithHttpInfo
     *
     * Get tx rollup dispatch tickets by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupDispatchTicketsOpsByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupDispatchTicketsOpsByHashAsyncWithHttpInfo(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupDispatchTicketsOpsByHash'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\TxRollupDispatchTicketsOperation[]';
        $request = $this->operationsGetTxRollupDispatchTicketsOpsByHashRequest($hash, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupDispatchTicketsOpsByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupDispatchTicketsOpsByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupDispatchTicketsOpsByHashRequest(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupDispatchTicketsOpsByHash'][0]
    ): Request
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetTxRollupDispatchTicketsOpsByHash'
            );
        }



        $resourcePath = '/v1/operations/tx_rollup_dispatch_tickets/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupDispatchTicketsOpsCount
     *
     * Get tx rollup dispatch tickets count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupDispatchTicketsOpsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return int
     */
    public function operationsGetTxRollupDispatchTicketsOpsCount(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetTxRollupDispatchTicketsOpsCount'][0]
    ): int
    {
        list($response) = $this->operationsGetTxRollupDispatchTicketsOpsCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupDispatchTicketsOpsCountWithHttpInfo
     *
     * Get tx rollup dispatch tickets count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupDispatchTicketsOpsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupDispatchTicketsOpsCountWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetTxRollupDispatchTicketsOpsCount'][0]
    ): array
    {
        $request = $this->operationsGetTxRollupDispatchTicketsOpsCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('int', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'int';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupDispatchTicketsOpsCountAsync
     *
     * Get tx rollup dispatch tickets count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupDispatchTicketsOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupDispatchTicketsOpsCountAsync(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetTxRollupDispatchTicketsOpsCount'][0]
    ): PromiseInterface
    {
        return $this->operationsGetTxRollupDispatchTicketsOpsCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupDispatchTicketsOpsCountAsyncWithHttpInfo
     *
     * Get tx rollup dispatch tickets count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupDispatchTicketsOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupDispatchTicketsOpsCountAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetTxRollupDispatchTicketsOpsCount'][0]
    ): PromiseInterface
    {
        $returnType = 'int';
        $request = $this->operationsGetTxRollupDispatchTicketsOpsCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupDispatchTicketsOpsCount'
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupDispatchTicketsOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupDispatchTicketsOpsCountRequest(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetTxRollupDispatchTicketsOpsCount'][0]
    ): Request
    {




        $resourcePath = '/v1/operations/tx_rollup_dispatch_tickets/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupDispatchTicketsStatus
     *
     * Get tx rollup dispatch tickets status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupDispatchTicketsStatus'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return bool
     */
    public function operationsGetTxRollupDispatchTicketsStatus(
        string $hash,
        string $contentType = self::contentTypes['operationsGetTxRollupDispatchTicketsStatus'][0]
    ): bool
    {
        list($response) = $this->operationsGetTxRollupDispatchTicketsStatusWithHttpInfo($hash, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupDispatchTicketsStatusWithHttpInfo
     *
     * Get tx rollup dispatch tickets status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupDispatchTicketsStatus'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of bool, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupDispatchTicketsStatusWithHttpInfo(
        string $hash,
        string $contentType = self::contentTypes['operationsGetTxRollupDispatchTicketsStatus'][0]
    ): array
    {
        $request = $this->operationsGetTxRollupDispatchTicketsStatusRequest($hash, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('bool', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('bool' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'bool', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'bool';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'bool',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupDispatchTicketsStatusAsync
     *
     * Get tx rollup dispatch tickets status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupDispatchTicketsStatus'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupDispatchTicketsStatusAsync(
        string $hash,
        string $contentType = self::contentTypes['operationsGetTxRollupDispatchTicketsStatus'][0]
    ): PromiseInterface
    {
        return $this->operationsGetTxRollupDispatchTicketsStatusAsyncWithHttpInfo($hash, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupDispatchTicketsStatusAsyncWithHttpInfo
     *
     * Get tx rollup dispatch tickets status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupDispatchTicketsStatus'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupDispatchTicketsStatusAsyncWithHttpInfo(
        string $hash,
        string $contentType = self::contentTypes['operationsGetTxRollupDispatchTicketsStatus'][0]
    ): PromiseInterface
    {
        $returnType = 'bool';
        $request = $this->operationsGetTxRollupDispatchTicketsStatusRequest($hash, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupDispatchTicketsStatus'
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupDispatchTicketsStatus'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupDispatchTicketsStatusRequest(
        string $hash,
        string $contentType = self::contentTypes['operationsGetTxRollupDispatchTicketsStatus'][0]
    ): Request
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetTxRollupDispatchTicketsStatus'
            );
        }


        $resourcePath = '/v1/operations/tx_rollup_dispatch_tickets/{hash}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupFinalizeCommitmentOps
     *
     * Get tx rollup finalize commitment
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupFinalizeCommitmentOps'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\TxRollupFinalizeCommitmentOperation[]
     */
    public function operationsGetTxRollupFinalizeCommitmentOps(
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupFinalizeCommitmentOps'][0]
    ): array
    {
        list($response) = $this->operationsGetTxRollupFinalizeCommitmentOpsWithHttpInfo($sender, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupFinalizeCommitmentOpsWithHttpInfo
     *
     * Get tx rollup finalize commitment
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupFinalizeCommitmentOps'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\TxRollupFinalizeCommitmentOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupFinalizeCommitmentOpsWithHttpInfo(
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupFinalizeCommitmentOps'][0]
    ): array
    {
        $request = $this->operationsGetTxRollupFinalizeCommitmentOpsRequest($sender, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\TxRollupFinalizeCommitmentOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\TxRollupFinalizeCommitmentOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\TxRollupFinalizeCommitmentOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\TxRollupFinalizeCommitmentOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\TxRollupFinalizeCommitmentOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupFinalizeCommitmentOpsAsync
     *
     * Get tx rollup finalize commitment
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupFinalizeCommitmentOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupFinalizeCommitmentOpsAsync(
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupFinalizeCommitmentOps'][0]
    ): PromiseInterface
    {
        return $this->operationsGetTxRollupFinalizeCommitmentOpsAsyncWithHttpInfo($sender, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupFinalizeCommitmentOpsAsyncWithHttpInfo
     *
     * Get tx rollup finalize commitment
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupFinalizeCommitmentOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupFinalizeCommitmentOpsAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupFinalizeCommitmentOps'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\TxRollupFinalizeCommitmentOperation[]';
        $request = $this->operationsGetTxRollupFinalizeCommitmentOpsRequest($sender, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupFinalizeCommitmentOps'
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupFinalizeCommitmentOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupFinalizeCommitmentOpsRequest(
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupFinalizeCommitmentOps'][0]
    ): Request
    {









        if ($limit !== null && $limit > 10000) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetTxRollupFinalizeCommitmentOps, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetTxRollupFinalizeCommitmentOps, must be bigger than or equal to 0.');
        }
        


        $resourcePath = '/v1/operations/tx_rollup_finalize_commitment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rollup,
            'rollup', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            '\Tzkt\Model\OperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            '\Tzkt\Model\SelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            '\Tzkt\Model\SortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            '\Tzkt\Model\OffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupFinalizeCommitmentOpsByHash
     *
     * Get tx rollup finalize commitment by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupFinalizeCommitmentOpsByHash'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\TxRollupFinalizeCommitmentOperation[]
     */
    public function operationsGetTxRollupFinalizeCommitmentOpsByHash(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupFinalizeCommitmentOpsByHash'][0]
    ): array
    {
        list($response) = $this->operationsGetTxRollupFinalizeCommitmentOpsByHashWithHttpInfo($hash, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupFinalizeCommitmentOpsByHashWithHttpInfo
     *
     * Get tx rollup finalize commitment by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupFinalizeCommitmentOpsByHash'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\TxRollupFinalizeCommitmentOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupFinalizeCommitmentOpsByHashWithHttpInfo(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupFinalizeCommitmentOpsByHash'][0]
    ): array
    {
        $request = $this->operationsGetTxRollupFinalizeCommitmentOpsByHashRequest($hash, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\TxRollupFinalizeCommitmentOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\TxRollupFinalizeCommitmentOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\TxRollupFinalizeCommitmentOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\TxRollupFinalizeCommitmentOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\TxRollupFinalizeCommitmentOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupFinalizeCommitmentOpsByHashAsync
     *
     * Get tx rollup finalize commitment by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupFinalizeCommitmentOpsByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupFinalizeCommitmentOpsByHashAsync(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupFinalizeCommitmentOpsByHash'][0]
    ): PromiseInterface
    {
        return $this->operationsGetTxRollupFinalizeCommitmentOpsByHashAsyncWithHttpInfo($hash, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupFinalizeCommitmentOpsByHashAsyncWithHttpInfo
     *
     * Get tx rollup finalize commitment by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupFinalizeCommitmentOpsByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupFinalizeCommitmentOpsByHashAsyncWithHttpInfo(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupFinalizeCommitmentOpsByHash'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\TxRollupFinalizeCommitmentOperation[]';
        $request = $this->operationsGetTxRollupFinalizeCommitmentOpsByHashRequest($hash, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupFinalizeCommitmentOpsByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupFinalizeCommitmentOpsByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupFinalizeCommitmentOpsByHashRequest(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupFinalizeCommitmentOpsByHash'][0]
    ): Request
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetTxRollupFinalizeCommitmentOpsByHash'
            );
        }



        $resourcePath = '/v1/operations/tx_rollup_finalize_commitment/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupFinalizeCommitmentOpsCount
     *
     * Get tx rollup finalize commitment count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupFinalizeCommitmentOpsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return int
     */
    public function operationsGetTxRollupFinalizeCommitmentOpsCount(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetTxRollupFinalizeCommitmentOpsCount'][0]
    ): int
    {
        list($response) = $this->operationsGetTxRollupFinalizeCommitmentOpsCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupFinalizeCommitmentOpsCountWithHttpInfo
     *
     * Get tx rollup finalize commitment count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupFinalizeCommitmentOpsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupFinalizeCommitmentOpsCountWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetTxRollupFinalizeCommitmentOpsCount'][0]
    ): array
    {
        $request = $this->operationsGetTxRollupFinalizeCommitmentOpsCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('int', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'int';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupFinalizeCommitmentOpsCountAsync
     *
     * Get tx rollup finalize commitment count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupFinalizeCommitmentOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupFinalizeCommitmentOpsCountAsync(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetTxRollupFinalizeCommitmentOpsCount'][0]
    ): PromiseInterface
    {
        return $this->operationsGetTxRollupFinalizeCommitmentOpsCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupFinalizeCommitmentOpsCountAsyncWithHttpInfo
     *
     * Get tx rollup finalize commitment count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupFinalizeCommitmentOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupFinalizeCommitmentOpsCountAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetTxRollupFinalizeCommitmentOpsCount'][0]
    ): PromiseInterface
    {
        $returnType = 'int';
        $request = $this->operationsGetTxRollupFinalizeCommitmentOpsCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupFinalizeCommitmentOpsCount'
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupFinalizeCommitmentOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupFinalizeCommitmentOpsCountRequest(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetTxRollupFinalizeCommitmentOpsCount'][0]
    ): Request
    {




        $resourcePath = '/v1/operations/tx_rollup_finalize_commitment/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupFinalizeCommitmentStatus
     *
     * Get tx rollup finalize commitment status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupFinalizeCommitmentStatus'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return bool
     */
    public function operationsGetTxRollupFinalizeCommitmentStatus(
        string $hash,
        string $contentType = self::contentTypes['operationsGetTxRollupFinalizeCommitmentStatus'][0]
    ): bool
    {
        list($response) = $this->operationsGetTxRollupFinalizeCommitmentStatusWithHttpInfo($hash, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupFinalizeCommitmentStatusWithHttpInfo
     *
     * Get tx rollup finalize commitment status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupFinalizeCommitmentStatus'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of bool, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupFinalizeCommitmentStatusWithHttpInfo(
        string $hash,
        string $contentType = self::contentTypes['operationsGetTxRollupFinalizeCommitmentStatus'][0]
    ): array
    {
        $request = $this->operationsGetTxRollupFinalizeCommitmentStatusRequest($hash, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('bool', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('bool' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'bool', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'bool';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'bool',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupFinalizeCommitmentStatusAsync
     *
     * Get tx rollup finalize commitment status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupFinalizeCommitmentStatus'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupFinalizeCommitmentStatusAsync(
        string $hash,
        string $contentType = self::contentTypes['operationsGetTxRollupFinalizeCommitmentStatus'][0]
    ): PromiseInterface
    {
        return $this->operationsGetTxRollupFinalizeCommitmentStatusAsyncWithHttpInfo($hash, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupFinalizeCommitmentStatusAsyncWithHttpInfo
     *
     * Get tx rollup finalize commitment status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupFinalizeCommitmentStatus'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupFinalizeCommitmentStatusAsyncWithHttpInfo(
        string $hash,
        string $contentType = self::contentTypes['operationsGetTxRollupFinalizeCommitmentStatus'][0]
    ): PromiseInterface
    {
        $returnType = 'bool';
        $request = $this->operationsGetTxRollupFinalizeCommitmentStatusRequest($hash, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupFinalizeCommitmentStatus'
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupFinalizeCommitmentStatus'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupFinalizeCommitmentStatusRequest(
        string $hash,
        string $contentType = self::contentTypes['operationsGetTxRollupFinalizeCommitmentStatus'][0]
    ): Request
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetTxRollupFinalizeCommitmentStatus'
            );
        }


        $resourcePath = '/v1/operations/tx_rollup_finalize_commitment/{hash}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupOriginationOps
     *
     * Get tx rollup origination
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupOriginationOps'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\TxRollupOriginationOperation[]
     */
    public function operationsGetTxRollupOriginationOps(
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupOriginationOps'][0]
    ): array
    {
        list($response) = $this->operationsGetTxRollupOriginationOpsWithHttpInfo($sender, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupOriginationOpsWithHttpInfo
     *
     * Get tx rollup origination
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupOriginationOps'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\TxRollupOriginationOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupOriginationOpsWithHttpInfo(
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupOriginationOps'][0]
    ): array
    {
        $request = $this->operationsGetTxRollupOriginationOpsRequest($sender, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\TxRollupOriginationOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\TxRollupOriginationOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\TxRollupOriginationOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\TxRollupOriginationOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\TxRollupOriginationOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupOriginationOpsAsync
     *
     * Get tx rollup origination
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupOriginationOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupOriginationOpsAsync(
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupOriginationOps'][0]
    ): PromiseInterface
    {
        return $this->operationsGetTxRollupOriginationOpsAsyncWithHttpInfo($sender, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupOriginationOpsAsyncWithHttpInfo
     *
     * Get tx rollup origination
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupOriginationOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupOriginationOpsAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupOriginationOps'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\TxRollupOriginationOperation[]';
        $request = $this->operationsGetTxRollupOriginationOpsRequest($sender, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupOriginationOps'
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupOriginationOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupOriginationOpsRequest(
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupOriginationOps'][0]
    ): Request
    {









        if ($limit !== null && $limit > 10000) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetTxRollupOriginationOps, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetTxRollupOriginationOps, must be bigger than or equal to 0.');
        }
        


        $resourcePath = '/v1/operations/tx_rollup_origination';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rollup,
            'rollup', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            '\Tzkt\Model\OperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            '\Tzkt\Model\SelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            '\Tzkt\Model\SortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            '\Tzkt\Model\OffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupOriginationOpsByHash
     *
     * Get tx rollup origination by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupOriginationOpsByHash'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\TxRollupOriginationOperation[]
     */
    public function operationsGetTxRollupOriginationOpsByHash(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupOriginationOpsByHash'][0]
    ): array
    {
        list($response) = $this->operationsGetTxRollupOriginationOpsByHashWithHttpInfo($hash, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupOriginationOpsByHashWithHttpInfo
     *
     * Get tx rollup origination by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupOriginationOpsByHash'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\TxRollupOriginationOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupOriginationOpsByHashWithHttpInfo(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupOriginationOpsByHash'][0]
    ): array
    {
        $request = $this->operationsGetTxRollupOriginationOpsByHashRequest($hash, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\TxRollupOriginationOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\TxRollupOriginationOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\TxRollupOriginationOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\TxRollupOriginationOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\TxRollupOriginationOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupOriginationOpsByHashAsync
     *
     * Get tx rollup origination by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupOriginationOpsByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupOriginationOpsByHashAsync(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupOriginationOpsByHash'][0]
    ): PromiseInterface
    {
        return $this->operationsGetTxRollupOriginationOpsByHashAsyncWithHttpInfo($hash, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupOriginationOpsByHashAsyncWithHttpInfo
     *
     * Get tx rollup origination by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupOriginationOpsByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupOriginationOpsByHashAsyncWithHttpInfo(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupOriginationOpsByHash'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\TxRollupOriginationOperation[]';
        $request = $this->operationsGetTxRollupOriginationOpsByHashRequest($hash, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupOriginationOpsByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupOriginationOpsByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupOriginationOpsByHashRequest(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupOriginationOpsByHash'][0]
    ): Request
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetTxRollupOriginationOpsByHash'
            );
        }



        $resourcePath = '/v1/operations/tx_rollup_origination/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupOriginationOpsCount
     *
     * Get tx rollup origination count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupOriginationOpsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return int
     */
    public function operationsGetTxRollupOriginationOpsCount(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetTxRollupOriginationOpsCount'][0]
    ): int
    {
        list($response) = $this->operationsGetTxRollupOriginationOpsCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupOriginationOpsCountWithHttpInfo
     *
     * Get tx rollup origination count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupOriginationOpsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupOriginationOpsCountWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetTxRollupOriginationOpsCount'][0]
    ): array
    {
        $request = $this->operationsGetTxRollupOriginationOpsCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('int', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'int';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupOriginationOpsCountAsync
     *
     * Get tx rollup origination count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupOriginationOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupOriginationOpsCountAsync(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetTxRollupOriginationOpsCount'][0]
    ): PromiseInterface
    {
        return $this->operationsGetTxRollupOriginationOpsCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupOriginationOpsCountAsyncWithHttpInfo
     *
     * Get tx rollup origination count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupOriginationOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupOriginationOpsCountAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetTxRollupOriginationOpsCount'][0]
    ): PromiseInterface
    {
        $returnType = 'int';
        $request = $this->operationsGetTxRollupOriginationOpsCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupOriginationOpsCount'
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupOriginationOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupOriginationOpsCountRequest(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetTxRollupOriginationOpsCount'][0]
    ): Request
    {




        $resourcePath = '/v1/operations/tx_rollup_origination/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupOriginationStatus
     *
     * Get tx rollup origination status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupOriginationStatus'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return bool
     */
    public function operationsGetTxRollupOriginationStatus(
        string $hash,
        string $contentType = self::contentTypes['operationsGetTxRollupOriginationStatus'][0]
    ): bool
    {
        list($response) = $this->operationsGetTxRollupOriginationStatusWithHttpInfo($hash, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupOriginationStatusWithHttpInfo
     *
     * Get tx rollup origination status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupOriginationStatus'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of bool, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupOriginationStatusWithHttpInfo(
        string $hash,
        string $contentType = self::contentTypes['operationsGetTxRollupOriginationStatus'][0]
    ): array
    {
        $request = $this->operationsGetTxRollupOriginationStatusRequest($hash, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('bool', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('bool' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'bool', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'bool';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'bool',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupOriginationStatusAsync
     *
     * Get tx rollup origination status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupOriginationStatus'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupOriginationStatusAsync(
        string $hash,
        string $contentType = self::contentTypes['operationsGetTxRollupOriginationStatus'][0]
    ): PromiseInterface
    {
        return $this->operationsGetTxRollupOriginationStatusAsyncWithHttpInfo($hash, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupOriginationStatusAsyncWithHttpInfo
     *
     * Get tx rollup origination status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupOriginationStatus'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupOriginationStatusAsyncWithHttpInfo(
        string $hash,
        string $contentType = self::contentTypes['operationsGetTxRollupOriginationStatus'][0]
    ): PromiseInterface
    {
        $returnType = 'bool';
        $request = $this->operationsGetTxRollupOriginationStatusRequest($hash, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupOriginationStatus'
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupOriginationStatus'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupOriginationStatusRequest(
        string $hash,
        string $contentType = self::contentTypes['operationsGetTxRollupOriginationStatus'][0]
    ): Request
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetTxRollupOriginationStatus'
            );
        }


        $resourcePath = '/v1/operations/tx_rollup_origination/{hash}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupRejectionOps
     *
     * Get tx rollup rejection
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters by any of the specified fields. Example: &#x60;anyof.sender.committer&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;committer&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $committer Filters by committer. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRejectionOps'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\TxRollupRejectionOperation[]
     */
    public function operationsGetTxRollupRejectionOps(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $committer = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupRejectionOps'][0]
    ): array
    {
        list($response) = $this->operationsGetTxRollupRejectionOpsWithHttpInfo($anyof, $sender, $committer, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupRejectionOpsWithHttpInfo
     *
     * Get tx rollup rejection
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters by any of the specified fields. Example: &#x60;anyof.sender.committer&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;committer&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $committer Filters by committer. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRejectionOps'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\TxRollupRejectionOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupRejectionOpsWithHttpInfo(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $committer = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupRejectionOps'][0]
    ): array
    {
        $request = $this->operationsGetTxRollupRejectionOpsRequest($anyof, $sender, $committer, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\TxRollupRejectionOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\TxRollupRejectionOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\TxRollupRejectionOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\TxRollupRejectionOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\TxRollupRejectionOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupRejectionOpsAsync
     *
     * Get tx rollup rejection
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters by any of the specified fields. Example: &#x60;anyof.sender.committer&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;committer&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $committer Filters by committer. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRejectionOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupRejectionOpsAsync(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $committer = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupRejectionOps'][0]
    ): PromiseInterface
    {
        return $this->operationsGetTxRollupRejectionOpsAsyncWithHttpInfo($anyof, $sender, $committer, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupRejectionOpsAsyncWithHttpInfo
     *
     * Get tx rollup rejection
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters by any of the specified fields. Example: &#x60;anyof.sender.committer&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;committer&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $committer Filters by committer. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRejectionOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupRejectionOpsAsyncWithHttpInfo(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $committer = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupRejectionOps'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\TxRollupRejectionOperation[]';
        $request = $this->operationsGetTxRollupRejectionOpsRequest($anyof, $sender, $committer, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupRejectionOps'
     *
     * @param  \Tzkt\Model\BlocksGetAnyofParameter|null $anyof Filters by any of the specified fields. Example: &#x60;anyof.sender.committer&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;committer&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $committer Filters by committer. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRejectionOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupRejectionOpsRequest(
        ?\Tzkt\Model\BlocksGetAnyofParameter $anyof = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $committer = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupRejectionOps'][0]
    ): Request
    {











        if ($limit !== null && $limit > 10000) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetTxRollupRejectionOps, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetTxRollupRejectionOps, must be bigger than or equal to 0.');
        }
        


        $resourcePath = '/v1/operations/tx_rollup_rejection';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $anyof,
            'anyof', // param base name
            '\Tzkt\Model\AnyOfParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $committer,
            'committer', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rollup,
            'rollup', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            '\Tzkt\Model\OperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            '\Tzkt\Model\SelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            '\Tzkt\Model\SortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            '\Tzkt\Model\OffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupRejectionOpsByHash
     *
     * Get tx rollup rejection by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRejectionOpsByHash'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\TxRollupRejectionOperation[]
     */
    public function operationsGetTxRollupRejectionOpsByHash(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupRejectionOpsByHash'][0]
    ): array
    {
        list($response) = $this->operationsGetTxRollupRejectionOpsByHashWithHttpInfo($hash, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupRejectionOpsByHashWithHttpInfo
     *
     * Get tx rollup rejection by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRejectionOpsByHash'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\TxRollupRejectionOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupRejectionOpsByHashWithHttpInfo(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupRejectionOpsByHash'][0]
    ): array
    {
        $request = $this->operationsGetTxRollupRejectionOpsByHashRequest($hash, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\TxRollupRejectionOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\TxRollupRejectionOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\TxRollupRejectionOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\TxRollupRejectionOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\TxRollupRejectionOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupRejectionOpsByHashAsync
     *
     * Get tx rollup rejection by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRejectionOpsByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupRejectionOpsByHashAsync(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupRejectionOpsByHash'][0]
    ): PromiseInterface
    {
        return $this->operationsGetTxRollupRejectionOpsByHashAsyncWithHttpInfo($hash, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupRejectionOpsByHashAsyncWithHttpInfo
     *
     * Get tx rollup rejection by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRejectionOpsByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupRejectionOpsByHashAsyncWithHttpInfo(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupRejectionOpsByHash'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\TxRollupRejectionOperation[]';
        $request = $this->operationsGetTxRollupRejectionOpsByHashRequest($hash, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupRejectionOpsByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRejectionOpsByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupRejectionOpsByHashRequest(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupRejectionOpsByHash'][0]
    ): Request
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetTxRollupRejectionOpsByHash'
            );
        }



        $resourcePath = '/v1/operations/tx_rollup_rejection/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupRejectionOpsCount
     *
     * Get tx rollup rejection count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRejectionOpsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return int
     */
    public function operationsGetTxRollupRejectionOpsCount(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetTxRollupRejectionOpsCount'][0]
    ): int
    {
        list($response) = $this->operationsGetTxRollupRejectionOpsCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupRejectionOpsCountWithHttpInfo
     *
     * Get tx rollup rejection count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRejectionOpsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupRejectionOpsCountWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetTxRollupRejectionOpsCount'][0]
    ): array
    {
        $request = $this->operationsGetTxRollupRejectionOpsCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('int', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'int';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupRejectionOpsCountAsync
     *
     * Get tx rollup rejection count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRejectionOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupRejectionOpsCountAsync(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetTxRollupRejectionOpsCount'][0]
    ): PromiseInterface
    {
        return $this->operationsGetTxRollupRejectionOpsCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupRejectionOpsCountAsyncWithHttpInfo
     *
     * Get tx rollup rejection count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRejectionOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupRejectionOpsCountAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetTxRollupRejectionOpsCount'][0]
    ): PromiseInterface
    {
        $returnType = 'int';
        $request = $this->operationsGetTxRollupRejectionOpsCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupRejectionOpsCount'
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRejectionOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupRejectionOpsCountRequest(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetTxRollupRejectionOpsCount'][0]
    ): Request
    {




        $resourcePath = '/v1/operations/tx_rollup_rejection/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupRejectionStatus
     *
     * Get tx rollup rejection status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRejectionStatus'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return bool
     */
    public function operationsGetTxRollupRejectionStatus(
        string $hash,
        string $contentType = self::contentTypes['operationsGetTxRollupRejectionStatus'][0]
    ): bool
    {
        list($response) = $this->operationsGetTxRollupRejectionStatusWithHttpInfo($hash, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupRejectionStatusWithHttpInfo
     *
     * Get tx rollup rejection status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRejectionStatus'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of bool, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupRejectionStatusWithHttpInfo(
        string $hash,
        string $contentType = self::contentTypes['operationsGetTxRollupRejectionStatus'][0]
    ): array
    {
        $request = $this->operationsGetTxRollupRejectionStatusRequest($hash, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('bool', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('bool' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'bool', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'bool';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'bool',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupRejectionStatusAsync
     *
     * Get tx rollup rejection status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRejectionStatus'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupRejectionStatusAsync(
        string $hash,
        string $contentType = self::contentTypes['operationsGetTxRollupRejectionStatus'][0]
    ): PromiseInterface
    {
        return $this->operationsGetTxRollupRejectionStatusAsyncWithHttpInfo($hash, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupRejectionStatusAsyncWithHttpInfo
     *
     * Get tx rollup rejection status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRejectionStatus'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupRejectionStatusAsyncWithHttpInfo(
        string $hash,
        string $contentType = self::contentTypes['operationsGetTxRollupRejectionStatus'][0]
    ): PromiseInterface
    {
        $returnType = 'bool';
        $request = $this->operationsGetTxRollupRejectionStatusRequest($hash, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupRejectionStatus'
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRejectionStatus'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupRejectionStatusRequest(
        string $hash,
        string $contentType = self::contentTypes['operationsGetTxRollupRejectionStatus'][0]
    ): Request
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetTxRollupRejectionStatus'
            );
        }


        $resourcePath = '/v1/operations/tx_rollup_rejection/{hash}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupRemoveCommitmentOps
     *
     * Get tx rollup remove commitment
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRemoveCommitmentOps'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\TxRollupRemoveCommitmentOperation[]
     */
    public function operationsGetTxRollupRemoveCommitmentOps(
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupRemoveCommitmentOps'][0]
    ): array
    {
        list($response) = $this->operationsGetTxRollupRemoveCommitmentOpsWithHttpInfo($sender, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupRemoveCommitmentOpsWithHttpInfo
     *
     * Get tx rollup remove commitment
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRemoveCommitmentOps'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\TxRollupRemoveCommitmentOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupRemoveCommitmentOpsWithHttpInfo(
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupRemoveCommitmentOps'][0]
    ): array
    {
        $request = $this->operationsGetTxRollupRemoveCommitmentOpsRequest($sender, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\TxRollupRemoveCommitmentOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\TxRollupRemoveCommitmentOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\TxRollupRemoveCommitmentOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\TxRollupRemoveCommitmentOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\TxRollupRemoveCommitmentOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupRemoveCommitmentOpsAsync
     *
     * Get tx rollup remove commitment
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRemoveCommitmentOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupRemoveCommitmentOpsAsync(
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupRemoveCommitmentOps'][0]
    ): PromiseInterface
    {
        return $this->operationsGetTxRollupRemoveCommitmentOpsAsyncWithHttpInfo($sender, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupRemoveCommitmentOpsAsyncWithHttpInfo
     *
     * Get tx rollup remove commitment
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRemoveCommitmentOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupRemoveCommitmentOpsAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupRemoveCommitmentOps'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\TxRollupRemoveCommitmentOperation[]';
        $request = $this->operationsGetTxRollupRemoveCommitmentOpsRequest($sender, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupRemoveCommitmentOps'
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRemoveCommitmentOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupRemoveCommitmentOpsRequest(
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupRemoveCommitmentOps'][0]
    ): Request
    {









        if ($limit !== null && $limit > 10000) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetTxRollupRemoveCommitmentOps, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetTxRollupRemoveCommitmentOps, must be bigger than or equal to 0.');
        }
        


        $resourcePath = '/v1/operations/tx_rollup_remove_commitment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rollup,
            'rollup', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            '\Tzkt\Model\OperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            '\Tzkt\Model\SelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            '\Tzkt\Model\SortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            '\Tzkt\Model\OffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupRemoveCommitmentOpsByHash
     *
     * Get tx rollup remove commitment by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRemoveCommitmentOpsByHash'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\TxRollupRemoveCommitmentOperation[]
     */
    public function operationsGetTxRollupRemoveCommitmentOpsByHash(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupRemoveCommitmentOpsByHash'][0]
    ): array
    {
        list($response) = $this->operationsGetTxRollupRemoveCommitmentOpsByHashWithHttpInfo($hash, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupRemoveCommitmentOpsByHashWithHttpInfo
     *
     * Get tx rollup remove commitment by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRemoveCommitmentOpsByHash'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\TxRollupRemoveCommitmentOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupRemoveCommitmentOpsByHashWithHttpInfo(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupRemoveCommitmentOpsByHash'][0]
    ): array
    {
        $request = $this->operationsGetTxRollupRemoveCommitmentOpsByHashRequest($hash, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\TxRollupRemoveCommitmentOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\TxRollupRemoveCommitmentOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\TxRollupRemoveCommitmentOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\TxRollupRemoveCommitmentOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\TxRollupRemoveCommitmentOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupRemoveCommitmentOpsByHashAsync
     *
     * Get tx rollup remove commitment by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRemoveCommitmentOpsByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupRemoveCommitmentOpsByHashAsync(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupRemoveCommitmentOpsByHash'][0]
    ): PromiseInterface
    {
        return $this->operationsGetTxRollupRemoveCommitmentOpsByHashAsyncWithHttpInfo($hash, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupRemoveCommitmentOpsByHashAsyncWithHttpInfo
     *
     * Get tx rollup remove commitment by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRemoveCommitmentOpsByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupRemoveCommitmentOpsByHashAsyncWithHttpInfo(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupRemoveCommitmentOpsByHash'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\TxRollupRemoveCommitmentOperation[]';
        $request = $this->operationsGetTxRollupRemoveCommitmentOpsByHashRequest($hash, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupRemoveCommitmentOpsByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRemoveCommitmentOpsByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupRemoveCommitmentOpsByHashRequest(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupRemoveCommitmentOpsByHash'][0]
    ): Request
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetTxRollupRemoveCommitmentOpsByHash'
            );
        }



        $resourcePath = '/v1/operations/tx_rollup_remove_commitment/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupRemoveCommitmentOpsCount
     *
     * Get tx rollup remove commitment count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRemoveCommitmentOpsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return int
     */
    public function operationsGetTxRollupRemoveCommitmentOpsCount(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetTxRollupRemoveCommitmentOpsCount'][0]
    ): int
    {
        list($response) = $this->operationsGetTxRollupRemoveCommitmentOpsCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupRemoveCommitmentOpsCountWithHttpInfo
     *
     * Get tx rollup remove commitment count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRemoveCommitmentOpsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupRemoveCommitmentOpsCountWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetTxRollupRemoveCommitmentOpsCount'][0]
    ): array
    {
        $request = $this->operationsGetTxRollupRemoveCommitmentOpsCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('int', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'int';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupRemoveCommitmentOpsCountAsync
     *
     * Get tx rollup remove commitment count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRemoveCommitmentOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupRemoveCommitmentOpsCountAsync(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetTxRollupRemoveCommitmentOpsCount'][0]
    ): PromiseInterface
    {
        return $this->operationsGetTxRollupRemoveCommitmentOpsCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupRemoveCommitmentOpsCountAsyncWithHttpInfo
     *
     * Get tx rollup remove commitment count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRemoveCommitmentOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupRemoveCommitmentOpsCountAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetTxRollupRemoveCommitmentOpsCount'][0]
    ): PromiseInterface
    {
        $returnType = 'int';
        $request = $this->operationsGetTxRollupRemoveCommitmentOpsCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupRemoveCommitmentOpsCount'
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRemoveCommitmentOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupRemoveCommitmentOpsCountRequest(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetTxRollupRemoveCommitmentOpsCount'][0]
    ): Request
    {




        $resourcePath = '/v1/operations/tx_rollup_remove_commitment/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupRemoveCommitmentStatus
     *
     * Get tx rollup remove commitment status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRemoveCommitmentStatus'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return bool
     */
    public function operationsGetTxRollupRemoveCommitmentStatus(
        string $hash,
        string $contentType = self::contentTypes['operationsGetTxRollupRemoveCommitmentStatus'][0]
    ): bool
    {
        list($response) = $this->operationsGetTxRollupRemoveCommitmentStatusWithHttpInfo($hash, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupRemoveCommitmentStatusWithHttpInfo
     *
     * Get tx rollup remove commitment status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRemoveCommitmentStatus'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of bool, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupRemoveCommitmentStatusWithHttpInfo(
        string $hash,
        string $contentType = self::contentTypes['operationsGetTxRollupRemoveCommitmentStatus'][0]
    ): array
    {
        $request = $this->operationsGetTxRollupRemoveCommitmentStatusRequest($hash, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('bool', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('bool' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'bool', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'bool';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'bool',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupRemoveCommitmentStatusAsync
     *
     * Get tx rollup remove commitment status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRemoveCommitmentStatus'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupRemoveCommitmentStatusAsync(
        string $hash,
        string $contentType = self::contentTypes['operationsGetTxRollupRemoveCommitmentStatus'][0]
    ): PromiseInterface
    {
        return $this->operationsGetTxRollupRemoveCommitmentStatusAsyncWithHttpInfo($hash, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupRemoveCommitmentStatusAsyncWithHttpInfo
     *
     * Get tx rollup remove commitment status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRemoveCommitmentStatus'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupRemoveCommitmentStatusAsyncWithHttpInfo(
        string $hash,
        string $contentType = self::contentTypes['operationsGetTxRollupRemoveCommitmentStatus'][0]
    ): PromiseInterface
    {
        $returnType = 'bool';
        $request = $this->operationsGetTxRollupRemoveCommitmentStatusRequest($hash, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupRemoveCommitmentStatus'
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRemoveCommitmentStatus'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupRemoveCommitmentStatusRequest(
        string $hash,
        string $contentType = self::contentTypes['operationsGetTxRollupRemoveCommitmentStatus'][0]
    ): Request
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetTxRollupRemoveCommitmentStatus'
            );
        }


        $resourcePath = '/v1/operations/tx_rollup_remove_commitment/{hash}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupReturnBondOps
     *
     * Get tx rollup return bond
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupReturnBondOps'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\TxRollupReturnBondOperation[]
     */
    public function operationsGetTxRollupReturnBondOps(
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupReturnBondOps'][0]
    ): array
    {
        list($response) = $this->operationsGetTxRollupReturnBondOpsWithHttpInfo($sender, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupReturnBondOpsWithHttpInfo
     *
     * Get tx rollup return bond
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupReturnBondOps'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\TxRollupReturnBondOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupReturnBondOpsWithHttpInfo(
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupReturnBondOps'][0]
    ): array
    {
        $request = $this->operationsGetTxRollupReturnBondOpsRequest($sender, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\TxRollupReturnBondOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\TxRollupReturnBondOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\TxRollupReturnBondOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\TxRollupReturnBondOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\TxRollupReturnBondOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupReturnBondOpsAsync
     *
     * Get tx rollup return bond
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupReturnBondOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupReturnBondOpsAsync(
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupReturnBondOps'][0]
    ): PromiseInterface
    {
        return $this->operationsGetTxRollupReturnBondOpsAsyncWithHttpInfo($sender, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupReturnBondOpsAsyncWithHttpInfo
     *
     * Get tx rollup return bond
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupReturnBondOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupReturnBondOpsAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupReturnBondOps'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\TxRollupReturnBondOperation[]';
        $request = $this->operationsGetTxRollupReturnBondOpsRequest($sender, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupReturnBondOps'
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupReturnBondOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupReturnBondOpsRequest(
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupReturnBondOps'][0]
    ): Request
    {









        if ($limit !== null && $limit > 10000) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetTxRollupReturnBondOps, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetTxRollupReturnBondOps, must be bigger than or equal to 0.');
        }
        


        $resourcePath = '/v1/operations/tx_rollup_return_bond';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rollup,
            'rollup', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            '\Tzkt\Model\OperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            '\Tzkt\Model\SelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            '\Tzkt\Model\SortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            '\Tzkt\Model\OffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupReturnBondOpsByHash
     *
     * Get tx rollup return bond by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupReturnBondOpsByHash'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\TxRollupReturnBondOperation[]
     */
    public function operationsGetTxRollupReturnBondOpsByHash(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupReturnBondOpsByHash'][0]
    ): array
    {
        list($response) = $this->operationsGetTxRollupReturnBondOpsByHashWithHttpInfo($hash, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupReturnBondOpsByHashWithHttpInfo
     *
     * Get tx rollup return bond by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupReturnBondOpsByHash'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\TxRollupReturnBondOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupReturnBondOpsByHashWithHttpInfo(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupReturnBondOpsByHash'][0]
    ): array
    {
        $request = $this->operationsGetTxRollupReturnBondOpsByHashRequest($hash, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\TxRollupReturnBondOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\TxRollupReturnBondOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\TxRollupReturnBondOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\TxRollupReturnBondOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\TxRollupReturnBondOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupReturnBondOpsByHashAsync
     *
     * Get tx rollup return bond by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupReturnBondOpsByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupReturnBondOpsByHashAsync(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupReturnBondOpsByHash'][0]
    ): PromiseInterface
    {
        return $this->operationsGetTxRollupReturnBondOpsByHashAsyncWithHttpInfo($hash, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupReturnBondOpsByHashAsyncWithHttpInfo
     *
     * Get tx rollup return bond by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupReturnBondOpsByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupReturnBondOpsByHashAsyncWithHttpInfo(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupReturnBondOpsByHash'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\TxRollupReturnBondOperation[]';
        $request = $this->operationsGetTxRollupReturnBondOpsByHashRequest($hash, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupReturnBondOpsByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupReturnBondOpsByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupReturnBondOpsByHashRequest(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupReturnBondOpsByHash'][0]
    ): Request
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetTxRollupReturnBondOpsByHash'
            );
        }



        $resourcePath = '/v1/operations/tx_rollup_return_bond/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupReturnBondOpsCount
     *
     * Get tx rollup return bond count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupReturnBondOpsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return int
     */
    public function operationsGetTxRollupReturnBondOpsCount(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetTxRollupReturnBondOpsCount'][0]
    ): int
    {
        list($response) = $this->operationsGetTxRollupReturnBondOpsCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupReturnBondOpsCountWithHttpInfo
     *
     * Get tx rollup return bond count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupReturnBondOpsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupReturnBondOpsCountWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetTxRollupReturnBondOpsCount'][0]
    ): array
    {
        $request = $this->operationsGetTxRollupReturnBondOpsCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('int', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'int';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupReturnBondOpsCountAsync
     *
     * Get tx rollup return bond count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupReturnBondOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupReturnBondOpsCountAsync(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetTxRollupReturnBondOpsCount'][0]
    ): PromiseInterface
    {
        return $this->operationsGetTxRollupReturnBondOpsCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupReturnBondOpsCountAsyncWithHttpInfo
     *
     * Get tx rollup return bond count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupReturnBondOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupReturnBondOpsCountAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetTxRollupReturnBondOpsCount'][0]
    ): PromiseInterface
    {
        $returnType = 'int';
        $request = $this->operationsGetTxRollupReturnBondOpsCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupReturnBondOpsCount'
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupReturnBondOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupReturnBondOpsCountRequest(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetTxRollupReturnBondOpsCount'][0]
    ): Request
    {




        $resourcePath = '/v1/operations/tx_rollup_return_bond/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupReturnBondStatus
     *
     * Get tx rollup return bond status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupReturnBondStatus'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return bool
     */
    public function operationsGetTxRollupReturnBondStatus(
        string $hash,
        string $contentType = self::contentTypes['operationsGetTxRollupReturnBondStatus'][0]
    ): bool
    {
        list($response) = $this->operationsGetTxRollupReturnBondStatusWithHttpInfo($hash, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupReturnBondStatusWithHttpInfo
     *
     * Get tx rollup return bond status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupReturnBondStatus'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of bool, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupReturnBondStatusWithHttpInfo(
        string $hash,
        string $contentType = self::contentTypes['operationsGetTxRollupReturnBondStatus'][0]
    ): array
    {
        $request = $this->operationsGetTxRollupReturnBondStatusRequest($hash, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('bool', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('bool' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'bool', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'bool';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'bool',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupReturnBondStatusAsync
     *
     * Get tx rollup return bond status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupReturnBondStatus'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupReturnBondStatusAsync(
        string $hash,
        string $contentType = self::contentTypes['operationsGetTxRollupReturnBondStatus'][0]
    ): PromiseInterface
    {
        return $this->operationsGetTxRollupReturnBondStatusAsyncWithHttpInfo($hash, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupReturnBondStatusAsyncWithHttpInfo
     *
     * Get tx rollup return bond status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupReturnBondStatus'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupReturnBondStatusAsyncWithHttpInfo(
        string $hash,
        string $contentType = self::contentTypes['operationsGetTxRollupReturnBondStatus'][0]
    ): PromiseInterface
    {
        $returnType = 'bool';
        $request = $this->operationsGetTxRollupReturnBondStatusRequest($hash, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupReturnBondStatus'
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupReturnBondStatus'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupReturnBondStatusRequest(
        string $hash,
        string $contentType = self::contentTypes['operationsGetTxRollupReturnBondStatus'][0]
    ): Request
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetTxRollupReturnBondStatus'
            );
        }


        $resourcePath = '/v1/operations/tx_rollup_return_bond/{hash}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupSubmitBatchOps
     *
     * Get tx rollup submit batch
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupSubmitBatchOps'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\TxRollupSubmitBatchOperation[]
     */
    public function operationsGetTxRollupSubmitBatchOps(
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupSubmitBatchOps'][0]
    ): array
    {
        list($response) = $this->operationsGetTxRollupSubmitBatchOpsWithHttpInfo($sender, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupSubmitBatchOpsWithHttpInfo
     *
     * Get tx rollup submit batch
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupSubmitBatchOps'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\TxRollupSubmitBatchOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupSubmitBatchOpsWithHttpInfo(
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupSubmitBatchOps'][0]
    ): array
    {
        $request = $this->operationsGetTxRollupSubmitBatchOpsRequest($sender, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\TxRollupSubmitBatchOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\TxRollupSubmitBatchOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\TxRollupSubmitBatchOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\TxRollupSubmitBatchOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\TxRollupSubmitBatchOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupSubmitBatchOpsAsync
     *
     * Get tx rollup submit batch
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupSubmitBatchOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupSubmitBatchOpsAsync(
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupSubmitBatchOps'][0]
    ): PromiseInterface
    {
        return $this->operationsGetTxRollupSubmitBatchOpsAsyncWithHttpInfo($sender, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupSubmitBatchOpsAsyncWithHttpInfo
     *
     * Get tx rollup submit batch
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupSubmitBatchOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupSubmitBatchOpsAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupSubmitBatchOps'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\TxRollupSubmitBatchOperation[]';
        $request = $this->operationsGetTxRollupSubmitBatchOpsRequest($sender, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupSubmitBatchOps'
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupSubmitBatchOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupSubmitBatchOpsRequest(
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetDelegateParameter $rollup = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupSubmitBatchOps'][0]
    ): Request
    {









        if ($limit !== null && $limit > 10000) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetTxRollupSubmitBatchOps, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetTxRollupSubmitBatchOps, must be bigger than or equal to 0.');
        }
        


        $resourcePath = '/v1/operations/tx_rollup_submit_batch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rollup,
            'rollup', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            '\Tzkt\Model\OperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            '\Tzkt\Model\SelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            '\Tzkt\Model\SortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            '\Tzkt\Model\OffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupSubmitBatchOpsByHash
     *
     * Get tx rollup submit batch by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupSubmitBatchOpsByHash'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\TxRollupSubmitBatchOperation[]
     */
    public function operationsGetTxRollupSubmitBatchOpsByHash(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupSubmitBatchOpsByHash'][0]
    ): array
    {
        list($response) = $this->operationsGetTxRollupSubmitBatchOpsByHashWithHttpInfo($hash, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupSubmitBatchOpsByHashWithHttpInfo
     *
     * Get tx rollup submit batch by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupSubmitBatchOpsByHash'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\TxRollupSubmitBatchOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupSubmitBatchOpsByHashWithHttpInfo(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupSubmitBatchOpsByHash'][0]
    ): array
    {
        $request = $this->operationsGetTxRollupSubmitBatchOpsByHashRequest($hash, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\TxRollupSubmitBatchOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\TxRollupSubmitBatchOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\TxRollupSubmitBatchOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\TxRollupSubmitBatchOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\TxRollupSubmitBatchOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupSubmitBatchOpsByHashAsync
     *
     * Get tx rollup submit batch by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupSubmitBatchOpsByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupSubmitBatchOpsByHashAsync(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupSubmitBatchOpsByHash'][0]
    ): PromiseInterface
    {
        return $this->operationsGetTxRollupSubmitBatchOpsByHashAsyncWithHttpInfo($hash, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupSubmitBatchOpsByHashAsyncWithHttpInfo
     *
     * Get tx rollup submit batch by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupSubmitBatchOpsByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupSubmitBatchOpsByHashAsyncWithHttpInfo(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupSubmitBatchOpsByHash'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\TxRollupSubmitBatchOperation[]';
        $request = $this->operationsGetTxRollupSubmitBatchOpsByHashRequest($hash, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupSubmitBatchOpsByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupSubmitBatchOpsByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupSubmitBatchOpsByHashRequest(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetTxRollupSubmitBatchOpsByHash'][0]
    ): Request
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetTxRollupSubmitBatchOpsByHash'
            );
        }



        $resourcePath = '/v1/operations/tx_rollup_submit_batch/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupSubmitBatchOpsCount
     *
     * Get tx rollup submit batch count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupSubmitBatchOpsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return int
     */
    public function operationsGetTxRollupSubmitBatchOpsCount(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetTxRollupSubmitBatchOpsCount'][0]
    ): int
    {
        list($response) = $this->operationsGetTxRollupSubmitBatchOpsCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupSubmitBatchOpsCountWithHttpInfo
     *
     * Get tx rollup submit batch count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupSubmitBatchOpsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupSubmitBatchOpsCountWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetTxRollupSubmitBatchOpsCount'][0]
    ): array
    {
        $request = $this->operationsGetTxRollupSubmitBatchOpsCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('int', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'int';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupSubmitBatchOpsCountAsync
     *
     * Get tx rollup submit batch count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupSubmitBatchOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupSubmitBatchOpsCountAsync(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetTxRollupSubmitBatchOpsCount'][0]
    ): PromiseInterface
    {
        return $this->operationsGetTxRollupSubmitBatchOpsCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupSubmitBatchOpsCountAsyncWithHttpInfo
     *
     * Get tx rollup submit batch count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupSubmitBatchOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupSubmitBatchOpsCountAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetTxRollupSubmitBatchOpsCount'][0]
    ): PromiseInterface
    {
        $returnType = 'int';
        $request = $this->operationsGetTxRollupSubmitBatchOpsCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupSubmitBatchOpsCount'
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupSubmitBatchOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupSubmitBatchOpsCountRequest(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetTxRollupSubmitBatchOpsCount'][0]
    ): Request
    {




        $resourcePath = '/v1/operations/tx_rollup_submit_batch/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupSubmitBatchStatus
     *
     * Get tx rollup submit batch status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupSubmitBatchStatus'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return bool
     */
    public function operationsGetTxRollupSubmitBatchStatus(
        string $hash,
        string $contentType = self::contentTypes['operationsGetTxRollupSubmitBatchStatus'][0]
    ): bool
    {
        list($response) = $this->operationsGetTxRollupSubmitBatchStatusWithHttpInfo($hash, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupSubmitBatchStatusWithHttpInfo
     *
     * Get tx rollup submit batch status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupSubmitBatchStatus'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of bool, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupSubmitBatchStatusWithHttpInfo(
        string $hash,
        string $contentType = self::contentTypes['operationsGetTxRollupSubmitBatchStatus'][0]
    ): array
    {
        $request = $this->operationsGetTxRollupSubmitBatchStatusRequest($hash, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('bool', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('bool' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'bool', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'bool';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'bool',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupSubmitBatchStatusAsync
     *
     * Get tx rollup submit batch status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupSubmitBatchStatus'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupSubmitBatchStatusAsync(
        string $hash,
        string $contentType = self::contentTypes['operationsGetTxRollupSubmitBatchStatus'][0]
    ): PromiseInterface
    {
        return $this->operationsGetTxRollupSubmitBatchStatusAsyncWithHttpInfo($hash, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupSubmitBatchStatusAsyncWithHttpInfo
     *
     * Get tx rollup submit batch status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupSubmitBatchStatus'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetTxRollupSubmitBatchStatusAsyncWithHttpInfo(
        string $hash,
        string $contentType = self::contentTypes['operationsGetTxRollupSubmitBatchStatus'][0]
    ): PromiseInterface
    {
        $returnType = 'bool';
        $request = $this->operationsGetTxRollupSubmitBatchStatusRequest($hash, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupSubmitBatchStatus'
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupSubmitBatchStatus'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupSubmitBatchStatusRequest(
        string $hash,
        string $contentType = self::contentTypes['operationsGetTxRollupSubmitBatchStatus'][0]
    ): Request
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetTxRollupSubmitBatchStatus'
            );
        }


        $resourcePath = '/v1/operations/tx_rollup_submit_batch/{hash}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetUpdateConsensusKeyByHash
     *
     * Get update consensus key by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetUpdateConsensusKeyByHash'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\UpdateConsensusKeyOperation[]
     */
    public function operationsGetUpdateConsensusKeyByHash(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetUpdateConsensusKeyByHash'][0]
    ): array
    {
        list($response) = $this->operationsGetUpdateConsensusKeyByHashWithHttpInfo($hash, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetUpdateConsensusKeyByHashWithHttpInfo
     *
     * Get update consensus key by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetUpdateConsensusKeyByHash'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\UpdateConsensusKeyOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetUpdateConsensusKeyByHashWithHttpInfo(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetUpdateConsensusKeyByHash'][0]
    ): array
    {
        $request = $this->operationsGetUpdateConsensusKeyByHashRequest($hash, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\UpdateConsensusKeyOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\UpdateConsensusKeyOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\UpdateConsensusKeyOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\UpdateConsensusKeyOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\UpdateConsensusKeyOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetUpdateConsensusKeyByHashAsync
     *
     * Get update consensus key by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetUpdateConsensusKeyByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetUpdateConsensusKeyByHashAsync(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetUpdateConsensusKeyByHash'][0]
    ): PromiseInterface
    {
        return $this->operationsGetUpdateConsensusKeyByHashAsyncWithHttpInfo($hash, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetUpdateConsensusKeyByHashAsyncWithHttpInfo
     *
     * Get update consensus key by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetUpdateConsensusKeyByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetUpdateConsensusKeyByHashAsyncWithHttpInfo(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetUpdateConsensusKeyByHash'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\UpdateConsensusKeyOperation[]';
        $request = $this->operationsGetUpdateConsensusKeyByHashRequest($hash, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetUpdateConsensusKeyByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetUpdateConsensusKeyByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetUpdateConsensusKeyByHashRequest(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetUpdateConsensusKeyByHash'][0]
    ): Request
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetUpdateConsensusKeyByHash'
            );
        }



        $resourcePath = '/v1/operations/update_consensus_key/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetUpdateConsensusKeyOps
     *
     * Get update consensus key
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $activation_cycle Filters by activation cycle. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetAddressParameter|null $public_key_hash Filters by pkh (tz address). (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetUpdateConsensusKeyOps'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\UpdateConsensusKeyOperation[]
     */
    public function operationsGetUpdateConsensusKeyOps(
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetIdParameter $activation_cycle = null,
        ?\Tzkt\Model\AccountsGetAddressParameter $public_key_hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetUpdateConsensusKeyOps'][0]
    ): array
    {
        list($response) = $this->operationsGetUpdateConsensusKeyOpsWithHttpInfo($sender, $activation_cycle, $public_key_hash, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetUpdateConsensusKeyOpsWithHttpInfo
     *
     * Get update consensus key
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $activation_cycle Filters by activation cycle. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetAddressParameter|null $public_key_hash Filters by pkh (tz address). (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetUpdateConsensusKeyOps'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\UpdateConsensusKeyOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetUpdateConsensusKeyOpsWithHttpInfo(
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetIdParameter $activation_cycle = null,
        ?\Tzkt\Model\AccountsGetAddressParameter $public_key_hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetUpdateConsensusKeyOps'][0]
    ): array
    {
        $request = $this->operationsGetUpdateConsensusKeyOpsRequest($sender, $activation_cycle, $public_key_hash, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\UpdateConsensusKeyOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\UpdateConsensusKeyOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\UpdateConsensusKeyOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\UpdateConsensusKeyOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\UpdateConsensusKeyOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetUpdateConsensusKeyOpsAsync
     *
     * Get update consensus key
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $activation_cycle Filters by activation cycle. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetAddressParameter|null $public_key_hash Filters by pkh (tz address). (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetUpdateConsensusKeyOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetUpdateConsensusKeyOpsAsync(
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetIdParameter $activation_cycle = null,
        ?\Tzkt\Model\AccountsGetAddressParameter $public_key_hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetUpdateConsensusKeyOps'][0]
    ): PromiseInterface
    {
        return $this->operationsGetUpdateConsensusKeyOpsAsyncWithHttpInfo($sender, $activation_cycle, $public_key_hash, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetUpdateConsensusKeyOpsAsyncWithHttpInfo
     *
     * Get update consensus key
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $activation_cycle Filters by activation cycle. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetAddressParameter|null $public_key_hash Filters by pkh (tz address). (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetUpdateConsensusKeyOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetUpdateConsensusKeyOpsAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetIdParameter $activation_cycle = null,
        ?\Tzkt\Model\AccountsGetAddressParameter $public_key_hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetUpdateConsensusKeyOps'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\UpdateConsensusKeyOperation[]';
        $request = $this->operationsGetUpdateConsensusKeyOpsRequest($sender, $activation_cycle, $public_key_hash, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetUpdateConsensusKeyOps'
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $activation_cycle Filters by activation cycle. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetAddressParameter|null $public_key_hash Filters by pkh (tz address). (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsStatusParameter|null $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetUpdateConsensusKeyOps'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetUpdateConsensusKeyOpsRequest(
        ?\Tzkt\Model\AccountsGetDelegateParameter $sender = null,
        ?\Tzkt\Model\AccountsGetIdParameter $activation_cycle = null,
        ?\Tzkt\Model\AccountsGetAddressParameter $public_key_hash = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetOperationsStatusParameter $status = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetUpdateConsensusKeyOps'][0]
    ): Request
    {










        if ($limit !== null && $limit > 10000) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetUpdateConsensusKeyOps, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetUpdateConsensusKeyOps, must be bigger than or equal to 0.');
        }
        


        $resourcePath = '/v1/operations/update_consensus_key';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $activation_cycle,
            'activationCycle', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $public_key_hash,
            'publicKeyHash', // param base name
            '\Tzkt\Model\AddressParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            '\Tzkt\Model\OperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            '\Tzkt\Model\SelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            '\Tzkt\Model\SortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            '\Tzkt\Model\OffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetUpdateConsensusKeyOpsCount
     *
     * Get update consensus key count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetUpdateConsensusKeyOpsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return int
     */
    public function operationsGetUpdateConsensusKeyOpsCount(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetUpdateConsensusKeyOpsCount'][0]
    ): int
    {
        list($response) = $this->operationsGetUpdateConsensusKeyOpsCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetUpdateConsensusKeyOpsCountWithHttpInfo
     *
     * Get update consensus key count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetUpdateConsensusKeyOpsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetUpdateConsensusKeyOpsCountWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetUpdateConsensusKeyOpsCount'][0]
    ): array
    {
        $request = $this->operationsGetUpdateConsensusKeyOpsCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('int', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'int';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetUpdateConsensusKeyOpsCountAsync
     *
     * Get update consensus key count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetUpdateConsensusKeyOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetUpdateConsensusKeyOpsCountAsync(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetUpdateConsensusKeyOpsCount'][0]
    ): PromiseInterface
    {
        return $this->operationsGetUpdateConsensusKeyOpsCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetUpdateConsensusKeyOpsCountAsyncWithHttpInfo
     *
     * Get update consensus key count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetUpdateConsensusKeyOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetUpdateConsensusKeyOpsCountAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetUpdateConsensusKeyOpsCount'][0]
    ): PromiseInterface
    {
        $returnType = 'int';
        $request = $this->operationsGetUpdateConsensusKeyOpsCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetUpdateConsensusKeyOpsCount'
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters operations by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetUpdateConsensusKeyOpsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetUpdateConsensusKeyOpsCountRequest(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetUpdateConsensusKeyOpsCount'][0]
    ): Request
    {




        $resourcePath = '/v1/operations/update_consensus_key/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetVdfRevelationByHash
     *
     * Get vdf revelation by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetVdfRevelationByHash'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\VdfRevelationOperation[]
     */
    public function operationsGetVdfRevelationByHash(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetVdfRevelationByHash'][0]
    ): array
    {
        list($response) = $this->operationsGetVdfRevelationByHashWithHttpInfo($hash, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetVdfRevelationByHashWithHttpInfo
     *
     * Get vdf revelation by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetVdfRevelationByHash'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\VdfRevelationOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetVdfRevelationByHashWithHttpInfo(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetVdfRevelationByHash'][0]
    ): array
    {
        $request = $this->operationsGetVdfRevelationByHashRequest($hash, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\VdfRevelationOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\VdfRevelationOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\VdfRevelationOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\VdfRevelationOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\VdfRevelationOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetVdfRevelationByHashAsync
     *
     * Get vdf revelation by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetVdfRevelationByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetVdfRevelationByHashAsync(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetVdfRevelationByHash'][0]
    ): PromiseInterface
    {
        return $this->operationsGetVdfRevelationByHashAsyncWithHttpInfo($hash, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetVdfRevelationByHashAsyncWithHttpInfo
     *
     * Get vdf revelation by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetVdfRevelationByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetVdfRevelationByHashAsyncWithHttpInfo(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetVdfRevelationByHash'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\VdfRevelationOperation[]';
        $request = $this->operationsGetVdfRevelationByHashRequest($hash, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetVdfRevelationByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetVdfRevelationByHash'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetVdfRevelationByHashRequest(
        string $hash,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetVdfRevelationByHash'][0]
    ): Request
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetVdfRevelationByHash'
            );
        }



        $resourcePath = '/v1/operations/vdf_revelations/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetVdfRevelations
     *
     * Get vdf revelations
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $baker Filters by baker. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $cycle Filters by cycle in which the operation was included. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetVdfRevelations'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \Tzkt\Model\VdfRevelationOperation[]
     */
    public function operationsGetVdfRevelations(
        ?\Tzkt\Model\AccountsGetDelegateParameter $baker = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetIdParameter $cycle = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetVdfRevelations'][0]
    ): array
    {
        list($response) = $this->operationsGetVdfRevelationsWithHttpInfo($baker, $level, $cycle, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetVdfRevelationsWithHttpInfo
     *
     * Get vdf revelations
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $baker Filters by baker. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $cycle Filters by cycle in which the operation was included. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetVdfRevelations'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \Tzkt\Model\VdfRevelationOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetVdfRevelationsWithHttpInfo(
        ?\Tzkt\Model\AccountsGetDelegateParameter $baker = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetIdParameter $cycle = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetVdfRevelations'][0]
    ): array
    {
        $request = $this->operationsGetVdfRevelationsRequest($baker, $level, $cycle, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\Tzkt\Model\VdfRevelationOperation[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tzkt\Model\VdfRevelationOperation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tzkt\Model\VdfRevelationOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Tzkt\Model\VdfRevelationOperation[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tzkt\Model\VdfRevelationOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetVdfRevelationsAsync
     *
     * Get vdf revelations
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $baker Filters by baker. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $cycle Filters by cycle in which the operation was included. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetVdfRevelations'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetVdfRevelationsAsync(
        ?\Tzkt\Model\AccountsGetDelegateParameter $baker = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetIdParameter $cycle = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetVdfRevelations'][0]
    ): PromiseInterface
    {
        return $this->operationsGetVdfRevelationsAsyncWithHttpInfo($baker, $level, $cycle, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetVdfRevelationsAsyncWithHttpInfo
     *
     * Get vdf revelations
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $baker Filters by baker. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $cycle Filters by cycle in which the operation was included. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetVdfRevelations'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetVdfRevelationsAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetDelegateParameter $baker = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetIdParameter $cycle = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetVdfRevelations'][0]
    ): PromiseInterface
    {
        $returnType = '\Tzkt\Model\VdfRevelationOperation[]';
        $request = $this->operationsGetVdfRevelationsRequest($baker, $level, $cycle, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetVdfRevelations'
     *
     * @param  \Tzkt\Model\AccountsGetDelegateParameter|null $baker Filters by baker. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $cycle Filters by cycle in which the operation was included. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  \Tzkt\Model\AccountsGetSelectParameter|null $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  \Tzkt\Model\AccountsGetSortParameter|null $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  \Tzkt\Model\AccountsGetOffsetParameter|null $offset Specifies which or how many items should be skipped (optional)
     * @param  int|null $limit Maximum number of items to return (optional, default to 100)
     * @param  \Tzkt\Model\AccountsGetOperationsQuoteParameter|null $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetVdfRevelations'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetVdfRevelationsRequest(
        ?\Tzkt\Model\AccountsGetDelegateParameter $baker = null,
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetIdParameter $cycle = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        ?\Tzkt\Model\AccountsGetSelectParameter $select = null,
        ?\Tzkt\Model\AccountsGetSortParameter $sort = null,
        ?\Tzkt\Model\AccountsGetOffsetParameter $offset = null,
        ?int $limit = 100,
        ?\Tzkt\Model\AccountsGetOperationsQuoteParameter $quote = null,
        string $contentType = self::contentTypes['operationsGetVdfRevelations'][0]
    ): Request
    {








        if ($limit !== null && $limit > 10000) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetVdfRevelations, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetVdfRevelations, must be bigger than or equal to 0.');
        }
        


        $resourcePath = '/v1/operations/vdf_revelations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $baker,
            'baker', // param base name
            '\Tzkt\Model\AccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cycle,
            'cycle', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            '\Tzkt\Model\SelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            '\Tzkt\Model\SortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            '\Tzkt\Model\OffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            '\Tzkt\Model\Symbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetVdfRevelationsCount
     *
     * Get vdf revelations count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetVdfRevelationsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return int
     */
    public function operationsGetVdfRevelationsCount(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetVdfRevelationsCount'][0]
    ): int
    {
        list($response) = $this->operationsGetVdfRevelationsCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetVdfRevelationsCountWithHttpInfo
     *
     * Get vdf revelations count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetVdfRevelationsCount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetVdfRevelationsCountWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetVdfRevelationsCount'][0]
    ): array
    {
        $request = $this->operationsGetVdfRevelationsCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('int', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'int';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetVdfRevelationsCountAsync
     *
     * Get vdf revelations count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetVdfRevelationsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetVdfRevelationsCountAsync(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetVdfRevelationsCount'][0]
    ): PromiseInterface
    {
        return $this->operationsGetVdfRevelationsCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetVdfRevelationsCountAsyncWithHttpInfo
     *
     * Get vdf revelations count
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetVdfRevelationsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function operationsGetVdfRevelationsCountAsyncWithHttpInfo(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetVdfRevelationsCount'][0]
    ): PromiseInterface
    {
        $returnType = 'int';
        $request = $this->operationsGetVdfRevelationsCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetVdfRevelationsCount'
     *
     * @param  \Tzkt\Model\AccountsGetIdParameter|null $level Filters by level. (optional)
     * @param  \Tzkt\Model\AccountsGetOperationsTimestampParameter|null $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetVdfRevelationsCount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetVdfRevelationsCountRequest(
        ?\Tzkt\Model\AccountsGetIdParameter $level = null,
        ?\Tzkt\Model\AccountsGetOperationsTimestampParameter $timestamp = null,
        string $contentType = self::contentTypes['operationsGetVdfRevelationsCount'][0]
    ): Request
    {




        $resourcePath = '/v1/operations/vdf_revelations/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            '\Tzkt\Model\Int32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            '\Tzkt\Model\DateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption(): array
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
